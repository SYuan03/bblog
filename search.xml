<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>饥荒私服搭建</title>
      <link href="/posts/%E6%9D%82%E8%AE%B0/%E9%A5%A5%E8%8D%92%E7%A7%81%E6%9C%8D%E6%90%AD%E5%BB%BA.html"/>
      <url>/posts/%E6%9D%82%E8%AE%B0/%E9%A5%A5%E8%8D%92%E7%A7%81%E6%9C%8D%E6%90%AD%E5%BB%BA.html</url>
      
        <content type="html"><![CDATA[<h2 id="参考">参考</h2><p><a class="link" href="https://leanote.zzzmh.cn/blog/post/admin/63e46785da7405001301c7f5">https://leanote.zzzmh.cn/blog/post/admin/63e46785da7405001301c7f5 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>]]></content>
      
      
      <categories>
          
          <category> 杂记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 服务器 </tag>
            
            <tag> 饥荒 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>开源LLM翻译能力简单评测</title>
      <link href="/posts/%E6%9D%82%E8%AE%B0/%E5%BC%80%E6%BA%90llm%E7%BF%BB%E8%AF%91%E8%83%BD%E5%8A%9B%E7%AE%80%E5%8D%95%E8%AF%84%E6%B5%8B.html"/>
      <url>/posts/%E6%9D%82%E8%AE%B0/%E5%BC%80%E6%BA%90llm%E7%BF%BB%E8%AF%91%E8%83%BD%E5%8A%9B%E7%AE%80%E5%8D%95%E8%AF%84%E6%B5%8B.html</url>
      
        <content type="html"><![CDATA[<p>主要依托siliconflow平台的免费金，想看看哪个模型翻译的好点</p><p>先看下目前账号可用的模型列表</p><p><a class="link" href="https://docs.siliconflow.cn/reference/retrieve-a-list-of-models-1">https://docs.siliconflow.cn/reference/retrieve-a-list-of-models-1 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p><div class="highlight-container" data-rel="Json"><figure class="iseeu highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;object&quot;</span><span class="punctuation">:</span> <span class="string">&quot;list&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;data&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;stabilityai/stable-diffusion-xl-base-1.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;object&quot;</span><span class="punctuation">:</span> <span class="string">&quot;model&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;created&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;owned_by&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;TencentARC/PhotoMaker&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;object&quot;</span><span class="punctuation">:</span> <span class="string">&quot;model&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;created&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;owned_by&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;InstantX/InstantID&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;object&quot;</span><span class="punctuation">:</span> <span class="string">&quot;model&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;created&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;owned_by&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;mistralai/Mixtral-8x7B-Instruct-v0.1&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;object&quot;</span><span class="punctuation">:</span> <span class="string">&quot;model&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;created&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;owned_by&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;mistralai/Mistral-7B-Instruct-v0.2&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;object&quot;</span><span class="punctuation">:</span> <span class="string">&quot;model&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;created&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;owned_by&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;stabilityai/stable-diffusion-2-1&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;object&quot;</span><span class="punctuation">:</span> <span class="string">&quot;model&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;created&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;owned_by&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;stabilityai/sd-turbo&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;object&quot;</span><span class="punctuation">:</span> <span class="string">&quot;model&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;created&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;owned_by&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;stabilityai/sdxl-turbo&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;object&quot;</span><span class="punctuation">:</span> <span class="string">&quot;model&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;created&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;owned_by&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ByteDance/SDXL-Lightning&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;object&quot;</span><span class="punctuation">:</span> <span class="string">&quot;model&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;created&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;owned_by&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;deepseek-ai/deepseek-llm-67b-chat&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;object&quot;</span><span class="punctuation">:</span> <span class="string">&quot;model&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;created&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;owned_by&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Qwen/Qwen1.5-14B-Chat&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;object&quot;</span><span class="punctuation">:</span> <span class="string">&quot;model&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;created&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;owned_by&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;mixtralai/Mixtral-8x22B-Instruct-v0.1&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;object&quot;</span><span class="punctuation">:</span> <span class="string">&quot;model&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;created&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;owned_by&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;meta-llama/Meta-Llama-3-70B-Instruct&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;object&quot;</span><span class="punctuation">:</span> <span class="string">&quot;model&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;created&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;owned_by&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;meta-llama/Meta-Llama-3-8B-Instruct&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;object&quot;</span><span class="punctuation">:</span> <span class="string">&quot;model&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;created&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;owned_by&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Qwen/Qwen1.5-7B-Chat&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;object&quot;</span><span class="punctuation">:</span> <span class="string">&quot;model&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;created&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;owned_by&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Qwen/Qwen1.5-110B-Chat&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;object&quot;</span><span class="punctuation">:</span> <span class="string">&quot;model&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;created&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;owned_by&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Qwen/Qwen1.5-32B-Chat&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;object&quot;</span><span class="punctuation">:</span> <span class="string">&quot;model&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;created&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;owned_by&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;01-ai/Yi-1.5-6B-Chat&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;object&quot;</span><span class="punctuation">:</span> <span class="string">&quot;model&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;created&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;owned_by&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;01-ai/Yi-1.5-9B-Chat-16K&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;object&quot;</span><span class="punctuation">:</span> <span class="string">&quot;model&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;created&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;owned_by&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;01-ai/Yi-1.5-34B-Chat-16K&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;object&quot;</span><span class="punctuation">:</span> <span class="string">&quot;model&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;created&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;owned_by&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;THUDM/chatglm3-6b&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;object&quot;</span><span class="punctuation">:</span> <span class="string">&quot;model&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;created&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;owned_by&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;deepseek-ai/DeepSeek-V2-Chat&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;object&quot;</span><span class="punctuation">:</span> <span class="string">&quot;model&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;created&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;owned_by&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;THUDM/glm-4-9b-chat&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;object&quot;</span><span class="punctuation">:</span> <span class="string">&quot;model&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;created&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;owned_by&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Qwen/Qwen2-72B-Instruct&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;object&quot;</span><span class="punctuation">:</span> <span class="string">&quot;model&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;created&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;owned_by&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Qwen/Qwen2-7B-Instruct&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;object&quot;</span><span class="punctuation">:</span> <span class="string">&quot;model&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;created&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;owned_by&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Qwen/Qwen2-57B-A14B-Instruct&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;object&quot;</span><span class="punctuation">:</span> <span class="string">&quot;model&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;created&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;owned_by&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;stabilityai/stable-diffusion-3-medium&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;object&quot;</span><span class="punctuation">:</span> <span class="string">&quot;model&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;created&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;owned_by&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;deepseek-ai/DeepSeek-Coder-V2-Instruct&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;object&quot;</span><span class="punctuation">:</span> <span class="string">&quot;model&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;created&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;owned_by&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Qwen/Qwen2-1.5B-Instruct&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;object&quot;</span><span class="punctuation">:</span> <span class="string">&quot;model&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;created&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;owned_by&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;google/gemma-2-9b-it&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;object&quot;</span><span class="punctuation">:</span> <span class="string">&quot;model&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;created&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;owned_by&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;google/gemma-2-27b-it&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;object&quot;</span><span class="punctuation">:</span> <span class="string">&quot;model&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;created&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;owned_by&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;internlm/internlm2_5-7b-chat&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;object&quot;</span><span class="punctuation">:</span> <span class="string">&quot;model&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;created&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;owned_by&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;BAAI/bge-large-en-v1.5&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;object&quot;</span><span class="punctuation">:</span> <span class="string">&quot;model&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;created&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;owned_by&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;BAAI/bge-large-zh-v1.5&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;object&quot;</span><span class="punctuation">:</span> <span class="string">&quot;model&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;created&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;owned_by&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Pro/Qwen/Qwen2-7B-Instruct&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;object&quot;</span><span class="punctuation">:</span> <span class="string">&quot;model&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;created&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;owned_by&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Pro/Qwen/Qwen2-1.5B-Instruct&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;object&quot;</span><span class="punctuation">:</span> <span class="string">&quot;model&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;created&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;owned_by&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Pro/Qwen/Qwen1.5-7B-Chat&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;object&quot;</span><span class="punctuation">:</span> <span class="string">&quot;model&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;created&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;owned_by&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Pro/THUDM/glm-4-9b-chat&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;object&quot;</span><span class="punctuation">:</span> <span class="string">&quot;model&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;created&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;owned_by&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Pro/THUDM/chatglm3-6b&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;object&quot;</span><span class="punctuation">:</span> <span class="string">&quot;model&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;created&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;owned_by&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Pro/01-ai/Yi-1.5-9B-Chat-16K&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;object&quot;</span><span class="punctuation">:</span> <span class="string">&quot;model&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;created&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;owned_by&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Pro/01-ai/Yi-1.5-6B-Chat&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;object&quot;</span><span class="punctuation">:</span> <span class="string">&quot;model&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;created&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;owned_by&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Pro/google/gemma-2-9b-it&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;object&quot;</span><span class="punctuation">:</span> <span class="string">&quot;model&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;created&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;owned_by&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Pro/internlm/internlm2_5-7b-chat&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;object&quot;</span><span class="punctuation">:</span> <span class="string">&quot;model&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;created&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;owned_by&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Pro/meta-llama/Meta-Llama-3-8B-Instruct&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;object&quot;</span><span class="punctuation">:</span> <span class="string">&quot;model&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;created&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;owned_by&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Pro/mistralai/Mistral-7B-Instruct-v0.2&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;object&quot;</span><span class="punctuation">:</span> <span class="string">&quot;model&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;created&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;owned_by&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></div><p><strong>计费规则</strong></p><p><img lazyload src="/images/loading.svg" data-src="LLM%E7%BF%BB%E8%AF%91%E8%83%BD%E5%8A%9B%E7%AE%80%E5%8D%95%E8%AF%84%E6%B5%8B/75d9225-img_v3_02cm_8dfc2b61-3c7e-44d3-af4a-75e26b22b59g.jpg" alt="img"></p><p>待测文本</p><div class="highlight-container" data-rel="Pgsql"><figure class="iseeu highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Early neural <span class="keyword">language</span> models (NLMs) [<span class="number">13</span>], [<span class="number">14</span>], [<span class="number">15</span>], [<span class="number">16</span>] deal <span class="keyword">with data</span> sparsity <span class="keyword">by</span> <span class="keyword">mapping</span> words <span class="keyword">to</span> low-dimensional continuous vectors (embedding vectors) <span class="keyword">and</span> predict the next word based <span class="keyword">on</span> the aggregation <span class="keyword">of</span> the embedding vectors <span class="keyword">of</span> its proceeding words <span class="keyword">using</span> neural networks. The embedding vectors learned <span class="keyword">by</span> NLMs define a hidden space <span class="keyword">where</span> the semantic similarity <span class="keyword">between</span> vectors can be readily computed <span class="keyword">as</span> their distance. This opens the door <span class="keyword">to</span> computing semantic similarity <span class="keyword">of</span> <span class="keyword">any</span> two inputs regardless their forms (e.g., queries vs. documents <span class="keyword">in</span> Web <span class="keyword">search</span> [<span class="number">17</span>], [<span class="number">18</span>], sentences <span class="keyword">in</span> different languages <span class="keyword">in</span> machine translation [<span class="number">19</span>], [<span class="number">20</span>]) <span class="keyword">or</span> modalities (e.g., image <span class="keyword">and</span> <span class="type">text</span> <span class="keyword">in</span> image captioning [<span class="number">21</span>], [<span class="number">22</span>]). Early NLMs are task-specific models, <span class="keyword">in</span> that they are trained <span class="keyword">on</span> task-specific data <span class="keyword">and</span> their learned hidden space <span class="keyword">is</span> task-specific.  </span><br><span class="line">Pre-trained <span class="keyword">language</span> models (PLMs), unlike early NLMs, are task-agnostic. This generality <span class="keyword">also</span> extends <span class="keyword">to</span> the learned hidden embedding space. The training <span class="keyword">and</span> inference <span class="keyword">of</span> PLMs follows the pre-training <span class="keyword">and</span> fine-tuning paradigm, <span class="keyword">where</span> <span class="keyword">language</span> models <span class="keyword">with</span> recurrent neural networks [<span class="number">23</span>] <span class="keyword">or</span> transformers [<span class="number">24</span>], [<span class="number">25</span>], [<span class="number">26</span>] are pre-trained <span class="keyword">on</span> Web-scale unlabeled <span class="type">text</span> corpora <span class="keyword">for</span> general tasks such <span class="keyword">as</span> word prediction, <span class="keyword">and</span> <span class="keyword">then</span> finetuned <span class="keyword">to</span> specific tasks <span class="keyword">using</span> small amounts <span class="keyword">of</span> (labeled) task-specific data. Recent surveys <span class="keyword">on</span> PLMs <span class="keyword">include</span> [<span class="number">8</span>], [<span class="number">27</span>], [<span class="number">28</span>].</span><br></pre></td></tr></table></figure></div><h2 id="Qwen-Qwen2-57B-A14B-Instruct">Qwen/Qwen2-57B-A14B-Instruct</h2><p>主打一个快，还算可以</p><p><img lazyload src="/images/loading.svg" data-src="LLM%E7%BF%BB%E8%AF%91%E8%83%BD%E5%8A%9B%E7%AE%80%E5%8D%95%E8%AF%84%E6%B5%8B/image-20240724162019227.png" alt="image-20240724162019227"></p><h2 id="meta-llama-Meta-Llama-3-70B-Instruct">meta-llama/Meta-Llama-3-70B-Instruct</h2><p><img lazyload src="/images/loading.svg" data-src="LLM%E7%BF%BB%E8%AF%91%E8%83%BD%E5%8A%9B%E7%AE%80%E5%8D%95%E8%AF%84%E6%B5%8B/image-20240724162348536.png" alt="image-20240724162348536"></p><p>翻译的更精准一些，比如train没翻译成学习，task-agnostic就直接直译了</p><p>速度稍慢于1，且会有网络问题</p><h2 id="meta-llama-Meta-Llama-3-8B-Instruct">meta-llama/Meta-Llama-3-8B-Instruct</h2><p>有点重量级</p><p><img lazyload src="/images/loading.svg" data-src="LLM%E7%BF%BB%E8%AF%91%E8%83%BD%E5%8A%9B%E7%AE%80%E5%8D%95%E8%AF%84%E6%B5%8B/image-20240724162755569.png" alt="image-20240724162755569"></p><p>单词还拼错了，有的不是特定名词也直接不翻了</p><h2 id="Qwen-Qwen2-72B-Instruct">Qwen/Qwen2-72B-Instruct</h2><p>目前最慢的一个</p><p><img lazyload src="/images/loading.svg" data-src="LLM%E7%BF%BB%E8%AF%91%E8%83%BD%E5%8A%9B%E7%AE%80%E5%8D%95%E8%AF%84%E6%B5%8B/image-20240724163035608.png" alt="image-20240724163035608"></p><p>“他们不针对具体任务”，虽然是意译，但其实我不太喜欢</p><h2 id="GPT-3-5-turbo-16K（非开源模型）">GPT-3.5-turbo-16K（非开源模型）</h2><p><img lazyload src="/images/loading.svg" data-src="LLM%E7%BF%BB%E8%AF%91%E8%83%BD%E5%8A%9B%E7%AE%80%E5%8D%95%E8%AF%84%E6%B5%8B/image-20240724163459667.png" alt="image-20240724163459667"></p><p>感觉还得是gpt的</p>]]></content>
      
      
      <categories>
          
          <category> 杂记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LLM </tag>
            
            <tag> 翻译 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FaceFusion使用记录</title>
      <link href="/posts/%E6%9D%82%E8%AE%B0/facefusion%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95.html"/>
      <url>/posts/%E6%9D%82%E8%AE%B0/facefusion%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>刚刚南软面试结束，稍稍放松下</p></blockquote><h2 id="环境">环境</h2><p>用了驱动云，白嫖了一些计算点</p><p><a class="link" href="https://www.virtaicloud.com/">https://www.virtaicloud.com/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p><h3 id="换源">换源</h3><p>jupterbook + 网页终端，要记得保存环境</p><p>conda换源，感觉它这个速度一般，似乎不如不换</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">conda config --add default_channels https://conda.virtaicloud.com/repository/anaconda/main</span><br><span class="line">conda config --add default_channels https://conda.virtaicloud.com/repository/anaconda/r</span><br><span class="line">conda config --add default_channels https://conda.virtaicloud.com/repository/anaconda/msys2</span><br></pre></td></tr></table></figure></div><h3 id="apt换源">apt换源</h3><p><a class="link" href="https://developer.aliyun.com/article/1180548">https://developer.aliyun.com/article/1180548 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释</span></span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal main restricted universe multiverse</span><br><span class="line"><span class="comment"># deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal main restricted universe multiverse</span></span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-updates main restricted universe multiverse</span><br><span class="line"><span class="comment"># deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-updates main restricted universe multiverse</span></span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-backports main restricted universe multiverse</span><br><span class="line"><span class="comment"># deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-backports main restricted universe multiverse</span></span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-security main restricted universe multiverse</span><br><span class="line"><span class="comment"># deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-security main restricted universe multiverse</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 预发布软件源，不建议启用</span></span><br><span class="line"><span class="comment"># deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-proposed main restricted universe multiverse</span></span><br><span class="line"><span class="comment"># deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-proposed main restricted universe multiverse</span></span><br></pre></td></tr></table></figure></div><h3 id="Platform">Platform</h3><p><a class="link" href="https://docs.facefusion.io/installation">https://docs.facefusion.io/installation <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt install git-all curl ffmpeg mesa-va-drivers</span><br></pre></td></tr></table></figure></div><p>conda镜像里已经装了</p><h3 id="environment">environment</h3><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda create --name facefusion python=3.10</span><br></pre></td></tr></table></figure></div><h3 id="accelerator">accelerator</h3><p>cuda</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda install conda-forge::cuda-runtime=12.4.1 cudnn=8.9.2.26 conda-forge::gputil=1.4.0</span><br></pre></td></tr></table></figure></div>]]></content>
      
      
      <categories>
          
          <category> 杂记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> FaceFusion </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>24-Spring-软件质量与管理期末复习</title>
      <link href="/posts/%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/24-spring-%E8%BD%AF%E4%BB%B6%E8%B4%A8%E9%87%8F%E4%B8%8E%E7%AE%A1%E7%90%86%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0.html"/>
      <url>/posts/%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/24-spring-%E8%BD%AF%E4%BB%B6%E8%B4%A8%E9%87%8F%E4%B8%8E%E7%AE%A1%E7%90%86%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0.html</url>
      
        <content type="html"><![CDATA[<blockquote><p><a class="link" href="https://wbl-z.github.io/%E8%BD%AF%E4%BB%B6%E8%B4%A8%E9%87%8F%E7%AE%A1%E7%90%86/%E8%BD%AF%E4%BB%B6%E8%B4%A8%E9%87%8F%E7%AE%A1%E7%90%86%E5%A4%8D%E4%B9%A0/#">2024软件质量管理复习+2024回忆 | wbl-z’s Blog <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> | <a class="link" href="https://eaglebear2002.github.io/2023Fall-%E8%BD%AF%E4%BB%B6%E8%B4%A8%E9%87%8F%E7%AE%A1%E7%90%86/%E8%BD%AF%E4%BB%B6%E8%B4%A8%E9%87%8F%E7%AE%A1%E7%90%86-%E4%B9%A0%E9%A2%98/">软件质量管理-习题 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p><p>PS：本文非背诵速通版本，只是尽力理一下思路</p><p>v2.0 修正了一些错误，添加了一些内容</p></blockquote><h2 id="最后一课">最后一课</h2><p>课程目标：很多<strong>软件工程</strong>基本、简单的概念要能够表述准确，经得起推敲</p><h3 id="过程线">过程线</h3><p><img lazyload src="/images/loading.svg" data-src="24-Spring-%E8%BD%AF%E4%BB%B6%E8%B4%A8%E9%87%8F%E4%B8%8E%E7%AE%A1%E7%90%86/1719552424214-47.png" alt="img"></p><p><strong>概念</strong></p><ol><li><strong>什么是管理</strong>：三个要素还记得不</li><li><strong>管理视角</strong>，关注的是学习，如何复现别人的成功：首先用一样的方法去做-&gt;过程</li><li><strong>有了过程为什么还要生命周期</strong>？过程太复杂，要有简单的方法：瀑布、生命周期，让别人快速明白</li><li><strong>迭代和瀑布：</strong><ol><li>迭代式是什么</li><li>关于瀑布的错误观点：有哪些，要有正确的理解</li><li>不理解瀑布模型的话，你觉得你是软件工程职业选手吗？</li></ol></li></ol><p><strong>软件过程管理</strong></p><p>有改进的场景：PDCA和IDEAL元模型</p><p>CMM和CMMI</p><p><strong>软件工程演变的历史视角</strong></p><p>软件危机和软件工程怎么来的，解决什么问题</p><p>三大阶段？如何正确理解敏捷宣言？（业界理解很多都是偏的）</p><p>驱动力：本质难题（人月神话的提到），这些本质难题在不同历史阶段的显现程度决定了演变</p><h3 id="项目管理线"><strong>项目管理线</strong></h3><p><img lazyload src="/images/loading.svg" data-src="24-Spring-%E8%BD%AF%E4%BB%B6%E8%B4%A8%E9%87%8F%E4%B8%8E%E7%AE%A1%E7%90%86/1719552424165-1.png" alt="img"></p><ol><li><strong>自主团队</strong>：内部环境和外部环境（外部是管理层）该怎么样，TSP角色和职责（启动过程，九次会议），SCRUM角色和职责</li><li><strong>所有估算都是抽象的相对的估算</strong></li><li>PROBE方法：相对大小矩阵，很典型的抽象，相对的</li><li>SCRUM故事点：斐波那契数列</li><li>通用计划框架：正推，不是逆推，课上还专门讨论了哪些可以实现自动化哪些需要人为判断</li><li>注意一份完整的项目计划包含了很多种计划，不止质量、风险</li><li>（跟踪中最重要的部分）挣值管理体系<ol><li>需要思考这套体系为什么更加适合SE？1.支持动态变更，SE天然地会经常改变，需求功能改变这样（最关键的一点） 2.挣值图是相对保守的策略，全部完成才能拿到挣值</li></ol></li></ol><h3 id="质量管理线"><strong>质量管理线</strong></h3><p><img lazyload src="/images/loading.svg" data-src="24-Spring-%E8%BD%AF%E4%BB%B6%E8%B4%A8%E9%87%8F%E4%B8%8E%E7%AE%A1%E7%90%86/1719552424165-2.png" alt="img"></p><ol><li>质量管理的挑战：从管理的三要素来看，质量管理非常困难</li><li>质量管理的策略和背后逻辑<ol><li>比如问为什么这么多质量相关的属性，在企业中关注的往往只是其中的测试、缺陷管控？用户优先级排序第一的什么东西？</li></ol></li><li>个人评审：关键控制因素（速度），时机选择（先测试还是评审之类的）</li><li>小组评审 九宫图 Capture?</li><li>质量控制指标 Yield，A/FR, PQI, DRL 有什么用，能干什么，特点和用途</li><li>设计评审：几种评审机制</li></ol><h3 id="工程技术线"><strong>工程技术线</strong></h3><p><img lazyload src="/images/loading.svg" data-src="24-Spring-%E8%BD%AF%E4%BB%B6%E8%B4%A8%E9%87%8F%E4%B8%8E%E7%AE%A1%E7%90%86/1719552424165-3.png" alt="img"></p><p>概念和区别：vertification验证和validation确认，跟客户需求和产品需求联系起来理解就容易区分了</p><h3 id="其他"><strong>其他</strong></h3><p><img lazyload src="/images/loading.svg" data-src="24-Spring-%E8%BD%AF%E4%BB%B6%E8%B4%A8%E9%87%8F%E4%B8%8E%E7%AE%A1%E7%90%86/1719552424165-4.png" alt="img"></p><h2 id="题型">题型</h2><p>名词解释+简答题</p><h2 id="过程线-2">过程线</h2><h3 id="软件工程究竟是什么？">软件工程究竟是什么？</h3><p>主要解决面向“人”的问题</p><p><img lazyload src="/images/loading.svg" data-src="24-Spring-%E8%BD%AF%E4%BB%B6%E8%B4%A8%E9%87%8F%E4%B8%8E%E7%AE%A1%E7%90%86/1719552424165-5.png" alt="img"></p><h3 id="什么是软件开发">什么是软件开发</h3><h4 id="软件开发的本质困难（四大本质难题）">软件开发的本质困难（四大本质难题）</h4><p><strong>不可见性</strong></p><ul><li>软件是一种“看不见、摸不着”的逻辑实体、不具有空间的形体特征</li><li>开发人员可以直接看到程序源代码，但是源代码本身并不是软件本身</li><li>软件是以机器代码的形式运行，但是开发人员无法看到源代码是如何运行的</li></ul><p><strong>复杂性</strong></p><ul><li>对于软件复杂的需求导致了软件的复杂性</li></ul><p><strong>可变性</strong></p><ul><li>软件的变化（随时间推移）对其失效率的影响，软件的可变性体现在软件本身升级，功能的变化等</li></ul><p><strong>一致性</strong></p><ul><li>软件不能独立存在，要依附于一定的环境（如硬件、网络、以及其他软件）</li><li>软件必须遵循从人为的惯例并适应已有的技术和系统</li><li>软件需要随着接口不同而变化，随着时间推移而变化，而这些变化是不同人设计的结果</li></ul><h4 id="四大本质难题之间的关系"><strong>四大本质难题之间的关系</strong></h4><ol><li>除了<strong>不可见性</strong>以外，其他三个本质难题因项目⽽异。</li><li>四⼤本质难题互相促进。</li><li><strong>本质难题变化带动软件⽅法（过程）演变。（驱动力）</strong></li></ol><h4 id="软件开发的几个注意点">软件开发的几个注意点</h4><ol><li>软件开发**四大本质难题永远存在，不可能彻底解决，**在不同时期凸显程度有差异。</li><li>软件开发本质上是智⼒劳动，<strong>开发者心理</strong>⽅⾯的因素不可忽视</li></ol><h3 id="本课程要回答的十大问题">本课程要回答的十大问题</h3><p>复习完可以想想</p><h3 id="√软件危机vs软件工程">√软件危机vs软件工程</h3><ol><li>软件危机<ol><li>软件危机是指<strong>落后的软件生产方式</strong>无法满足迅速增长的<strong>计算机软件需求</strong>，从而导致软件开发与维护过程中出现一系列严重问题的现象。</li></ol></li><li>软件工程<ol><li>软件工程是一门研究用<strong>工程化方法</strong>构建和维护有效的、实用的和高质量的软件的学科。</li><li>软件工程的两大视角<ol><li>管理视角——<strong>能否复制成功？</strong></li><li>技术视角——<strong>是否可以将问题解决得更好？</strong></li></ol></li></ol></li></ol><blockquote><p>软件危机-&gt;软件工程-&gt;两大视角之管理视角</p></blockquote><h3 id="√什么是管理">√什么是管理</h3><blockquote><p>所以什么是管理？</p></blockquote><ol><li><strong>管理的三大关键要素：</strong><ol><li><strong>目标</strong></li><li><strong>状态</strong>：是在接近目标还是在远离目标</li><li><strong>纠偏</strong></li></ol></li></ol><h3 id="√软件项目管理">√软件项目管理</h3><p><strong>软件项目管理（not 软件过程管理）</strong></p><ol><li><strong>典型的三大目标：成本、质量、工期</strong></li><li><strong>软件项目管理</strong>是应用方法、工具、技术以及人员能力来完成软件项目，实现项目目标的过程。<ol><li>A. 软件项⽬管理包括<strong>估算、计划、跟踪、⻛险管理、范围管理、⼈员管理、沟通管理</strong>等等。</li><li>B. 软件项⽬管理的对象是各类软件项⽬</li></ol></li></ol><blockquote><p>质量实践和质量管理是不一样的</p><ol><li>质量实践包括测试等等</li><li>质量管理是对质量的管理，而不是实践，管理必须有上面所说的三个要素</li></ol></blockquote><h3 id="√软件过程管理">√软件过程管理</h3><p>管理视角的主要目标/核心问题：成功是否可以复制？</p><h4 id="软件过程定义"><strong>软件过程定义</strong></h4><ol><li>软件过程是为了实现一个或者多个事先定义的目标而建立起来的一组实践的集合</li><li>这组实践之间往往有一定的先后顺序，作为一个整体来实现事先定义的一个或者多个目标。</li></ol><h4 id="广义软件过程"><strong>广义软件过程</strong></h4><blockquote><p>广义软件过程（Generalized Software Process Model）**通常是一种高度抽象的方法，用于描述软件开发的各个阶段或步骤，旨在兼顾多种具体软件开发过程模型的共通特点。**这种广义的过程不专注于某一个特定的软件过程模型（如瀑布模型、迭代模型、敏捷开发模型等），而是试图概括出在大多数软件开发项目中普遍存在的活动和任务。</p></blockquote><ol><li>理论基石：软件产品和服务的质量，<strong>很大程度上取决于生产和维护该软件或者服务的过程的质量。</strong></li><li>广义软件过程包括<strong>技术、人员以及狭义过程</strong></li><li>广义软件过程的同义词<ol><li><strong>软件开发方法、软件开发过程</strong><ol><li>净室Cleanroom方法、极限编程方法、SCRUM方法、Gate方法；</li><li>而更一般的，敏捷软件过程／方法、轻量型过程／方法以及重型过程／方法等描述也是恰当的</li></ol></li></ol></li></ol><h4 id="生命周期模型"><strong>生命周期模型</strong></h4><ol><li>**主要作用：**便于传达，复制成功</li><li>区别和联系<ol><li><strong>生命周期模型是对一个软件开发过程的人为划分</strong></li><li>生命周期模型是软件开发过程的主框架，是对软件开发过程的一种粗粒度划分</li><li>生命周期模型往往不包括技术实践</li></ol></li><li>典型生命周期模型<ol><li>瀑布模型、迭代式模型、增量模型、螺旋模型、原型法等等</li></ol></li></ol><h5 id="√瀑布模型">√瀑布模型</h5><p>瀑布模型是Family，与迭代并不矛盾，团队决定该使用什么样的瀑布模型。</p><p><img lazyload src="/images/loading.svg" data-src="24-Spring-%E8%BD%AF%E4%BB%B6%E8%B4%A8%E9%87%8F%E4%B8%8E%E7%AE%A1%E7%90%86/1719552424166-6.png" alt="img"></p><p>瀑布模型是Family，与迭代并不矛盾，团队决定该使用什么样的瀑布模型。</p><p><strong>迭代与瀑布：多个迭代迭代完成，灵活，反馈快；瀑布线性完成，反馈少，不易变更</strong></p><p>关于瀑布的错误观点（知道哪些错误的，不背）：</p><ol><li>瀑布模型是过时的</li></ol><p>​        正确理解： 瀑布模型并非过时，而是适用于某些特定类型的项目。对于需求明确、不太可能发生变化的项目，瀑布模型可以提供清晰的结构和控制。它在一些政府和大型工程项目中仍然广泛使用。</p><ol><li>瀑布模型不允许任何变化</li></ol><p>​        正确理解： <strong>虽然瀑布模型强调顺序进行，但这并不意味着完全不能进行任何变化。实际应用中，许多瀑布项目会在必要时进行一些回溯和调整，只是相对较难和代价较高。因此，在<strong><strong>需求稳定、变化较少</strong></strong>的项目中，瀑布模型更为有效。</strong></p><ol><li>瀑布模型没有反馈环节</li></ol><p>​        正确理解： **瀑布模型中的每个阶段通常都有验证和确认环节，以确保符合需求。**例如，需求分析阶段结束时会有需求评审，设计阶段结束时会有设计评审等。<strong>尽管反馈不像迭代式开发那么频繁，但仍然存在。</strong></p><ol><li>瀑布模型导致更高的项目失败率</li></ol><p>​        正确理解： 瀑布模型的成功与否取决于项目的性质和执行的严格性。在需求明确且不太会变动的项目中，瀑布模型可以非常成功。项目失败通常更多与管理不善、沟通不畅和需求变化相关，而不是开发模型本身。</p><p><strong>如何理解瀑布模型</strong></p><blockquote><ul><li>瀑布模型不是单一模型，是一系列模型，覆盖最简单场景(过程元素少)到最复杂的场景(过程元素多)</li><li>软件项目应该结合实际情况选择合适过程元素的瀑布模型。基本原则是，项目面临困难和挑战越多，选择的模型应该越复杂。</li><li>软件项目团队往往低估项目的挑战，选择了过于简单的不适用的瀑布模型。</li></ul></blockquote><h5 id="√迭代式模型">√迭代式模型</h5><p>迭代式：大型软件系统的开发过程也是一个逐步学习和交流的过程，软件系统的交付不是一次完成，而是通过多个迭代周期，逐步来完成交付。</p><h4 id="软件过程管理"><strong>软件过程管理</strong></h4><p><strong>管理视角的核心问题——能否复制成功？</strong></p><ol><li>管理对象是软件过程</li><li>管理的<strong>目的</strong>是为了让软件过程在开发效率、质量等方面有着更好性能绩效(performance)</li></ol><p><img lazyload src="/images/loading.svg" data-src="24-Spring-%E8%BD%AF%E4%BB%B6%E8%B4%A8%E9%87%8F%E4%B8%8E%E7%AE%A1%E7%90%86/1719552424166-7.png" alt="img"><img lazyload src="/images/loading.svg" data-src="24-Spring-%E8%BD%AF%E4%BB%B6%E8%B4%A8%E9%87%8F%E4%B8%8E%E7%AE%A1%E7%90%86/1719552424166-8.png" alt="img"></p><blockquote><p>左侧是软件开发部分，右侧是传统生产部分</p></blockquote><h4 id="软件过程管理与软件过程改进">软件过程管理与软件过程改进</h4><p>两者意思接近</p><ol><li>软件过程管理参考模型 CMM/CMMI, SPICE等</li><li>软件过程改进参考元模型 PDCA，IDEAL</li></ol><blockquote><p>CMM (Capability Maturity Model): 软件能力成熟度模型</p><p>CMMI (Capability Maturity Model Integration): 能力成熟度模型集成</p><p>PDCA (Plan Do Check Action): PDCA循环就是按照这样的顺序进行质量管理，</p><p>并且循环不止地进行下去的科学程序。【右上角】</p><p>IDEAL (Intiating Diagnosing Establishing Acting Learning): 初始化、诊断、建</p><p>立、行动、学习 。【右下角】</p></blockquote><h3 id="√软件发展三大阶段">√软件发展三大阶段</h3><ol><li><strong>软硬件一体化阶段</strong>（50年代~70年代）<ol><li>软件完全依附于硬件</li><li>软件作坊</li></ol></li><li><strong>软件成为独立的产品</strong>（70年代~90年代）</li><li><strong>网络化和服务化</strong>（90年代中期迄今）</li></ol><h3 id="√软硬件一体化阶段（50年代-70年代）">√软硬件一体化阶段（50年代~70年代）</h3><h4 id="一：软件完全依附于硬件">一：软件完全依附于硬件</h4><ol><li>软件应用典型特征<ol><li>软件支持硬件完成计算任务</li><li>功能单一</li><li>复杂度有限</li><li>几乎不需要需求变更</li></ol></li><li>软件开发典型特征<ol><li>硬件太贵</li><li>团队以硬件工程师和数学家为主</li></ol></li></ol><h5 id="典型软件过程和实践">典型软件过程和实践</h5><ol><li><strong>Measure twice, cut once</strong>，相同的软件工程实践：code review &amp; inspection</li><li>各种specification，Operational Specifications (操作规格)，Program Specifications (程序规格)，Coding Specifications (编码规格)<ol><li>specification与参数、代码等部分相关</li></ol></li></ol><h4 id="二：软件作坊">二：软件作坊</h4><ol><li>软件应用典型特征<ol><li>功能简单</li><li>规模小</li></ol></li><li>软件开发典型特征<ol><li><strong>很多非专业领域的人员涌入软件开发领域</strong></li><li>高级程序语言出现</li><li><strong>质疑权威文化盛行</strong></li></ol></li><li><strong>Code And Fix</strong><ol><li>Code And Fix不适合大型软件项目开发</li><li><strong>一开始是“软件依附于硬件”，后来独立出去有“软件作坊”，软件小作坊的特征就是比较简单的Code And Fix</strong></li></ol></li></ol><h3 id="√软件成为独立产品（70年代-90年代）">√软件成为独立产品（70年代~90年代）</h3><p><strong>软件应用典型特征</strong></p><ol><li>摆脱了硬件束缚（OS）</li><li>功能强大</li><li>规模和复杂度剧增</li><li>个人电脑出现 =&gt; 普通人成为软件用户<ol><li>需求多变</li><li>兼容性要求</li></ol></li><li>来自市场的压力</li></ol><h4 id="软件典型过程和实践">软件典型过程和实践</h4><ol><li>方法之一：形式化方法：指建立在严格数学基础上的软件开发方法，做数学化的检验，主要解决质量和正确性问题<ol><li>问题和不足：<strong>形式化方法在扩展性和可用性方面存在不足</strong></li></ol></li><li>方法之二：结构化程序设计和瀑布模型<ol><li>设计+开发； 设计文档化；build it twice， 规划和监控测试，引入客户</li><li>问题和不足：<strong>瀑布模型成为一个重文档，慢节奏的过程</strong></li></ol></li></ol><blockquote><p>lean development说：其实royce提出瀑布生命周期模型的本意是该生命周期模型不适合软件开发。 <strong>（错误的）参考前文对瀑布模型的理解</strong></p></blockquote><h3 id="√网络化和服务化（90年代中期迄今）">√网络化和服务化（90年代中期迄今）</h3><p><strong>软件应用典型特征</strong></p><ol><li>功能更复杂、规模更大</li><li>用户数量急剧增加</li><li>快速演化和需求不确定</li><li>分发方法的变化 （SaaS）</li></ol><p><strong>典型软件过程和实践</strong></p><ol><li><p>迭代式：大型软件系统的开发过程也是一个逐步学习和交流的过程，软件系统的交付不是一次完成，而是通过多个迭代周期，逐步来完成交付。</p></li><li><p>√<strong>雪鸟会议和敏捷宣言（见下）</strong></p><ol><li><p>目的：使软件开发团队具有高效工作和快速响应变化的能力</p></li><li><p>特征：小周期迭代、快速响应变更、价值交付、自动化</p></li><li><p><strong>敏捷软件开发宣言的四个简单价值观</strong></p><ol><li>A. <strong>个体和互动</strong>胜过<strong>流程和工具</strong></li><li>B. <strong>可以工作的软件</strong>胜过<strong>详尽的文档</strong></li><li>C. <strong>客户合作</strong>胜过<strong>合同谈判</strong></li><li>D. <strong>响应变化</strong>胜过<strong>遵循计划</strong></li></ol></li><li><p><strong>也就是说，尽管右项有其价值，我们更重视左项的价值</strong>。</p></li><li><p>That is, while there is value in the items onthe right, we value the items on the left more”</p><p>务必关注这一句话，非常重要：对敏捷宣言正确的理解是，右项是“正和” （根基），左项是“奇胜” 【“凡战者,以正合,以奇胜 ” — 孙子兵法】</p></li></ol></li><li><p>XP（eXtreme Programming）方法</p><ol><li>偏重于一些工程实践的描述</li></ol></li><li><p>SCRUM</p><ol><li>管理框架和管理实践</li></ol></li><li><p>Kanban</p><ol><li>精益生产（丰田制造法）的具体实现</li><li>可视化工作流、限定WIP【Working in Progress 车间生产管理】、管理周期时间</li></ol></li><li><p>开源软件开发方法：是一种基于并行开发模式的软件开发的组织与管理方式</p><ol><li>Linus 定律：如果有足够多的beta测试者和合作开发者，几乎所有问题都会很快显现，然后自然有人会把它解决。</li><li>早发布，常发布，倾听用户的反馈 、把你的用户当成开发合作者对待，如果想让代码质量快速提升并有效排错，这是最省心的途径、设计上的完美不是没有东西可以再加，而是没有东西可以再减</li><li>代码管理：严格的代码提交社区审核制度</li><li>一些演化：1. 内部开源（inner source） 2. 众包（Crowdsourcing）</li></ol></li></ol><h3 id="√当前软件发展现状">√当前软件发展现状</h3><ol><li><strong>软件应用典型特征</strong><ol><li>进一步服务化和网络化（移动是主流）</li><li>用户需求多样性进一步凸显</li><li>软件产品和服务的地位变化</li><li>错综复杂的部署环境</li><li>近乎苛刻的用户期望<ol><li>多：功能丰富，个性化</li><li>快：快速使用，及时更新，快速解决问题</li><li>好：稳定，可靠，安全，可信</li><li>省：用户的获得成本低，最好免费</li></ol></li></ol></li><li><strong>软件开发典型特征</strong><ol><li>空前强大的开发和部署环境——XaaS（IaaS、PaaS、SaaS、FaaS）</li><li>盛行共享和开源</li><li>潜在支撑获得了长足进步（AI，Bigdata， Cloud，etc.）</li></ol></li><li>典型Devops实践和方法<ol><li>方法论基础是敏捷软件开发、精益思想以及看板Kanban方法。</li><li>以领域驱动设计为指导的微服务架构方式</li><li>大量虚拟化技术的使用</li><li>一切皆服务XaaS(X as a Service)的理念指导</li><li>构建了强大的工具链，支持高水平自动化</li></ol></li></ol><h3 id="√软件工程演变的驱动力">√软件工程演变的驱动力</h3><p>软件工程演变的驱动力是四大本质难题：不可见，复杂，可变，一致。【前文】四大难题之间的关系</p><h3 id="√软件过程管理参考模型">√软件过程管理参考模型</h3><h4 id="成熟度模型CMM-CMMI-Capability-Maturity-Model">成熟度模型CMM/CMMI (Capability Maturity Model)</h4><p><img lazyload src="/images/loading.svg" data-src="24-Spring-%E8%BD%AF%E4%BB%B6%E8%B4%A8%E9%87%8F%E4%B8%8E%E7%AE%A1%E7%90%86/1719552424166-9.png" alt="img"></p><p>成熟度模型（最开始是CMM，现在是CMMI）</p><ol><li>CMMI从第2级升级到第3级的原因：固化最佳实践，对小组而言则是能够更快地学习其他的做法</li><li>CMMI第3级中的标准化目的不是简单的替换，重点是已定义</li><li>CMMI第4级我们希望能够看到一个预测模型</li><li>第4级和第5级更多是根据结果（未来）来进行管理</li><li>第2级和第3级关注的是当前的状态</li></ol><p><strong>理解</strong></p><ol><li><strong>初始级 Initial</strong><ol><li><strong>过程不可预测、项目管理很少、开发相对混乱</strong></li><li><strong>个人英雄主义、救火文化</strong></li><li>工作无序，项目进行过程中常放弃当初的计划。管理无章法，缺乏健全的管理制度。开发项目成效不稳定，<strong>项目成功主要依靠项目负责人的经验和能力，他一旦离去，工作秩序面目全非。</strong></li></ol></li><li><strong>已管理级 Managed</strong><ol><li>以<strong>项目</strong>为单位进行管理，相对被动的管理</li><li><strong>有项目计划和跟踪、需求管理、配置管理等</strong></li><li><strong>管理制度化，建立了基本的管理制度和规程，管理工作有章可循。</strong> <strong>初步实现标准化</strong>，开发工作比较好地按标准实施。 变更依法进行，做到基线化，稳定可跟踪，新项目的计划和管理基于过去的实践经验，<strong>具有复现以前成功项目的环境和条件。</strong></li></ol></li><li><strong>已定义级 Defined</strong><ol><li>以<strong>公司</strong>为单位进行管理，相对主动的管理</li><li><strong>公司层面有标准流程和相应规范，每个项目小组可以基于此定义自己的流程</strong></li><li>开发过程，包括技术工作和管理工作，<strong>均已实现标准化、文档化。建立了完善的培训制度和专家评审制度，全部技术活动和管理活动均可控制</strong>，对项目进行中的过程、岗位和职责均有共同的理解 。</li></ol></li><li><strong>定量管理级 Quantitatively</strong><ol><li>过程被度量和管理</li><li>构建预测模型，用统计过程控制的手段来管理过程</li><li>产品和过程已建立了定量的质量目标。开发活动中的生产率和质量是可 量度的。已建立过程数据库。已实现项目产品和过程的控制。可预测过 程和产品质量趋势，如预测偏差，及时纠正。</li></ol></li><li><strong>优化级 Optimizing</strong><ol><li>专注于过程改进</li><li>继续应用统计方法识别过程偏差，找到问题根源并消除，避免未来继续发生类似问题</li><li>可通过采用新技术、新方法，集中精力改进过程。具备防缺陷、识别薄 弱环节以及改进的手段。可取得过程有效性的统计数据，并可据此进行 分析，从而得出最佳方法。</li></ol></li></ol><p><strong>一些讨论</strong></p><ol><li>CMMI是过程改进模型而非软件过程或者软件过程模型，说法怎么样？对的，CMMI指导软件过程改进，不指导开发。</li><li>CMMI不是过程优劣的标准，也不适合用作公司之间的能力比较，说法怎么样？对的，CMMI本身是有评级。（美国国防部订单招标要求企业至少达到CMMI的3级。因为公司的能力需要绝对东西，也就是能力强，能力弱，而CMMI衡量的是相对的水平，CMMI仅仅关注在本公司的目标下的等级</li><li>为什么CMMI VS. Agile是一个伪命题？ ==&gt; Agile是敏捷过程或方法，这是一种软件开发方法；CMMI是过程管理模型。</li><li>Level 3及以下是一般的项目管理；Level4&amp;5是高成熟的项目管理，即定量管理</li></ol><blockquote><p>更多见：<a class="link" href="https://www.jianshu.com/p/b7407257eedb">https://www.jianshu.com/p/b7407257eedb <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p></blockquote><h3 id="√软件过程改进元模型">√软件过程改进元模型</h3><h4 id="PDCA">PDCA</h4><ol><li>PDCA：Plan、Do、Check、Action</li><li>PDCA模型的步骤：<ol><li>分析现状，找出问题</li><li>分析影响质量的原因</li><li>找出措施</li><li>拟定措施计划</li><li>执⾏措施，执⾏计划</li><li>检查效果，发现问题</li><li>总结经验，纳⼊标准</li><li>遗留问题转⼊下期PDCA循环</li></ol></li></ol><p><img lazyload src="/images/loading.svg" data-src="24-Spring-%E8%BD%AF%E4%BB%B6%E8%B4%A8%E9%87%8F%E4%B8%8E%E7%AE%A1%E7%90%86/1719552424166-10.png" alt="img"></p><h4 id="IDEAL">IDEAL</h4><ol><li>IDEAL模型解决了软件在各种质量改进环境下的需要。</li><li>IDEAL包括了软件改进过程的五个阶段<ol><li>Initiating 初始</li><li>Diagnosing 诊断</li><li>Establishing 建立</li><li>Acting 执行</li><li>Leveraging 调整</li></ol></li></ol><p><img lazyload src="/images/loading.svg" data-src="24-Spring-%E8%BD%AF%E4%BB%B6%E8%B4%A8%E9%87%8F%E4%B8%8E%E7%AE%A1%E7%90%86/1719552424166-11.png" alt="img"></p><h2 id="项目管理线-2">项目管理线</h2><h3 id="√三大目标">√三大目标</h3><p><strong>成本、质量、工期</strong></p><blockquote><p>注意区分目标的三要素</p></blockquote><h3 id="√团队动力学">√团队动力学</h3><blockquote><p>软件开发是一项既复杂又富有创造性的知识工作（智力劳动）</p><ul><li>处理和讨论极其抽象的概念</li><li>把不同的部分（不可见）整合成一个可以工作的系统</li></ul></blockquote><h4 id="√知识工作特点">√知识工作特点</h4><p>软件开发是一种<strong>智力劳动</strong>，需要工程师全身心地参与工作，<strong>主观</strong>意愿上努力追求卓越，所以需要管理者<strong>激励</strong>并且维持激励</p><h4 id="√知识工作管理">√知识工作管理</h4><p>知识工作者的管理需要的是<strong>领导者</strong>，而不是<strong>经理</strong></p><p>管理知识工作的关键规则是：管理者无法管理工作者，知识工作者必须实现并且学会自我管理。</p><p>要自我管理，知识工作者必须：</p><ul><li>有积极性</li><li>能做出准确的估算和计划</li><li>懂得协商承诺</li><li>有效跟踪他们的计划</li><li>持续地按计划交付高质量产物</li></ul><h4 id="√领导者和特点">√领导者和特点</h4><p>知识工作者的管理需要的是<strong>领导者</strong>，而不是<strong>经理</strong></p><ul><li>诚实——言行一致</li><li>有能力——技能与知识兼备</li><li>有远见——能否洞察未来，是否拥有一个可信且美好的未来愿景？</li><li>鼓舞人心——他们对未来是否持有积极、热情和充满活力的态度？</li></ul><h4 id="√不同的激励方式">√不同的激励方式</h4><p>有3种主要的激励方式：</p><ol><li>威逼</li><li>利诱</li><li>鼓励承诺：位于马斯洛需求理论的4级以上，应当是主要的方式，并且最好以团队为单位做承诺</li></ol><h5 id="√马斯洛需求层次理论">√马斯洛需求层次理论</h5><p><img lazyload src="/images/loading.svg" data-src="24-Spring-%E8%BD%AF%E4%BB%B6%E8%B4%A8%E9%87%8F%E4%B8%8E%E7%AE%A1%E7%90%86/1719552424166-12.png" alt="img"></p><ol><li>马斯洛需求理论：生理需求、安全感、爱和归属、获得尊敬、自我实现<ol><li>自我实现是最高的层次</li><li>激励来自为没有满足的需求而努力奋斗</li><li>低层次的需求必须在高层次需求满足之前得到满足</li><li>满足高层次的需求的途径比满足低层次的途径更为广泛</li></ol></li></ol><h5 id="√期望理论">√期望理论</h5><p>期望理论：<strong>Motivation = Valence * Expectancy</strong></p><ol><li>M：激发力量，积极性</li><li>V：<strong>目标价值</strong>(效价)，达到目标对于满足个人需要的价值，有正零负三种，效价越高，激励力量越大</li><li>E：<strong>期望值</strong>，人们根据过去经验判断自己达到某种目标的可能性大小</li></ol><h5 id="其他理论">其他理论</h5><ol><li>海兹伯格的激励保健理论 Herzberg’s Motivational and Hygiene Factors<ol><li>内在（成就感，责任感）+外在（环境薪资）</li></ol></li><li>麦克勒格的 X－理论 和 Y －理论 McGregor’s Theory X and Y<ol><li><strong>X理论</strong>：基于这种观点，管理者认为员工本质上是懒惰的，缺乏野心，抗拒变化，并且总是避免责任。因此，这种观点认为，必须通过严格的监控、控制和处罚来管理员工。</li><li><strong>Y理论</strong>：在这种观点中，管理者认为员工是自我激励和自我控制的，愿意接受和寻求责任。他们认为工作是自然的，像休息和玩耍一样。基于Y理论的管理风格强调赋予权力、员工参与和整体目标的追求。</li><li>麦克格雷戈强调，采用Y理论的管理风格可以更有效地激发员工潜能，提高工作效率和满意度。</li></ol></li></ol><h5 id="相应的领导方式">相应的领导方式</h5><ol><li><strong>交易型领导方式</strong><ol><li>承诺奖励激励</li><li>人们通常能找到新的方式来获得奖励，同时少做工作。</li><li>威逼和利诱属于交易型领导方式。</li></ol></li><li><strong>转变型领导方式</strong><ol><li>用成就激励</li><li>鼓励承诺属于转变型领导方式。</li></ol></li><li>由于交易型领导方式很少能产生成功的并且有创造性的团队，因此<strong>转变型领导方式</strong>是首选。</li></ol><h4 id="维持激励水平">维持激励水平</h4><p>维持激励需要<strong>及时的绩效反馈</strong>，这些反馈包括</p><ol><li>根据一个详细计划衡量进度</li><li>当前计划不准确时重做计划</li><li>为漫长而富有挑战性的项目提供中间反馈，即里程碑</li></ol><h3 id="√自主团队">√自主团队</h3><ol><li>定义：<ol><li>一个团队必须包括至少<strong>两个成员</strong>，他们为了<strong>共同的目标和愿景</strong>而努力工作，他们每个人都有<strong>明确的角色和相应的职责定义</strong>，任务的完成需要团队成员<strong>互相依赖和支持</strong>。</li><li>如果团队成员都实现了<strong>自我管理</strong>，也就形成了所谓的自主团队。（可结合知识工作特点等说明）</li></ol></li><li>特点<ol><li>自行定义项目的目标</li><li>自行决定团队组成形式以及成员的角色</li><li>自行决定项目的开发策略</li><li>自行决定项目的开发过程</li><li>自行制定项目的开发计划</li><li>自行度量、管理和控制项目工作</li></ol></li></ol><h3 id="√内外部环境">√内外部环境</h3><p><strong>内部环境：</strong>=特点</p><p><strong>外部环境：（大的2点）</strong></p><ul><li>项目启动阶段获得管理层的支持<ul><li>项目小组应当体现出已经尽最大的可能在满足管理层的需求的工作态度。</li><li>项目小组应当在计划中体现定期需要向管理层报告的内容。</li><li>项目小组应当向管理层证明他们所制定的工作计划是合理的。</li><li>项目小组应当在计划中体现为了追求高质量而开展的工作。</li><li>项目小组应当在工作计划中允许必要的项目变更。</li><li>项目小组应当向管理层寻求必要的帮助。</li></ul></li><li>在项目进展过程中获得管理层的支持<ul><li>项目小组应当严格遵循定义好的开发过程开展项目开发工作。</li><li>项目小组应当维护和更新项目成员的个人计划和团队计划。</li><li>项目小组应当对产品质量进行管理。</li><li>项目小组应当跟踪项目进展，并定期向管理层报告。</li><li>项目小组应当持续地向管理层展现优异的项目表现。</li></ul></li></ul><p><img lazyload src="/images/loading.svg" data-src="24-Spring-%E8%BD%AF%E4%BB%B6%E8%B4%A8%E9%87%8F%E4%B8%8E%E7%AE%A1%E7%90%86/1719552424166-13.png" alt="img"></p><blockquote><p>团队成员自身努力，团队规范合理制定，团队管理妥善 -&gt; 自主团队</p></blockquote><h3 id="√TSP角色和职责">√TSP角色和职责</h3><ul><li><strong>项目组长</strong>：激励成员、主持例会、汇报项目、分配任务、维护资料、组织总结</li><li><strong>计划经理</strong>：开发项目计划、平衡计划、跟踪进度、参与总结</li><li><strong>开发经理</strong>：开发策略、估算时间、文档编写、产品实现、集成测试、参与总结</li><li><strong>质量经理</strong>：开发质量计划、报告问题、评审问题、组织协调、参与总结</li><li><strong>过程经理</strong>：记录内容、维护标准、维护记录、参与总结</li><li><strong>支持经理</strong>：工具开发、管理配置、维护词汇、参与总结</li><li><strong>开发人员</strong>：参与开发</li></ul><p><img lazyload src="/images/loading.svg" data-src="24-Spring-%E8%BD%AF%E4%BB%B6%E8%B4%A8%E9%87%8F%E4%B8%8E%E7%AE%A1%E7%90%86/1719552424166-14.png" alt="img"></p><p><img lazyload src="/images/loading.svg" data-src="24-Spring-%E8%BD%AF%E4%BB%B6%E8%B4%A8%E9%87%8F%E4%B8%8E%E7%AE%A1%E7%90%86/1719552424166-15.png" alt="img"></p><h4 id="√TSP启动过程">√TSP启动过程</h4><p><img lazyload src="/images/loading.svg" data-src="24-Spring-%E8%BD%AF%E4%BB%B6%E8%B4%A8%E9%87%8F%E4%B8%8E%E7%AE%A1%E7%90%86/1719552424166-16.png" alt="img"></p><ul><li>第一次和第二次会议由项目经理主持</li><li>第三次会议<ul><li>TSP灵活：自定义的流程让人相信项目可以成功</li><li>开发策略：打算进行几个迭代周期。</li></ul></li><li>几个认识<ul><li>错误的认识：软件开发阶段理解为注入缺陷的阶段，软件测试阶段理解为消除缺陷的阶段。</li><li>正确的认识：开发和测试都是既有可能引入缺陷，也有可能消除缺陷的阶段</li></ul></li><li>项目完成的实际时间由什么决定？最晚完成的工作的人决定的</li></ul><h3 id="√SCRUM角色和职责">√SCRUM角色和职责</h3><blockquote><p>ppt上还有点内容，可以多看看</p><p>Scrum 是一个敏捷开发项目管理框架</p></blockquote><ol><li><strong>产品负责人（Product Owner）</strong>：<ol><li>产品负责人是团队与客户及其他利益相关者之间的关键联系人。他们的主要职责是确保开发团队所开发的产品能够带来最大的价值。为此，产品负责人需要管理产品待办列表（Product Backlog），这是一个按优先级排序的功能需求列表，确保团队始终专注于最重要的任务。</li></ol></li><li><strong>Scrum Master</strong>：<ol><li>Scrum Master的角色可以看作是团队的引导者和教练。他们的任务是确保团队正确理解并遵循Scrum的理论、实践和规则。Scrum Master帮助团队解决进度中的障碍，优化流程，确保团队能高效运作。</li></ol></li><li><strong>开发团队</strong>：<ol><li>开发团队负责具体的产品开发工作。在Scrum中，他们需要交付高质量、可发布的产品增量。这意味着在每个Sprint（迭代周期）结束时，团队应产出完全可用的产品功能。团队成员在日常工作中自主管理自己的工作和时间，强调团队合作和自我管理。</li></ol></li></ol><p>这三个角色共同协作，通过每个迭代不断调整和优化工作方式，以确保项目的顺利进行，并最终达到高效交付高质量软件产品的目标。</p><p>典型SCRUM团队由一名<strong>产品负责人、开发团队</strong>和一名 <strong>SCRUM Master</strong> 组成</p><p>SCRUM团队是跨职能的自组织团队</p><p><strong>产品负责人：</strong></p><ul><li>产品负责人的职责是将开发团队开发的产品价值最大化。</li><li>产品负责人是负责管理产品待办列表的唯一负责人。产品待办列表的管理包括：（应该看看就好）<ul><li>清晰地表述产品待办列表项；</li><li>对产品待办列表项进行排序，使其最好地实现目标和使命；</li><li>优化开发团队所执行工作的价值；</li><li>确保产品待办列表对所有人是可见、透明和清晰的，同时显示 Scrum 团队 下一步要做的工作；</li><li>以及确保开发团队对产品待办列表项有足够深的了解。</li></ul></li></ul><p><strong>开发团队：</strong></p><ul><li>负责在每个 Sprint 结束时交付潜在可发布并且“完成”的产品增量。</li><li>开发团队由组织组建并得到授权，团队自己组织和管理他们的工作。开发团队具有下列特点：（应该看看就好）<ul><li>他们是自组织的。没有人（即使是 Scrum Master）有权告诉开发团队应该 如何把产品待办列表变成潜在可发布的功能增量；</li><li>开发团队是跨职能的团队，团队作为一个整体，拥有创建产品增量所需的全 部技能；</li><li>Scrum 不认可开发团队成员的任何头衔，不管其承担何种工作（他们都叫开 发人员）。</li><li>Scrum 不认可开发团队中所谓的“子团队”，无论其需要处理的领域是诸如测 试、架构、运维或业务分析；同时， 开发团队中的每个成员也许有特长和专注的领域，但是责任属于整个开发团队。</li></ul></li></ul><p><strong>Scurm Master:</strong></p><ul><li>促进和支持 SCRUM</li><li>帮助每个人理解 SCRUM 理论、实践、规则和价值</li><li>SCRUM Master 是一位服务型领导。 帮助 SCRUM 团队之外的人了解如何与 SCRUM 团队交互是有益的 改变SCRUM 团队之外的人与 SCRUM 团队的互动方式来最大化 SCRUM 团 队所创造的价值。</li><li>Scrum Master 服务于产品负责人，包括：<ul><li>确保 Scrum 团队中的每个人都尽可能地理解目标、范围和产品域；</li><li>找到有效管理产品待办列表的技巧；</li><li>帮助 Scrum 团队理解为何需要清晰且简明的产品待办列表项；</li><li>理解在经验主义的环境中的产品规划；</li><li>确保产品负责人懂得如何来安排产品待办列表使其达到最大化价值；</li><li>理解并实践敏捷性；以及，</li><li>当被请求或需要时，引导 Scrum 事件。</li></ul></li><li>Scrum Master 以各种方式服务于开发团队，包括<ul><li>作为教练在自组织和跨职能方面给予开发团队以指导；</li><li>帮助开发团队创造高价值的产品；</li><li>移除开发团队工作进展中的障碍；</li><li>按被请求或需要时，引导 Scrum 事件；以及，</li><li>在 Scrum 还未完全采纳和理解的组织环境中，作为教练指导开发团队。</li></ul></li><li>Scrum Master 以各种方式服务于组织，包括：<ul><li>带领并作为教练指导组织采纳 Scrum；</li><li>在组织范围内规划 Scrum 的实施；</li><li>帮助员工和利益攸关者理解并实施 Scrum 和经验导向的产品开发；</li><li>引发能够提升 Scrum 团队生产率的改变；以及，</li><li>与其他 Scrum Master 一起工作，增强组织中 Scrum 应用的有效性。</li></ul></li></ul><h3 id="√估算和计划">√估算和计划</h3><h4 id="关于估算的一些事实"><strong>关于估算的一些事实</strong></h4><p>估算对象是：规模、时间、日程</p><ol><li>估算是客观猜测</li><li>估算能力很难提升</li><li>没有任何人知道准确的数字究竟是什么</li><li>多项实证研究表明，是否使用估算模型（例如，COCOMO）并没有显著差异</li></ol><h4 id="√估算的要点">√估算的要点</h4><ul><li>尽可能划分详细一些</li><li>目标是<strong>建立对结果的信心</strong></li><li>尽量依赖数据</li><li>估算要的是过程，而非结果；估算的过程是相关干系人达成一致共识的过程</li></ul><h4 id="√估算目的是什么">√估算目的是什么</h4><p>目的是给<strong>各类计划提供决策依据、达成共识、建立信心</strong>（足够详细、依赖数据、最好的猜测）</p><h3 id="√PROBE估算方法">√PROBE估算方法</h3><ol><li>以 LOC VS. FP 为例（LOC精确度量，FP早期规划）<ol><li><strong>精确度量</strong>方式往往不便于<strong>早期规划</strong>；</li><li>有助于<strong>早期规划</strong>的度量往往难以产生<strong>精确度量</strong>结果；</li></ol></li><li>PROBE(PROxy Based Estimation)<strong>基本原理/作用</strong></li></ol><ul><li>设立合理的代理作为精确度量和早期规划之间的桥梁</li><li>相对大小，而非绝对大小</li></ul><h4 id="流程"><strong>流程</strong></h4><p><img lazyload src="/images/loading.svg" data-src="24-Spring-%E8%BD%AF%E4%BB%B6%E8%B4%A8%E9%87%8F%E4%B8%8E%E7%AE%A1%E7%90%86/1719552424166-17.png" alt="img"></p><h4 id="相对大小矩阵">相对大小矩阵</h4><p><img lazyload src="/images/loading.svg" data-src="24-Spring-%E8%BD%AF%E4%BB%B6%E8%B4%A8%E9%87%8F%E4%B8%8E%E7%AE%A1%E7%90%86/1719552424167-18.png" alt="img"></p><h4 id="概要设计">概要设计</h4><blockquote><p><strong>“如果你对产品的理解还不足以产出一个概要设计，那么你所知道的还不足以做出一个计划”</strong></p><p>**对于大多数的项目，概要设计都应相对较快地完成：**例如，1000LOC 以内程序，试着将概要设计时间限制在10到20分钟之内</p></blockquote><ol><li><strong>估算的第一步是做出一个概要设计</strong><ol><li>概要设计不是真实设计</li><li>与已有产品/组件 相关联</li><li>定义能够产生期望功能的产品元素</li><li>估算你计划构造之物的规模</li></ol></li><li>为了做出概要设计，需要确定产品功能，以及产生这些功能所需的<strong>程序组件/模块</strong>：“如果我有以下这些部件，我可以构造这个产品。”</li><li>然后，将这些<strong>程序组件/模块</strong>与你以前写的程序相比较，估算它们的规模</li><li>最后，将<strong>程序组件/模块</strong>估算综合给出总规模</li></ol><h3 id="整合估算">整合估算</h3><p>整合多个估算结果</p><ul><li>整合一个开发人员做的多个估算</li><li>多个开发人员可以整合独立进行的估算</li><li><strong>当估算多个部件时，总的误差会比各个部件误差的总和要小。</strong><ul><li><strong>误差趋于抵消了</strong></li><li><strong>假设没有共同的偏差</strong></li></ul></li></ul><blockquote><p>估算要点一</p></blockquote><h3 id="√SCRUM故事点">√SCRUM故事点</h3><ul><li>度量实现一个故事（Story）需要付出的工作量<ul><li>抽象：混合了对于开发特性所要付出的努力、开发复杂度、各种风险以及类似东西</li><li>相对：设定标准之后，考虑其他特性（feature）与标准之间的相对大小关系</li></ul></li><li>度量体现着决策者对试图要实现的目标的关切程度</li></ul><blockquote><p>在敏捷开发实践中，团队通常会进行一次“规划扑克”（Planning Poker）会议，利用斐波那契数列来为每个用户故事分配故事点数值。</p></blockquote><blockquote><p>估算要点二、三</p></blockquote><h3 id="关于度量">关于度量</h3><p><strong>度量体现着决策者对试图要实现的目标的关切程度</strong></p><p>PSP基本度项：规模 时间 缺陷 日程（TSP）</p><blockquote><p>以下开始是团队项目规划/计划的部分</p><p><img lazyload src="/images/loading.svg" data-src="24-Spring-%E8%BD%AF%E4%BB%B6%E8%B4%A8%E9%87%8F%E4%B8%8E%E7%AE%A1%E7%90%86/1719552424167-19.png" alt="img"></p></blockquote><h3 id="WBS-Work-Breakdown-Structure">WBS(Work Breakdown Structure)</h3><p><img lazyload src="/images/loading.svg" data-src="24-Spring-%E8%BD%AF%E4%BB%B6%E8%B4%A8%E9%87%8F%E4%B8%8E%E7%AE%A1%E7%90%86/1719552424167-20.png" alt="img"></p><p><strong>好的WBS检查标准</strong></p><ol><li>最底层要素不能重复，即任何一个工作包应该在WBS中的一个地方且只应该在WBS中的一个地方出现。</li><li>所有要素必须清晰完整定义，即相应的数据词典必须完整定义。</li><li>最底层要素必须有定义清晰的责任人，可以支持成本估算和进度安排。</li><li>最底层的要素是实现目标的成分必要条件，即项目的工作范围得到完整体现。</li></ol><h3 id="√通用计划框架">√通用计划框架</h3><p><img lazyload src="/images/loading.svg" data-src="24-Spring-%E8%BD%AF%E4%BB%B6%E8%B4%A8%E9%87%8F%E4%B8%8E%E7%AE%A1%E7%90%86/1719552424167-21.png" alt="img"></p><ol><li>上述框架中，那些步骤必须人为的干预<ol><li>定义需求</li><li>概要设计：划分由人为开始，规模划分好之后估算是自动产生的</li><li>日程计划</li></ol></li><li>这会带来什么的好处？比较容易扛住别人的质疑。<ol><li>攻击点：资源和时间是否被高估了</li><li>解决：估算没有代码行PROBE只有功能点是大中小。</li></ol></li></ol><h3 id="过程框架——生命周期模型（不背了）">过程框架——生命周期模型（不背了）</h3><p><img lazyload src="/images/loading.svg" data-src="24-Spring-%E8%BD%AF%E4%BB%B6%E8%B4%A8%E9%87%8F%E4%B8%8E%E7%AE%A1%E7%90%86/1719552424167-22.png" alt="img"></p><h3 id="√各类计划">√各类计划</h3><h4 id="日程计划">日程计划</h4><ol><li>任务计划和日程计划</li><li>典型计划流程回顾<ol><li>估算规模</li><li>估算资源</li><li>规划日程</li></ol></li><li>考虑假期的影响：时间计划和工作计划并存。</li></ol><blockquote><p>前者描述了项目所有的任务清单、任务之间的先后顺序以及每个任务所需时间资源；后者描述了整个各个任务在日程上的安排，即各个任务计划哪天开始和计划哪天结束。</p></blockquote><h4 id="√质量计划">√质量计划</h4><ul><li>项目的质量计划中应当确定需要开展的质量保证活动。</li><li>典型的质量保证活动包括个人评审、团队评审、单元测试、集成测试、系统测试以及验收测试等。</li><li>在质量计划中需要解决的关键的问题是该开展哪些活动，以及这些活动开展的程度，如时间、人数和目标分别是什么。</li></ul><blockquote><p>需要将项目总体质量目标细分成若干小的目标，这样便于在过程中进行管理和控制。结合本书第3章中介绍的质量管理指标，yield， PQI以及A/FR等，图 6‑4给出了质量管理计划的示例。途中右下角是质量总体目标，即整个系统在系统测试之后总的缺陷数应当小于6.63个。那么相应需要开展的质量保证活动以及每个活动的yield可以根据历史数据或者一般的行业数据确定。而每个质量管理活动所需时间则由PQI指标和A/FR指标加以确定。事实上，PQI和A/FR指标也是为了确保yield目标的实现。</p></blockquote><h4 id="√风险计划">√风险计划</h4><ul><li>风险管理的目的是在风险发生前，识别出潜在的问题，以便在产品或项目的生命周期中规划和实施风险管理活动，以消除潜在问题对项目的负面影响。</li></ul><ol><li>风险识别<ol><li><strong>识别</strong>成本、进度、绩效、环境因素、组件</li><li><strong>记录</strong>风险的内容、条件和结果，识别干系人</li><li><strong>评估、分类、分组、排列优先级</strong></li></ol></li><li>风险应对<ol><li><strong>风险转嫁</strong>：通过某种安排，在放弃部分利益的同时，将部分的项目风险转嫁到其他的团队或者组织。</li><li><strong>风险解决</strong>：指采取一些有效措施，使得风险的来源不再存在。</li><li><strong>风险缓解</strong>：容忍风险的存在，采取一些措施监控风险，不让风险对项目最终目标的实现造成负面影响。</li></ol></li></ol><blockquote><p>风险管理是一个持续的、前瞻的过程，此过程是项目管理的重要部分。有效的风险管理是通过相关干系人的合作与参与，尽早且积极地识别风险，制定项目风险管理计划。风险管理须同时考虑有关成本、进度、绩效及其他风险的内部及外部来源。因为在项目初期进行变更或修正的工作负荷，通常比在项目后期来得容易、花费较低及较不具破坏性，所以，早期及积极的风险侦测是重要的。风险管理大致分成两部分，即风险识别和风险应对。</p></blockquote><h3 id="√定量管理计划（自顶向下）不确定">√定量管理计划（自顶向下）不确定</h3><p><img lazyload src="/images/loading.svg" data-src="24-Spring-%E8%BD%AF%E4%BB%B6%E8%B4%A8%E9%87%8F%E4%B8%8E%E7%AE%A1%E7%90%86/1719552424167-23.png" alt="img"><img lazyload src="/images/loading.svg" data-src="24-Spring-%E8%BD%AF%E4%BB%B6%E8%B4%A8%E9%87%8F%E4%B8%8E%E7%AE%A1%E7%90%86/1719552424167-24.png" alt="img"></p><h4 id="过程性能">过程性能</h4><p>遵循某个特定（子）过程的之后产生结果的量化描述，既包括（子）过程度量Xi（例如，时间、缺陷消除效率、工时等），也包括产物度量Yi（例如，缺陷密度，相应时间等）。</p><h4 id="过程性能基线">过程性能基线</h4><p>上述过程性能的一个定量化的刻画，一般包括均值和范围。通常用作过程性能的benchmark。</p><p><img lazyload src="/images/loading.svg" data-src="24-Spring-%E8%BD%AF%E4%BB%B6%E8%B4%A8%E9%87%8F%E4%B8%8E%E7%AE%A1%E7%90%86/1719552424167-25.png" alt="img"></p><h4 id="过程-子过程性能模型">过程/子过程性能模型</h4><p>依据子过程的逻辑关系构建相应的数学模型，描述子过程性能基线和整体过程有意义的性能输出（例如，质量、生产效率、成本等）之间关系。例如 过程Yield 和 Phase Yield。</p><h4 id="过程组合：关键子过程性能目标、整体过程性能目标">过程组合：关键子过程性能目标、整体过程性能目标</h4><blockquote><p>以下是跟踪部分</p><p>团队项目的跟踪与管理主要包括<strong>进度的跟踪（利用不同跟踪方法，例如挣值管理、里程碑评审）</strong>、<strong>纠偏活动管理</strong></p></blockquote><h4 id="定量管理的基本范式">定量管理的基本范式</h4><p>定量管理基本范式：</p><ol><li>构建定量模型：子过程能力基线、<strong>过程模型</strong></li><li>应用模型：监控影响子过程的关键因素</li></ol><h3 id="项目跟踪意义">项目跟踪<strong>意义</strong></h3><ul><li>项目进展过程中开展跟踪活动的目的在于了解项目进度，以便在项目实际进展与计划产生严重偏离时，可采取适当的纠正措施。<ul><li>项目进度滞后与否是否需要参照物，即项目计划。</li><li>项目跟踪需要管理针对偏差而采取的纠偏措施</li></ul></li></ul><blockquote><p>正如Brooks在《人月神话》一书中指出的那样，**项目延迟整整一年是一次延迟一天慢慢积累起来的。**开展及时有效的项目跟踪就是期望及时发现项目实际进展与计划之间的偏差，及时处理这些偏差，从而消除累计的偏差对项目造成的负面影响。</p><p>例如，在软件工程实践中，有一条流传非常广泛的经验总结，即向一个已经落后的项目中增加人手，往往导致项目更加落后。而在实践中，一旦出现项目落后的情况，往往都会采取增加人手的方法来应对。</p></blockquote><h3 id="挣值管理-EV-体系">挣值管理(EV)体系</h3><p>项目的挣值管理方法(Earned Value Management，简称EVM)是用来客观度量项目进度的一种项目管理方法。</p><ul><li>每项任务实现附以一定价值（credit）</li><li>100%完成该项任务，就获得相应价值。</li></ul><p>EVM采用与进度计划、成本预算和实际成本相联系的三个独立的变量，进行项目绩效测量。</p><p><img lazyload src="/images/loading.svg" data-src="24-Spring-%E8%BD%AF%E4%BB%B6%E8%B4%A8%E9%87%8F%E4%B8%8E%E7%AE%A1%E7%90%86/1719552424167-26.png" alt="img"></p><p>BAC表示按照PV值的曲线，当项目完成的时候所需预算或者时间。</p><p><strong>成本差异CV = EV-AC</strong>，表示的是已经完成的工作与所消耗的成本的差异。可以表示为消耗的时间，也可以表示为消耗的资金。</p><p><strong>成本差异指数CPI = EV/AC</strong>，表示单位成本创造的价值，很显然，CPI&lt;1说明成本超支；CPI=1说明成本与预期一致；CPI&gt;1说明成本低于预期。</p><p><strong>日程偏差SV = EV–PV</strong>，表示进度偏差。显然SV&lt;0表示进度落后；SV=0表示进度正常；SV&gt;0表示进度超前。</p><p><strong>日程偏差指数SPI = EV/PV</strong>。</p><p><strong>预计完成成本EAC = AC+(BAC-EV)/CPI = BAC/CPI</strong>，表示的是按照目前的进展已经成本消耗情况，整个项目完成的时候所需消耗的成本。</p><blockquote><p>EV已经产生的价值，AC已经消耗的本钱，PV此时需要达到的预期价值</p><p>该图此时出现了加班情况，AC在增长，可能是加班费</p></blockquote><h4 id="√简单、中级和高级">√简单、中级和高级</h4><ul><li><strong>简单</strong><ul><li>这种方式仅仅关注进度信息。在实现时，首先需要建立WBS，定义工作范围；其次为WBS中每一项工作定义一个价值（PV）；最后按照一定的规则将某一数值赋给已经完成的工作或者正在进行的工作。</li><li>常用规则分别为0-100规则和50-50规则，前者只有当某项任务完成时，该任务的PV值将转化成EV值；后者只需要开始某项任务，即可以赋原PV值的50%作为EV值，完成时，再加上另外的50%。而实际完成的工作所需成本AC不对EV值产生任何影响。</li></ul></li><li><strong>中级</strong><ul><li>在简单实现的基础上，加入日程偏差的计算。典型计算方式有：</li><li>日程偏差SV = EV – PV;</li><li>日程偏差指数SPI = EV/PV；</li></ul></li><li><strong>高级</strong><ul><li>在中级实现的基础上，还需要考察项目的实际成本。</li></ul></li></ul><h4 id="EVM的局限性">EVM的局限性</h4><ol><li>EVM一般不能应用软件项目的质量管理。</li><li>EVM需要定量化的管理机制，这就使其在一些探索型项目以及部分敏捷开发方法中的应用受到限制。</li><li>EVM完全依赖项目的准确估算（价值体系），然而在项目早期，很难对项目进行非常准确的估算。</li></ol><h4 id="√为何适应软件项目">√为何适应软件项目</h4><ol><li>支持动态变更</li><li>相对保守的策略（全部完成才能拿到）</li></ol><h4 id="变形：燃尽图">变形：燃尽图</h4><p><img lazyload src="/images/loading.svg" data-src="24-Spring-%E8%BD%AF%E4%BB%B6%E8%B4%A8%E9%87%8F%E4%B8%8E%E7%AE%A1%E7%90%86/1719552424167-27.png" alt="img"></p><h3 id="里程碑评审"><strong>里程碑评审</strong></h3><blockquote><p>旨在特定的项目阶段或关键点对项目的进展进行评估和审查</p></blockquote><ol><li><strong>软件项目的里程碑往往是指某个时间点，用以标记某些工作的完成或者阶段的结束。</strong><ol><li>典型的里程碑事件：<ol><li>完成某项工作</li><li>获得干系人签字认可</li><li>完成某产物的评审</li><li>修改或交付某产物</li></ol></li></ol></li><li><strong>里程碑评审的审查内容包括：</strong><ol><li>项目相关的承诺，如日期、规格、质量等等；</li><li>项目各项计划的执行状况；</li><li>项目当前的状态讨论；</li><li>项目面临的风险讨论等</li></ol></li><li><strong>里程碑评审也可用于质量管理</strong></li></ol><h3 id="项目总结">项目总结</h3><p><img lazyload src="/images/loading.svg" data-src="24-Spring-%E8%BD%AF%E4%BB%B6%E8%B4%A8%E9%87%8F%E4%B8%8E%E7%AE%A1%E7%90%86/1719552424167-28.png" alt="img"></p><h4 id="基于PMBOK的总结">基于PMBOK的总结</h4><p>范围管理、时间管理、成本管理、质量管理、人力资源管理、沟通管理、风险管理、采购管理和整合管理9大知识领域</p><h4 id="TSP项目总结">TSP项目总结</h4><ul><li>TSP也提供了一种项目总结的方式，在这种方式当中，团队成员结合自己的角色，总结自己角色相关工作的得失，提出下一个开发周期的改进建议。</li><li><strong>典型角色包括项目组长、计划经理、开发经理、质量经理、过程经理和支持经理等</strong></li></ul><p><img lazyload src="/images/loading.svg" data-src="24-Spring-%E8%BD%AF%E4%BB%B6%E8%B4%A8%E9%87%8F%E4%B8%8E%E7%AE%A1%E7%90%86/1719552424167-29.png" alt="img"></p><h4 id="√EVM体系为何适应软件项目">√EVM体系为何适应软件项目</h4><ol><li>支持动态变更</li><li>相对保守的策略（全部完成才能拿到）</li></ol><h3 id="√定量管理的跟踪（自底向上）">√定量管理的跟踪（自底向上）</h3><h4 id="√关于子过程性能控制">√关于子过程性能控制</h4><h2 id="质量管理线-2">质量管理线</h2><h3 id="√软件质量的概念">√软件质量的概念</h3><p>软件质量为“与软件产品满足规定的和隐含的需求能力有关的特征或者特性的全体”</p><ol><li>软件质量的内外两部分的特性<ol><li>内部质量特性：不直接面向用户</li><li>外部质量特性：面向软件产品的最终用户</li></ol></li><li>软件质量的不同视角<ol><li>软件质量为软件产品可以改变世界，使世界更加美好的程度(用户满意度是最为重要的判断标准)</li><li>软件质量是对人的价值，强调质量的主观性(对同一款软件而言，不同的用户对其质量有不同的体验)</li></ol></li></ol><h3 id="√质量管理的挑战：三要素">√质量管理的挑战：三要素</h3><p><strong>成本、质量、工期</strong>（也就是软件质量管理的三大目标）</p><blockquote><p>“软件项目的日程、成本以及质量三大目标统一于质量目标。”</p></blockquote><h3 id="√面向用户的质量观">√面向用户的质量观</h3><p>定义<strong>质量</strong>为<strong>满足用户需求的程度</strong>，这个定义中需要进一步明确：</p><ol><li>用户究竟是谁？</li><li>用户需求的优先级是什么？</li><li>用户的优先级对软件产品的开发过程产生什么影响？</li><li>怎么度量这种质量观下的质量水平？</li><li>指导意义：开发在前，运维在后；高质量开发确保DevOps中的价值顺畅流动；个体软件工程师的技能、过程直接影响产品质量；PSP关注提升个体软件工程师工程技能</li></ol><p><strong>典型用户质量期望</strong>：</p><ol><li>这款软件产品必须能够工作；</li><li>这款软件产品最好有较快的执行速度；</li><li>这款软件产品最好在安全性、保密性、可用性、可靠性、兼容性、可维护性、可移植性等方面表现优异；</li></ol><blockquote><p>这样的列表可以一直列举下去，列表中各项内容的顺序也可以变化，这取决于用户期望、开发环境和应用环境等因素。但是，相信几乎在任何一个列表中，**都会把软件产品能够工作作为一个最基本的期望。**事实上，如果软件产品本身不能工作，那么考虑其他的期望是没有意义的。而为了使一个软件产品可以工作，该产品基本没有缺陷是最基本的要求。这样一来，整个软件产品的质量目标就可以归结成首先得确保基本没有缺陷，然后再考察其他的质量目标。<strong>PSP中就采用了这样的方式，用缺陷管理来替代质量管理，这大大简化了质量管理的方法，使得质量管理更加易于操作。</strong></p><p>（PSP：质量管理 简化-&gt; 缺陷管理）</p></blockquote><h3 id="质量管理策略和背后逻辑">质量管理策略和背后逻辑</h3><ul><li>用缺陷管理来替代质量管理</li><li>高质量产品也就意味着要求组成软件产品的各个组件基本无缺陷</li><li>各个组件的高质量是通过高质量评审来实现的</li></ul><h4 id="缺陷消除">缺陷消除</h4><p><img lazyload src="/images/loading.svg" data-src="24-Spring-%E8%BD%AF%E4%BB%B6%E8%B4%A8%E9%87%8F%E4%B8%8E%E7%AE%A1%E7%90%86/1719552424167-30.png" alt="img"></p><h4 id="测试消除缺陷的典型流程">测试消除缺陷的典型流程</h4><ol><li>发现待测程序的一个异常行为；</li><li>理解程序的工作方式；</li><li>调试程序，找出出错的位置，确定出错原因；</li><li>确定修改方案，修改缺陷；</li><li>回归测试，以确认修改有效；</li></ol><blockquote><p>在上述的步骤当中，有一些步骤极耗时间。比如步骤③，在项目的后期，往往会消耗数天甚至数周的时间。此外，在有些软件项目中，开发团队、测试团队和正式发布团队往往分开。那么如果用户在使用软件的过程中发现缺陷，再通过正式沟通渠道将信息反馈到开发团队，然后等待修改和发布，重新安装补丁，这一流程消耗数月时间也是常事。</p></blockquote><h4 id="评审发现缺陷的主要流程">评审发现缺陷的主要流程</h4><ol><li>遵循评审者的逻辑来理解程序流程；</li><li>发现缺陷的同时，也知道了缺陷的位置和原因；</li><li>修正缺陷；</li></ol><blockquote><p>在上述的步骤中，每一步消耗的时间都不会太多。尽管评审的技能因人而异，但是，通过适当培训和积累，有经验的评审者可以发现80%左右的缺陷。</p></blockquote><h3 id="PSP评审过程的质量">PSP评审过程的质量</h3><ul><li>评审检查表</li><li>质量控制指标</li><li>其他因素<ul><li>环境</li><li>评审时机</li><li>个人评审和小组评审</li><li>缺陷预防</li></ul></li></ul><h3 id="√个人评审">√个人评审</h3><h4 id="关键控制因素">关键控制因素</h4><p>速度</p><h4 id="时机选择">时机选择</h4><p>编译/UT前还是后？<strong>（所以先review再编译/UT）</strong></p><ol><li>**态度方面：**如果review在编译/UT之后，会对review态度产生影响，会有一种这个代码已经差不多对了的感受，态度上会有影响。态度很重要：review要么不做，要做就要抱着查出错误的心态，而不是内心已经认可了，导致code review做的很快，比如2000loc/h</li><li>**效率成本方面：**在review的时候先发现一些bug，编译/测试的时间会变少，也就是先编译后评审的时间会 &gt; 先评审后编译</li><li>**高质量软件开发的要求方面：**要降低编译时发生的错误数，是高质量软件开发的要求 =&gt; 先评审后编译</li><li>编译之前评审也是一种自我学习的好机会</li><li>干净的编译，即编译过程没有缺陷对于软件工程师来说，也有极大的成就感</li></ol><h3 id="√小组评审">√小组评审</h3><p><strong>小组评审时机（个人评审之后）</strong></p><ul><li>小组评审通常安排在个人评审之后进行，尤其是在详细设计和代码开发阶段之后。这样的安排有助于提升Process Yield，即过程产出率。</li><li>在个人评审后进行小组评审还有利于提升个人技能，尤其是对那些个人评审未发现但小组评审中发现的缺陷，这些缺陷需要引起足够的注意，并通过对这些缺陷的分析使软件工程师能够学习到很多东西。</li></ul><p><strong>小组评审的组织形式</strong>：</p><ul><li><strong>准备阶段</strong>：<ul><li>由评审的组织者召集参与人员开一个准备会议。</li><li>评审对象的作者需要向参与人员简要介绍评审对象的内容。</li><li>组织者向参与人员介绍评审的目标、标准及其他注意事项。</li><li>在所有人员都了解评审对象和目标之后，由组织者总结会议并确定下一次评审阶段会议的时间。</li></ul></li><li><strong>评审阶段</strong>：<ul><li>组织者确认所有评审参与人员已经完成了各自的评审活动后，再召集所有人开会讨论交流各自评审过程中发现的缺陷，并确定修改责任人和修改期限。</li></ul></li></ul><p><strong>小组评审的附加功能</strong>：</p><ul><li>除了提升产品的质量之外，小组评审还有助于判断评审产物的质量状况。</li><li>引入了“Catch and Re-Catch”方法来评价评审对象的质量状况，这是从统计学中估算池塘中鱼总数的方法演变而来。</li></ul><blockquote><p>参考 <a class="link" href="https://imgss.s3.bitiful.net/2024/06/27/20240627005600.png">https://imgss.s3.bitiful.net/2024/06/27/20240627005600.png <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p></blockquote><h4 id="过程质量控制方式">过程质量控制方式</h4><ol><li><strong>九宫格(by jhdd)</strong><ol><li>在软件质量管理中，使用“Review Rate”和“Defect Density (DD)”构成的九宫格是一种常见的方法，用于评估和可视化软件质量及代码审查的效果。这种矩阵帮助团队识别在哪些区域可以提高代码审查的质量和效率，以便更有效地发现和减少软件缺陷。下面是关于这个九宫格的详细解释：</li><li>九宫格是一个3x3的矩阵，其中：</li><li><strong>纵轴（Review Rate）</strong>：表示代码审查的频率或深度，分为低、中、高。</li><li><strong>横轴（Defect Density）</strong>：表示每单位代码中的缺陷数量，同样分为低、中、高。</li></ol></li><li><strong>Catch and Re-Catch</strong><ol><li>小组评审只有两个人参加。假设评审人员A和B分别发现了a个缺陷和b个缺陷，其中c个缺陷两人同时发现。利用上述思想，选择a-c和b-c中较大值，如果相等则可以任选一值。假设a-c是选定的值，那么就可以把a当成上述第一网被标记的鱼，c是第二网中被标记的鱼。简单计算就可以估算出评审对象经过小组评审之后，还遗留a x b/c -(a+b-c)个缺陷。<ol><li>a / 总数 = c / b -&gt; (a*b) / c</li></ol></li><li>小组评审有多人参加。小组评审如果有多人参与，那么情况就相对复杂。我们采取了一个简化的计算方法。即选择某个独立发现缺陷最多的评审员作为A，而其他所有参与人员的整体作为B。那么我们仍然可以用上述相同的方式来估算小组评审之后评审对象中遗留的缺陷数。</li></ol></li></ol><h3 id="质量控制指标">质量控制指标</h3><blockquote><p>这部分最好看看ppt例子</p></blockquote><h4 id="Yield">Yield</h4><ul><li>Yield指标用以度量每个阶段在消除缺陷方面的效率。越大越好，希望在80以上<ul><li><strong>Phase Yield</strong> = 100 * （某阶段发现的缺陷个数）/（某阶段注入的缺陷个数+进入该阶段前遗留的缺陷个数）</li><li><strong>Process Yield</strong> = 100 * （第一次编译前发现的缺陷个数）/（第一次编译前注入的缺陷个数）</li></ul></li></ul><p><strong>例子</strong></p><table><thead><tr><th>阶段</th><th>Injected</th><th>Removed</th><th>remain</th><th>Yield</th></tr></thead><tbody><tr><td>DFD</td><td>10</td><td>0</td><td>10</td><td>0</td></tr><tr><td>DFD REVIEW</td><td>0</td><td>4</td><td>6</td><td>40</td></tr><tr><td>CODING</td><td>20</td><td>2</td><td>24</td><td>1/13 * 100</td></tr><tr><td>CODE REVIEW</td><td>0</td><td>12</td><td>12</td><td>50</td></tr><tr><td>UNIT</td><td>0</td><td>12</td><td>0</td><td>100</td></tr></tbody></table><table><thead><tr><th>阶段</th><th>Injected</th><th>Removed</th><th>remain</th><th>Yield</th></tr></thead><tbody><tr><td>DFD</td><td>10+4</td><td>0</td><td>14</td><td>0</td></tr><tr><td>DFD REVIEW</td><td>0</td><td>4</td><td>10</td><td>2/7 * 100</td></tr><tr><td>CODING</td><td>20+8</td><td>2</td><td>36</td><td>2/19 * 100</td></tr><tr><td>CODE REVIEW</td><td>0</td><td>12</td><td>12</td><td>1/3 * 100</td></tr><tr><td>UNIT</td><td>0</td><td>12</td><td>12</td><td>50</td></tr></tbody></table><h4 id="A-FR">A/FR</h4><ol><li>COQ(Cost of Quality)<ol><li>失效成本：分析失效现象、查找原因，做必要的修改所消耗的成本</li><li>质检成本：评价软件产品，确定其质量状况所消耗的成本</li><li>预防成本：识别缺陷根本原因、采取措施预防其再次发生所消耗的成本</li></ol></li><li>质检失效比<ol><li>A/FR = PSP质检成本 / PSP失效成本</li><li>质检成本 = 设计评审时间 + 代码评审时间</li><li>失效成本 = 编译时间 + 单元测试时间</li></ol></li><li>理论上，A/FR值越大，意味着质量越高，但A/FR值过大说明评审过多，则开发效率低下，因此PSP中A/FR期望值为2.0</li></ol><blockquote><p>也就是说，为了确保较高的质量水平，软件工程师应当花费两倍于编译加测试的时间进行评审工作。评审的对象为设计和代码。</p></blockquote><h4 id="PQI">PQI</h4><p>5个数据乘积**（五个数值都是0到1，然后相乘出来也是0到1）**</p><ul><li>设计质量：设计的时间应该大于编码的时间, min{设计时间/编码时间, 1}</li><li>设计评审质量：设计评审的时间应该大于设计时间的50%，min{(2 * 设计评审时间 / 设计时间), 1}</li><li>代码评审质量：代码评审时间应该大于编码时间的50%，min{(2 * 代码评审时间)/编码时间 , 1}</li><li>代码质量：代码的编译缺陷密度应当小于10个/千行，min{20/(编译缺陷密度 + 10), 1}</li><li>程序质量：代码单元测试缺陷密度应当小于5个/千行 min{10/(单元测试缺陷密度 + 5), 1}</li></ul><p><img lazyload src="/images/loading.svg" data-src="24-Spring-%E8%BD%AF%E4%BB%B6%E8%B4%A8%E9%87%8F%E4%B8%8E%E7%AE%A1%E7%90%86/1719552424167-31.png" alt="img"></p><p><strong>PQI的作用</strong></p><ol><li>判断模块质量</li><li>评估项目质量</li><li>直接可以为软件改进做依据（之前两者是没有的）<ol><li>比如最后一个PQI图可以给出的建议<ol><li>增加设计时间</li><li>增加设计评审时间</li><li>增加代码评审时间</li></ol></li></ol></li><li><strong>只追求到0.4，而不是很高的值</strong></li></ol><h4 id="Review-rate">Review rate</h4><ul><li>评审的速度（Review Rate）是一个用以指导软件工程师开展有效评审的指标</li><li>高质量的评审需要软件工程师投入足够的时间进行评审</li><li>在PSP的实践中，代码评审速度小于200 LOC/小时，文档评审速度小于4 Page/小时</li></ul><blockquote><p>如果不计成本的投入大量时间进行评审，尽管可能发现较多的缺陷，但是又会影响到整个软件过程的生产效率。因此，应当为评审设置一个恰当的速度。</p></blockquote><h4 id="DRL">DRL</h4><ul><li>缺陷消除效率比度量的是<strong>不同缺陷消除手段</strong>消除缺陷的效率。</li><li>其计算方式是以<strong>某个测试阶段</strong>（一般为单元测试）<strong>每小时发现的缺陷数</strong>为基础，其他阶段每小时发现缺陷数与该测试阶段每小时发现的缺陷的比值就是DRL。</li></ul><p><img lazyload src="/images/loading.svg" data-src="24-Spring-%E8%BD%AF%E4%BB%B6%E8%B4%A8%E9%87%8F%E4%B8%8E%E7%AE%A1%E7%90%86/1719552424167-32.png" alt="img"></p><h3 id="评审的其他考虑因素">评审的其他考虑因素</h3><ul><li>打印后评审往往效果更好<ul><li>单个屏幕可以展现的内容比较有限</li><li>评审人员的注意力</li></ul></li><li>评审时机选择<ul><li>编译/UT 之前 VS. 之后</li></ul></li><li>个人评审和小组评审<ul><li>小组评审意义</li><li>先后顺序</li></ul></li></ul><h3 id="特点和用途">特点和用途</h3><p>上面这五个怎么用，能干什么，有什么特点大概讲讲</p><h3 id="Quality-Journey">Quality Journey</h3><h4 id="Journey是什么？顺序？">Journey是什么？顺序？</h4><p>为了追求极高的质量，你有哪些手段？</p><ul><li>Step 1：各种测试</li><li>Step 2：进入测试之前的产物质量提升</li><li>Step 3：评审过程度量和稳定</li><li>Step 4：质量意识和主人翁态度</li><li>Step 5：个体review的度量和稳定</li><li>Step 6：诉诸设计</li><li>Step 7：缺陷预防</li><li>Step 8：用户质量观——其他质量属性</li></ul><h3 id="设计">设计</h3><h4 id="设计与质量的关系？为什么要进行设计？">设计与质量的关系？为什么要进行设计？</h4><ol><li>低劣的设计是导致在软件开发中返工、不易维护以及用户不满的主要原因。</li><li>充分设计可以显著减少最终程序的规模，提升质量。</li><li>设计本身也是一种排错的过程。</li></ol><h4 id="典型设计过程">典型设计过程</h4><p><img lazyload src="/images/loading.svg" data-src="24-Spring-%E8%BD%AF%E4%BB%B6%E8%B4%A8%E9%87%8F%E4%B8%8E%E7%AE%A1%E7%90%86/1719552424167-33.png" alt="img"></p><h4 id="模板：要设计哪些信息？">模板：要设计哪些信息？</h4><ul><li>设计目标程序在<strong>整个应用系统中的位置</strong>；</li><li>设计目标程序的<strong>使用方式</strong>；</li><li>设计目标程序与<strong>其他组件以及模块之间的关系</strong>；</li><li>设计目标程序<strong>外部可见的变量和方法</strong>；</li><li>设计目标程序<strong>内部运作机制</strong>；</li><li>设计目标程序<strong>内部静态逻辑</strong>；</li></ul><table><thead><tr><th></th><th>动态信息</th><th>静态信息</th></tr></thead><tbody><tr><td>外部信息</td><td>交互信息（服务、消息等）</td><td>功能（继承、类结构等）</td></tr><tr><td>内部信息</td><td>行为信息（状态机）</td><td>结构信息（属性、业务逻辑等）</td></tr></tbody></table><h4 id="PSP设计模板">PSP设计模板</h4><p>操作规格模板OST、功能规格模板FST、状态规格模板SST、逻辑规格模板LST（PPT有详细说明）</p><p><img lazyload src="/images/loading.svg" data-src="24-Spring-%E8%BD%AF%E4%BB%B6%E8%B4%A8%E9%87%8F%E4%B8%8E%E7%AE%A1%E7%90%86/1719552424167-34.png" alt="img"><img lazyload src="/images/loading.svg" data-src="24-Spring-%E8%BD%AF%E4%BB%B6%E8%B4%A8%E9%87%8F%E4%B8%8E%E7%AE%A1%E7%90%86/1719552424168-35.png" alt="img"></p><h4 id="设计的层次">设计的层次</h4><p>系统-子系统-组件-模块 | 需求定义-规格说明-高层设计</p><p><img lazyload src="/images/loading.svg" data-src="24-Spring-%E8%BD%AF%E4%BB%B6%E8%B4%A8%E9%87%8F%E4%B8%8E%E7%AE%A1%E7%90%86/1719552424168-36.png" alt="img"></p><p>PSP模板</p><p><img lazyload src="/images/loading.svg" data-src="24-Spring-%E8%BD%AF%E4%BB%B6%E8%B4%A8%E9%87%8F%E4%B8%8E%E7%AE%A1%E7%90%86/1719552424168-37.png" alt="img"><img lazyload src="/images/loading.svg" data-src="24-Spring-%E8%BD%AF%E4%BB%B6%E8%B4%A8%E9%87%8F%E4%B8%8E%E7%AE%A1%E7%90%86/1719552424168-38.png" alt="img"></p><h3 id="设计评审（验证）">设计评审（验证）</h3><p>意义：简单评审不足以发现复杂缺陷</p><p>方法：状态机验证、符号化执行验证、执行表验证、跟踪表验证、正确性验证</p><h4 id="状态机验证">状态机验证</h4><ul><li>正确状态机<ul><li>**完整性：**对于状态机中任何一个状态，对应的所有条件组合，下一个状态的转换都有定义</li><li>**正交性：**对于状态机中任何一个状态，其所有下一个状态的转换条件都不能相同</li></ul></li><li>验证方法<ul><li>检验状态机，消除死循环和陷阱状态。</li><li>检查状态转换，验证完整性和正交性。</li><li>评价状态机，检验是否体现设计意图</li></ul></li></ul><h4 id="符号化执行验证">符号化执行验证</h4><p>符号化验证方法的基本思想是将描述设计的<strong>逻辑规格</strong>（一般用伪代码程序表示）用<strong>代数符号</strong>来表示，然后系统地开展分析和验证。具体步骤如下：</p><ul><li>识别伪码程序中的关键变量；</li><li>将这些变量用代数符号表示，重写伪码程序；</li><li>分析伪码程序的行为。</li></ul><p><img lazyload src="/images/loading.svg" data-src="24-Spring-%E8%BD%AF%E4%BB%B6%E8%B4%A8%E9%87%8F%E4%B8%8E%E7%AE%A1%E7%90%86/1719552424168-39.png" alt="img"></p><p><strong>优缺点分析：</strong></p><ul><li>符号化验证的方法实施简单，可以给出一般化的验证结果，很多时候往往是唯一提供全面验证的方式。</li><li>这种方法通常用在验证一些复杂算法中，特别是对遗留系统的改造中，往往应用这种方法来识别和理解原有的设计。</li><li>但是这种验证方法不适用于有复杂逻辑的场合，而且，纯手工的验证方法也容易引入一些人为的错误。</li></ul><h4 id="执行表验证">执行表验证</h4><p><strong>执行表</strong>用一种有序的方法来跟踪伪码程序的执行状况，分析程序行为，从而验证设计。具体步骤如下：</p><ul><li>识别伪码程序的关键变量；</li><li>构建表格，表格左侧填入主要程序步骤，右侧填入关键变量；</li><li>初始化被选定的变量；</li><li>跟踪被选择的关键变量的变化情况，从而判断程序行为。</li></ul><p><img lazyload src="/images/loading.svg" data-src="24-Spring-%E8%BD%AF%E4%BB%B6%E8%B4%A8%E9%87%8F%E4%B8%8E%E7%AE%A1%E7%90%86/1719552424168-40.png" alt="img"></p><h4 id="跟踪表验证">跟踪表验证</h4><p>跟踪表验证方法是对执行表验证方法的一种扩充。具体步骤如下：</p><ul><li>识别伪码程序的关键变量；</li><li>构建表格，表格左侧填入主要程序步骤，右侧填入关键变量；</li><li>初始化被选定的变量；</li><li><strong>识别将伪码程序符号化的机会，并加以符号化；</strong></li><li><strong>定义并且优化用例组合；</strong></li><li>跟踪被选择的关键变量的变化情况，从而判断程序行为。</li></ul><blockquote><p><strong>比较：执行表一般只能用以验证单独的用例，跟踪表应用符号化以及用例识别等方法，对程序的一般化行为进行验证，从而提供更加高效地开展验证工作。</strong></p></blockquote><h4 id="正确性检验">正确性检验</h4><p>正确性检验将伪码程序当成数学定理，采用形式化方法加以推理和验证。这种方法的步骤如下：</p><ul><li>分析和识别用例；</li><li>对于复杂伪码程序的结构，应用正确性检验的标准问题逐项加以验证；（比如，循环不变式）</li><li>对于不能明确判断的复杂程序结构，使用跟踪表等辅助验证。</li></ul><p><strong>示例while 正确性检验</strong></p><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (condition) </span><br><span class="line">begin</span><br><span class="line">    states;</span><br><span class="line">end</span><br></pre></td></tr></table></figure></div><p>条件1： condition是否最终一定会为“假”，从而使得循环可以结束；</p><p>条件2： condition为“真”的时候，单独的循环结构执行结果与循环体再加一个循环结构，其执行结果是否一致？</p><p>条件3： condition为“假”的时候，循环体内所有变量是否未被修改？</p><h2 id="工程技术线-2">工程技术线</h2><p>需求开发、团队设计、实现策略、集成策略、验证与确认</p><h3 id="需求">需求</h3><ol><li><strong>需求是一切工程活动的基础</strong></li><li>需求类别<ol><li>客户需求</li><li>产品需求</li><li>产品组件需求</li></ol></li></ol><h3 id="√客户需求">√客户需求</h3><p>描述的是<strong>客户的期望</strong>。</p><ol><li>往往表现为，**客户在实际工作中碰到了一些具体问题，希望通过某个东西来帮忙解决这些问题。**客户的这种解决问题的愿望，往往就表述为客户需求。<ol><li>比如，客户希望有一种快速进行数据计算的工具帮助他/她完成繁琐的计算工作。这就是一个客户需求。</li></ol></li><li>**客户需求可能很简单，也可能很复杂；可能很清晰，也可能很模糊。**这就需要开发团队与客户一起进行交流、协商，从而弄清客户的真正意图。</li></ol><h3 id="√产品需求">√产品需求</h3><p>描述的是<strong>开发团队所提供的解决方案</strong>。即针对上述的客户需求，开发团队设计出一个可以帮助客户解决工作当中碰到的问题的方案。</p><blockquote><p>如上例，产品需求就是提供一个可以输入数据，可以计算符号，可以显示计算结果的手持设备。产品需求是对客户需求的一个提炼和精化，把客户需求真正的表述为开发人员能够理解的语言。同样，产品需求需要进行验证，以确保客户的真实意图得到了体现。</p></blockquote><h3 id="产品组件需求">产品组件需求</h3><p>描述的是<strong>组成产品的各个组件的需求规格</strong>。与产品需求相比，这是更低层次上，更为细致的描述了上述解决方案中的某个组件的功能、性能、形式等。</p><blockquote><p>需求开发-需求获取-需求汇总-需求验证-需求文档制作（优秀的需求规格文档特征）</p></blockquote><h3 id="√产品经理？">√产品经理？</h3><h3 id="团队设计">团队设计</h3><h4 id="√自顶向下">√自顶向下</h4><p>在设计的过程当中，采取的基本策略是<strong>自顶向下，逐层精化</strong>的策略。<strong>这有利于建立系统的整体观。<strong>然而，在实现过程当中，应当</strong>更多的考虑到是否便于对实现结果的评审。</strong></p><h4 id="√团队智慧的使用">√团队智慧的使用</h4><p>发挥团队智慧两大挑战</p><ul><li><strong>确定整体架构之前很难进行分工</strong></li><li><strong>鼓励团队成员在讨论和评审会议中的参与程度</strong></li></ul><blockquote><p>每个团队成员都有不同的知识背景和工作经验，因此，如果设计工作中可以充分发挥每个人的特长，往往对项目带来极大的帮助。然而，设计工作面临的一个很大挑战是在确定整体架构之前很难进行分工。而缺乏合理的分工就不能可充分发挥团队智慧。对于该问题的处理办法是视软件系统的规模而定，选择适当人数的团队成员参与整体架构的开发，而其他人员参与架构的评价和关键技术问题的验证。</p></blockquote><blockquote><p>发挥团队智慧的另外一个问题是鼓励团队成员在讨论和评审会议中的参与程度。由于各种原因，如掌握项目信息的差异和个人知识背景的差异，在讨论会议中，有些团队成员倾向于主导会议讨论，而有的团队成员则不愿意发表见解。这就需要会议的协调者，特别是项目组长或者设计工作的负责人采取适当的方法来调动整个团队的参与。</p></blockquote><h4 id="设计标准">设计标准</h4><ul><li><strong>命名规范</strong><ul><li>项目小组应当设计一个统一的命名规范来命名各个模块并建立系统词典，用以描述各个模块。系统词典在整个系统的设计、实现以及支持文档的开发过程中要时刻保持可用状态。此外，还需要通过命名规范来约定系统的架构类型和名称，典型的包括系统、子系统、组件、模块、程序等。在编码过程中程序的命名、文件的命名、变量的命名以及参数的命名等都需要通过命名规范加以定义。</li></ul></li><li><strong>接口标准</strong><ul><li>组件之间的接口标准和格式也需要作为设计标准的内容之一加以定义。事实上，软件工程的一些设计原则，如高内聚、低耦合等也应当作为接口标准定义的内容，从而约束了模块之间信息交互的方式。</li></ul></li><li><strong>系统出错信息</strong><ul><li>系统异常信息和出错信息往往也需要通过一个规范加以标准化。从而使得出错信息有个一致的、便于理解的描述。此外，也便于在设计和开发中的复用。</li></ul></li><li><strong>设计表示标准</strong><ul><li>设计表示标准定义了设计工作的产物应当满足的标准。这有可能是所有设计标准中最为重要的一项内容。在设计表示标准的定义中，必须明确给出完整而准确地表示设计结果的标准。从而帮助项目团队用一致的方式来表现其设计结果。在本书4.3节中介绍的PSP设计模板可以作为设计表示标准的基础，项目小组可以基于4个设计模板，再参考设计的层次，合理定义团队设计表示的标准。</li></ul></li></ul><blockquote><p>复用可以显著提升团队生产效率和质量水平，然而，问题是复用的机会并不是偶然发生的，需要设计人员在项目尽可能的早期加以考虑。“Design For Reuse”被很多软件工程方法识别为最佳实践。这句话就深刻体现了在设计的时候，需要为了创造复用机会而有一些特别的考虑。</p></blockquote><h4 id="Design-For-Reuse复用性支持">Design For Reuse复用性支持</h4><p>在设计阶段必须要充分考虑复用的可能。为了支持复用，软件项目团队需要建立一套复用管理流程，具体而言，包括</p><ul><li><strong>复用接口标准</strong><ul><li>在识别可复用组件的时候，需要以高内聚、低耦合的的设计思想来设计可复用组件。另外，为了便于使用，还得定义复用组件的接口标准，比如参数、变量、返回值以及异常消息的格式与命名等。</li></ul></li><li><strong>复用文档标准</strong><ul><li>通常软件工程师在识别复用组件时，往往直接研究代码，这相当耗时。因此，大部分软件工程师倾向于使用自己开发的复用组件。在团队开发中，为了尽可能提升复用机会，对于可复用组件必须提供详细支持文档，便于团队其他人使用。在文档中需明确组件功能、调用方式、返回值类型以及可能的异常信息。此外，项目团队应当为复用文档定义一个统一的模板和标准。</li></ul></li><li><strong>复用质量保证机制</strong><ul><li>复用组件由于有可能在整个系统的多处被使用，因此，复用组件的质量有尤其重要。否则，复用组件中的一个错误会被传播到软件系统各处。为了获得较高的组件质量，建议采用高质量过程来开发，如PSP2.1过程。另外，还得对待复用组件进行充分的测试。根据过程数据来判断复用组件的质量。</li></ul></li></ul><h4 id="可测试性支持">可测试性支持</h4><p>设计可测试性考虑主要体现在两方面：</p><ul><li>一是要<strong>尽可能减少测试代码的数量</strong>；</li><li>二是要<strong>制定合理的测试计划</strong>。</li></ul><blockquote><p>减少测试代码的数量主要通过合理的架构设计来体现。而合理的测试计划对于可测试性的帮助往往被忽视。事实上，充分开展测试计划的开发工作，往往可以在计划阶段就可以发现相当多的缺陷，甚至比真正的测试工作发现的缺陷还要多。完整的设计工作和操作场景定义，有助于更好的开展测试计划工作。</p></blockquote><h4 id="可用性支持">可用性支持</h4><ul><li>可用性的问题应当在设计阶段就开始考虑，而不能推延到实现阶段。</li><li>针对每一个关键功能都定义操作概念和操作场景。</li><li>分析操作场景以确保软件系统开发完成之后，系统使用者会满意。</li><li>必要时，可以邀请最终用户参与场景的评审，使用模拟、原型等技术，更好的把握用户真实意图。</li></ul><h3 id="实现">实现</h3><h4 id="评审的考虑">评审的考虑</h4><p>在设计的过程当中，采取的基本策略是自顶向下，逐层精化的策略。这有利于建立系统的整体观。然而，在实现过程当中，应当更多的考虑到是否便于对实现结果的评审。**因此，建议采取的策略是自底向上进行实现。**按照这种策略，在实现的过程中优先实现底层的内容，然后这些底层的模块进行评审，以确保其质量。然后基于有着坚实质量基础的模块，再进行高层实现。</p><p><strong>此外，这种策略还有利于复用策略的应用。已经实现了的底层模块有着更多被复用的机会。</strong></p><h4 id="复用的考虑">复用的考虑</h4><p>除了上述的自底向上实现策略来支持复用之外，为了更加有效支持复用，还需要其他的一些实践。例如，编码注释的应用和每天站立式会议的应用。编码注释应当使用统一的格式，在每个源码文件的开头明确提供有利于复用的重要信息，如功能、调用方式、异常信息等。必要时，可以结合一些自动化工具来自动收集这些信息，便于查询。</p><h4 id="可测性考虑">可测性考虑</h4><p>实现阶段对于可测试性的考虑主要体现在实现的计划必须与测试计划一致，从而避免进行集成测试的时候，部分模块没有实现所带来的不便。</p><h3 id="集成">集成</h3><h4 id="覆盖范围">覆盖范围</h4><h4 id="基本策略">基本策略</h4><h5 id="爆炸"><strong>爆炸</strong></h5><p>该策略将所有已经完成的组件<strong>放在一起</strong>，进行<strong>一次集成</strong>。这是一种看起来非常具有吸引力策略。因为这有可能是需要<strong>测试用例最少</strong>的一种方式。然而，这需要所有待集成的产品组件都具有<strong>较高的质量水平</strong>，否则，<strong>难以定位</strong>缺陷位置的缺点会使得该策略<strong>消耗很多测试时间</strong>。而且，系统越复杂、规模越大，问题越突出。</p><h5 id="逐一添加">逐一添加</h5><p>该策略与上述的大爆炸集成策略<strong>完全相反</strong>，采取一次添加一个组件的方式进行集成。因此其优点就在于很容易定位缺陷的位置，特别在产品组件质量不高的情况下，每次集成之前都有着<strong>坚实的质量基础</strong>。但是，该方法的缺点也很突出。这可能是需要<strong>测试用例最多</strong>的一种策略，而且，大量的回归测试也会消耗很多时间。</p><h5 id="集簇式">集簇式</h5><p>集簇集成策略是对<strong>逐一添加集成策略</strong>的改进。简单的随机选择产品组件进行集成并不合理。为了提升测试效率，往往会把<strong>有相似功能或者有关联的模块优先进行集成</strong>，形成可以工作的组件。然后以组件为单位继续较高层次的集成。此外，这种策略还有一个好处就是，可以尽早获得一些可以工作的组件，有利于其他组件测试工作的开展。但是，这种策略的缺点是<strong>过于关注个别组件</strong>，而<strong>缺乏系统的整体观</strong>，不能尽早发现系统层面的缺陷。</p><h5 id="扁平化">扁平化</h5><p>该策略要求尽快构建一个可以工作的扁平化系统。也就是说，<strong>优先集成高层</strong>的部件，然后<strong>逐步将各个组件、模块的真正实现</strong>加入系统。这种方式可以尽早发现系统层面的缺陷。然而，该策略的缺陷是为了确保完成的系统，需要大量的打“桩”（stub），即提供一些直接提供返回值的伪实现。这种方式往往不能覆盖整个系统应该处理的多种状态。</p><blockquote><p>CI/CD是哪一种？逐一添加</p></blockquote><h3 id="V-V验证与确认">V&amp;V验证与确认</h3><h4 id="概念和区别">概念和区别</h4><h5 id="Verification-验证">Verification 验证</h5><p>验证(Verification)活动也是检验获得的产品和产品组件能不能满足各自事先定义好的需求规格；</p><h5 id="Validation-确认">Validation 确认</h5><p>确认(Validation)活动是为了确保产品可以满足客户的需求以及实际操作场景的要求。</p><h5 id="区别"><strong>区别</strong></h5><ul><li>验证是目的是确保选定的工作产品与事先指定给该工作产品的需求一致。</li><li>确认的目标则是确保开发完成的产品或者产品组件在即将要使用该产品或者产品组件的环境中工作正确。</li></ul><p>因此，<strong>验证</strong>关注的是是否正确的把软件产品开发出来，即与需求规格一致；<strong>确认</strong>关注的是是否开发了正确的软件产品，即是否能帮用户解决实际问题。</p><h5 id="关联"><strong>关联</strong></h5><p><strong>验证(Verification)和确认(Validation)都是为了提升最终产品的质量而采取的措施。</strong></p><p>**另一方面，验证和确认又是相互依存、关系紧密的两个活动。**验证活动的依据来源于确认的目标，即产品组件需求必须与客户需求一致；验证活动为确认活动提供了前提条件，在完全产品需要和产品组件需求之前，考察客户需求是否满足是没有意义的。</p><h4 id="验证与确认活动">验证与确认活动</h4><h5 id="环境准备"><strong>环境准备</strong></h5><p>不管是验证工作还是确认工作，环境非常重要，对于验证工作来说，如果是同行评审，就需要准备文件材料、人员以及会议场所等；如果是测试，则可能需要模拟器、场景生成程序、环境控制以及其他系统接口等。对于确认工作而言，环境的准备更加重要，因为确认要考察的是在真实环境中产品是否工作正常，因此，要求尽可能模拟真实环境和场景。如果是模拟环境，则需要开展分析工作，以弄清模拟环境与真实环境的差别以及对测试结果的影响。</p><h5 id="对象选择"><strong>对象选择</strong></h5><p>不是所有的工作产品都需要进行验证和确认。这一点在项目计划阶段都应当建立起相应的验证计划和确认计划。这里需要明确两个不同的概念，即产品和工作产品。产品是面向客户的，需要向客户提交的工作结果；而工作产品则往往是过程的直接结果。并不是所有的工作产品都需要向客户提交，因此，产品一定是工作产品，而反之则不成立。验证活动的对象往往从工作产品中选择而确认活动的对象则从产品中选择。</p><h5 id="活动实施"><strong>活动实施</strong></h5><p>验证和确认的活动主要就是评审和测试。一般情况下，可以将整个项目生命周期中早期对产品需求评审工作和最后的验收测试作为确认工作，而其他的评审和测试工作当成是验证工作。当然，严格的划分验证活动还是确认活动还是应该从活动本身的目标出发，加以区分。</p><h5 id="结果分析"><strong>结果分析</strong></h5><p>对于验证和确认工作的结果需要进行适当分析，以找出潜在问题和改进机会。如对于设计规格说明书的评审工作之外，应当分析一下设计过程的有效性，预测（Catch and Re-Catch）设计规格说明书中还隐藏的缺陷。对于验收测试结果的分析，往往可以重点考察那些一直遗留到验收阶段才被发现的缺陷，看看这些缺陷在什么阶段被引入，为什么前面未能发现等。</p><h2 id="其他-2">其他</h2><h3 id="配置管理">配置管理</h3><p>**目的：**建立与维护工作产品的完整性</p><h4 id="配置项">配置项</h4><ul><li><strong>配置项</strong>：在配置管理当中作为单独实体进行管理和控制的工作集合。</li></ul><h4 id="基线">基线</h4><ul><li><strong>基线</strong>：一个或多个配置项及相关的标识符的代表，是一组经正式审查同意的规格或工作产品集合，是未来开发工作或交付的基础，而且只能经由严格的变更控制程序才能改变。<ul><li>发布时间点：需求分析后、设计完成后、单元测试后、最终产品发布后</li><li>配置项持续演进的稳定基础</li></ul></li></ul><p><strong>配置管理的活动</strong></p><ul><li>识别和记录配置项的物理特性和功能特性；</li><li>控制上述特性的变更；</li><li>记录和报告变更过程和相应的配置项状态；</li><li>验证配置项是否与需求一致。</li></ul><p><img lazyload src="/images/loading.svg" data-src="24-Spring-%E8%BD%AF%E4%BB%B6%E8%B4%A8%E9%87%8F%E4%B8%8E%E7%AE%A1%E7%90%86/1719552424168-41.png" alt="img"></p><h4 id="配置管理的对象"><strong>配置管理的对象</strong></h4><p>典型的可能作为配置项纳入配置管理的工作产品包括：</p><ul><li>过程说明文档</li><li>项目开发计划文档</li><li>需求规格说明书</li><li>设计规格说明书</li><li>设计图表</li><li>产品规格说明书</li><li>程序代码</li><li>开发环境，如特定版本的编译器等</li><li>产品数据文件</li><li>产品技术文件</li><li>用户支持文档</li></ul><h3 id="度量和分析">度量和分析</h3><p><strong>目的</strong>：支持管理的信息需要</p><p><strong>意义</strong>：基于客观的数据对决策很重要，可以显著消除错误决策的风险。而客观数据的获取需要按照一定的流程用正确的方式获得和使用。度量和分析活动就定义了上述客观数据的获取与使用方式。</p><p><img lazyload src="/images/loading.svg" data-src="24-Spring-%E8%BD%AF%E4%BB%B6%E8%B4%A8%E9%87%8F%E4%B8%8E%E7%AE%A1%E7%90%86/1719552424168-42.png" alt="img"></p><p><strong>度量和分析活动可以支持如下的项目管理活动</strong>：</p><ul><li>客观的估计与计划</li><li>根据建立的计划和目标，跟踪实际进展</li><li>识别与解决/过程改进/相关议题</li><li>提供将度量结果纳入未来其他过程的基础</li></ul><h4 id="GQM度量体系">GQM度量体系</h4><p>GQM(Goal Question Metric)是一种应用非常广泛的建立软件度量体系的方法，从管理的目标出发，将目标归纳、分解为度量的指标，并把这些指标提炼成可以测量的值，是一种科学的、系统的思考问题的方式。</p><p><img lazyload src="/images/loading.svg" data-src="24-Spring-%E8%BD%AF%E4%BB%B6%E8%B4%A8%E9%87%8F%E4%B8%8E%E7%AE%A1%E7%90%86/1719552424168-43.png" alt="img"></p><ol><li>概念层(目标)：目标是为某个特定的对象而定义的。这里的对象是指软件产品、软件过程以及相关的资源等。定义的目标基于不同原因和不同质量模型,也要参考不同的角色视图与特定的环境。</li><li>操作层(问题)：基于一定的刻画上述目标是否达成或者目标达成的进展情况的模型，使用一系列的问题来定义所研究的对象, 然后得出评价或评估特定目标达成进展情况。所选择的问题应当尽量体现质量相关的话题。</li><li>量化层(度量)：试图以量化的方式回答上述操作层识别出来的问题。</li></ol><p><strong>GQM示例-PM（项目管理）</strong></p><p>G: 确保稳定性、可预测性的开发过程来满足计划的里程碑。</p><p>Q: 我的项目是否按照计划的轨迹前进，计划的里程碑都能实现吗？</p><p>M: 软件项目开发工作的挥发性（分支、流、变更管理活动）。</p><p><strong>GQM示例-DM（开发管理）</strong></p><p>G: 最大化所有团队贡献者的生产力。</p><p>Q: 开发人员能够完成分配给他们的任务吗，或者他们遇到障碍了吗？</p><p>M: 由个体或者工作组产生的项目工件的量级</p><h3 id="决策分析与解决方案">决策分析与解决方案</h3><p>**决策分析的意义：**错误的决策往往会给项目带来灾难性后果。为了降低这种错误决策的风险，往往需要尽可能基于客观事实和正确的流程来开展决策与分析活动</p><p><img lazyload src="/images/loading.svg" data-src="24-Spring-%E8%BD%AF%E4%BB%B6%E8%B4%A8%E9%87%8F%E4%B8%8E%E7%AE%A1%E7%90%86/1719552424168-44.png" alt="img"></p><p><strong>一个正式评估过程往往包含下列的活动：</strong></p><ul><li>建立评估备选方案的准则</li><li>识别备选解决方案</li><li>选择评估备选方案的方法</li><li>使用已建立的准则与方法，评估备选解决方案</li><li>依据评估准则，从备选方案中选择建议方案</li></ul><h4 id="“招投标“">“招投标“</h4><h3 id="根因分析与解决方案">根因分析与解决方案</h3><p>根因<strong>分析的意义：</strong></p><ol><li>错误的决策往往会给项目带来灾难性后果。为了降低这种错误决策的风险，往往需要尽可能基于客观事实和正确的流程来开展决策与分析活动（同上？）</li><li>避免类似错误反复发生</li></ol><p><strong>一个正式根因分析过程往往包含下列的活动：</strong></p><ul><li>识别和选定问题</li><li>根因分析</li><li>建立改进的行动方案</li><li>实施改进，评估效果</li></ul><p><img lazyload src="/images/loading.svg" data-src="24-Spring-%E8%BD%AF%E4%BB%B6%E8%B4%A8%E9%87%8F%E4%B8%8E%E7%AE%A1%E7%90%86/1719552424168-45.png" alt="img"></p><h4 id="2-8法则">2-8法则</h4><p>约仅有20%的因素影响80%的结果。也就是说：所有变因中，最重要的仅有20%，虽然剩余的80%占了多数，影响的幅度却远低于“关键的少数”。</p><h4 id="根因分析典型示例-鱼骨图">根因分析典型示例: 鱼骨图</h4><p><img lazyload src="/images/loading.svg" data-src="24-Spring-%E8%BD%AF%E4%BB%B6%E8%B4%A8%E9%87%8F%E4%B8%8E%E7%AE%A1%E7%90%86/1719552424168-46.png" alt="img"></p><ol><li>典型角度：<strong>技术角度 、人员角度、 培训角度、过程角度</strong></li></ol><blockquote><p>配置管理：配置项和基线</p><p>度量和分析：GQM度量体系</p><p>决策分析和解决方案：招投标</p><p>根因分析和解决方案：2-8选择对象，鱼骨头根因分析</p></blockquote><h2 id="思考">思考</h2><ol><li>课堂思考练习</li><li>本课程要回答的十大问题</li><li><strong>软件项目管理和软件过程管理的区别？</strong></li><li>TSP和SCRUM的团队的组成有哪些共性？这些共性对于高效团队有什么帮助？</li></ol>]]></content>
      
      
      <categories>
          
          <category> 期末复习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件质量与管理 </tag>
            
            <tag> 期末大通关 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>摸鱼分享（一）：头号做题家分享 | 博客配置RSS</title>
      <link href="/posts/%E5%88%86%E4%BA%AB%E5%8F%91%E7%8E%B0/%E6%91%B8%E9%B1%BC%E5%88%86%E4%BA%AB%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E5%A4%B4%E5%8F%B7%E5%81%9A%E9%A2%98%E5%AE%B6%E5%88%86%E4%BA%AB-%E5%8D%9A%E5%AE%A2%E9%85%8D%E7%BD%AErss.html"/>
      <url>/posts/%E5%88%86%E4%BA%AB%E5%8F%91%E7%8E%B0/%E6%91%B8%E9%B1%BC%E5%88%86%E4%BA%AB%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E5%A4%B4%E5%8F%B7%E5%81%9A%E9%A2%98%E5%AE%B6%E5%88%86%E4%BA%AB-%E5%8D%9A%E5%AE%A2%E9%85%8D%E7%BD%AErss.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>Context：</p><p>2024.6.24从3点睡到6点，奋战软统</p><p>故今天11点半才起床</p></blockquote><h2 id="头号做题家分享">头号做题家分享</h2><p><a class="link" href="https://wxaurl.cn/VMgDNryOYLu">https://wxaurl.cn/VMgDNryOYLu <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p><p>起床看了个好玩的 <a href="#%E5%B0%8F%E7%A8%8B%E5%BA%8F://%E5%A4%B4%E5%8F%B7%E5%81%9A%E9%A2%98%E5%AE%B6/0Y5BlL0lCAtzeSj">头号做题家</a></p><p>复习软质累了可以玩玩</p><p>前作似乎是《完蛋！我被大模型包围了》</p><h2 id="体验">体验</h2><img lazyload src="/images/loading.svg" data-src="%E6%91%B8%E9%B1%BC%E5%88%86%E4%BA%AB20240605/3f986f0354e55d6f98438f611165190.jpg" alt="3f986f0354e55d6f98438f611165190" style="zoom:50%;"> <p>浅玩了玩第一道，8token有点牛的</p><img lazyload src="/images/loading.svg" data-src="%E6%91%B8%E9%B1%BC%E5%88%86%E4%BA%AB20240605/19cffa8868345b7de17620d791b089c.jpg" alt="19cffa8868345b7de17620d791b089c" style="zoom:50%;"> <h2 id="感受">感受</h2><p>挺有意思的，适合摸鱼，当然这字体看得我眼睛更累了（</p><p>这也算是一种LLM往游戏方面的探索？感觉如果未来加入多模态的话可玩性会更高（也许后面的关卡已经有了）</p><p>个人认为还是创新点有意思，正所谓“凡战者 以正合 以奇胜”（软质课rgp老师原话，首尾呼应，欧耶！）</p><p><img lazyload src="/images/loading.svg" data-src="%E6%91%B8%E9%B1%BC%E5%88%86%E4%BA%AB20240605/640.png" alt="Image"></p><blockquote><p>今年3月才正式浮出水面的国产基座大模型创业公司，创始人<strong>姜大昕</strong>，微软前全球副总裁、微软亚洲互联网工程研究院（STCA）前首席科学家。</p><p>甫一亮相，阶跃星辰就祭出了Step系列大模型“组合拳”：Step-1千亿参数语言大模型、Step-1V千亿参数多模态大模型、Step-2万亿参数MoE语言大模型。</p><p>不认识的国产大模型公司再++</p></blockquote><h2 id="RSS">RSS</h2><p>博客新增了RSS，感兴趣的可以加下喵~</p><p><img lazyload src="/images/loading.svg" data-src="%E6%91%B8%E9%B1%BC%E5%88%86%E4%BA%AB20240605/image-20240625142059226.png" alt="image-20240625142059226"></p><blockquote><p>ICON在右下角，藏得有点深</p></blockquote><p>RSS链接：<a class="link" href="https://syding.njuse.icu/atom.xml">https://syding.njuse.icu/atom.xml <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>]]></content>
      
      
      <categories>
          
          <category> 分享发现 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 摸鱼 </tag>
            
            <tag> 大模型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>24-Spring-软件系统设计期末复习</title>
      <link href="/posts/%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/24-spring-%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0.html"/>
      <url>/posts/%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/24-spring-%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>参考 <a class="link" href="https://wbl-z.github.io/%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E5%A4%8D%E4%B9%A0%E5%BE%80%E5%B9%B4%E9%A2%98/">zzb学长 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> | <a class="link" href="https://spricoder.github.io/2021/07/15/2021-Software-System-Design/2021-Software-System-Design-Exam0-%E5%BE%80%E5%B9%B4%E8%80%83%E8%AF%95/">zhy学长 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> | <a class="link" href="https://eaglebear2002.github.io/2023Spring-%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1-%E5%A4%8D%E4%B9%A0/">xqh学长 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p><p><a class="link" href="https://spricoder.github.io/2021/07/15/2021-Software-System-Design/2021-Software-System-Design-Lec21-Review%20Part2/#14-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%8E%E7%B1%BB%E5%BA%93%E6%A1%86%E6%9E%B6">lec21-软件系统设计复习 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p><p>致敬  <a class="link" href="https://github.com/SEBugMaker">SEBugMaker <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> <a class="link" href="https://quas-modo.github.io/">quas-modo <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p><p>zh老师部分不太好整理，花体看的眼花，说的道理</p><p><a class="link" href="https://refactoringguru.cn/design-patterns">设计模式 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> |<a class="link" href="https://design-patterns.readthedocs.io/zh-cn/latest/index.html">图说设计模式 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p></blockquote><h2 id="题型">题型</h2><div class="markdown-alert markdown-alert-important"><p class="markdown-alert-title"><svg class="octicon octicon-report mr-2" viewbox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="M0 1.75C0 .784.784 0 1.75 0h12.5C15.216 0 16 .784 16 1.75v9.5A1.75 1.75 0 0 1 14.25 13H8.06l-2.573 2.573A1.458 1.458 0 0 1 3 14.543V13H1.75A1.75 1.75 0 0 1 0 11.25Zm1.75-.25a.25.25 0 0 0-.25.25v9.5c0 .138.112.25.25.25h2a.75.75 0 0 1 .75.75v2.19l2.72-2.72a.749.749 0 0 1 .53-.22h6.5a.25.25 0 0 0 .25-.25v-9.5a.25.25 0 0 0-.25-.25Zm7 2.25v2.5a.75.75 0 0 1-1.5 0v-2.5a.75.75 0 0 1 1.5 0ZM9 9a1 1 0 1 1-2 0 1 1 0 0 1 2 0Z"/></svg>Important</p><p></p><p>学长建议<mark>架构设计</mark>看往年卷，<mark>设计模式</mark>看ppt</p></div><p>简答+设计</p><h2 id="软件模式">软件模式</h2><p><img lazyload src="/images/loading.svg" data-src="https://imgss.s3.bitiful.net/2024/06/23/image-20240621103632968.png" alt="image-20240621103632968"></p><p><img lazyload src="/images/loading.svg" data-src="https://imgss.s3.bitiful.net/2024/06/23/image-20240621103643421.png" alt="image-20240621103643421"></p><h3 id="大三律Rule-Of-Three">大三律Rule Of Three</h3><p>在模式发现过程中需要遵循<strong>大三律(Rule of Three)</strong>，即只有经过<strong>三个以上不同类型（或不同领域）的系统的校验</strong>，一个<strong>解决方案</strong>才能从候选模式升格为模式。</p><h2 id="OOA-OOD-OOP">OOA/OOD/OOP</h2><p><img lazyload src="/images/loading.svg" data-src="https://imgss.s3.bitiful.net/2024/06/23/image-20240620232511155.png" alt="image-20240620232511155"></p><p>OOA、OOD和OOP是面向对象开发的三个关键步骤。</p><ol><li><strong>面向对象分析（OOA）</strong>：这是软件开发过程中的第一步，主要目标是理解问题域，并确定软件需要完成的功能。在OOA过程中，分析师会识别出问题域中的关键对象（或称为实体）、对象的属性以及对象之间的关系和交互。结果通常以<u><strong>用例模型，领域模型等</strong></u>表示</li><li><strong>面向对象设计（OOD）</strong>：在完成OOA之后，接下来就是OOD，也就是确定如何实现这些功能。设计师会考虑如何将分析阶段识别出的对象映射到具体的软件组件，并设计这些组件的内部结构，以及组件之间的交互。设计师还需要考虑非功能性需求，如性能、可用性、安全性等。结果通常以<u><strong>类图、状态图、交互图等</strong></u>形式表示。</li><li><strong>面向对象编程（OOP）</strong>：在OOD阶段完成后，接下来就是实现设计的<u><strong>具体代码</strong></u>，这就是OOP阶段。程序员会使用面向对象的编程语言（如Java、C++、Python等）来编写代码，实现设计中定义的类和接口。</li></ol><p>总的来说，OOA、OOD和OOP是面向对象开发的三个关键步骤，它们分别对应于软件开发过程中的<strong>需求分析</strong>、<strong>系统设计</strong>和<strong>编程实现</strong>。这三个步骤是紧密相连的，前一个步骤的输出将作为后一个步骤的输入，从而保证整个开发过程的连贯性和一致性。</p><h2 id="设计模式与类-库框架">设计模式与类/库框架</h2><p><strong>为什么不能建立一个包含所有设计模式的库，让人们不需要自己去创建？</strong></p><ul><li><u><strong>设计模式是比库更高级的概念。</strong></u>设计模式提供了如何结构化类和对象以解决特定问题的指导，但具体实现需要根据具体应用进行调整。<u><strong>设计模式的本质是它们的通用性和灵活性，而不是作为直接可用的代码提供。</strong></u></li></ul><p><strong>库和框架是否也是设计模式？</strong></p><ul><li><u><strong>库和框架本身不是设计模式。</strong></u>它们提供特定的代码实现，可以被直接集成到我们的代码中。<u><strong>然而，库和框架有时会在其实现中使用设计模式，这是有益的</strong></u>，因为一旦你理解了设计模式，就能更快地理解基于设计模式构建的API。</li></ul><h2 id="面向对象设计原则">面向对象设计原则</h2><blockquote><p>设计模式是<mark>设计原则</mark>的体现</p><ol><li>这些原则并不是孤立存在的，它们相互依赖，相互补充。</li><li>原则之间也会有相互的作用</li></ol></blockquote><div class="markdown-alert markdown-alert-important"><p class="markdown-alert-title"><svg class="octicon octicon-report mr-2" viewbox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="M0 1.75C0 .784.784 0 1.75 0h12.5C15.216 0 16 .784 16 1.75v9.5A1.75 1.75 0 0 1 14.25 13H8.06l-2.573 2.573A1.458 1.458 0 0 1 3 14.543V13H1.75A1.75 1.75 0 0 1 0 11.25Zm1.75-.25a.25.25 0 0 0-.25.25v9.5c0 .138.112.25.25.25h2a.75.75 0 0 1 .75.75v2.19l2.72-2.72a.749.749 0 0 1 .53-.22h6.5a.25.25 0 0 0 .25-.25v-9.5a.25.25 0 0 0-.25-.25Zm7 2.25v2.5a.75.75 0 0 1-1.5 0v-2.5a.75.75 0 0 1 1.5 0ZM9 9a1 1 0 1 1-2 0 1 1 0 0 1 2 0Z"/></svg>Important</p><p></p><p><strong>设计原则</strong></p><ol><li>目标：<u>开闭原则</u></li><li>指导：<u>最小知识原则</u></li><li>基础：<u>单一职责原则</u>、可变性封装原则（对OCP的具体描述）</li><li>实现：<u>依赖倒转原则</u>、<u>合成复用原则</u>、<u>里氏代换原则</u>、<u>接口隔离原则</u></li></ol></div><p><img lazyload src="/images/loading.svg" data-src="https://imgss.s3.bitiful.net/2024/06/23/image-20240621132132392.png" alt="image-20240621132132392"></p><p>面向对象设计原则注重<u><strong>软件的可维护性，可复用性和可扩展性</strong></u></p><h3 id="Single-Responsibility-Principle-SRP">Single Responsibility Principle, SRP</h3><h4 id="定义">定义</h4><p>⼀个对象应该只包含<strong>单⼀的职责</strong>，并且该<strong>职责被完整地封装在⼀个类中</strong></p><p>Every object should have a single responsibility, and that responsibility should be entirely encapsulated by the class.</p><p>从可维护性的角度考虑：对一个类而言，仅有<strong>一个引起它变化的原因</strong></p><p>There should <strong>never be more than one reason for a class to change</strong>.</p><h4 id="分析">分析</h4><p><strong>一个类所承担的职责越多，它被复用的可能性越小</strong></p><p>类的职责主要包括两个方面：</p><ol><li><strong>数据职责</strong>：数据职责通过其属性来体现。</li><li><strong>行为/功能职责</strong>：而行为职责通过其方法来体现。</li></ol><p>单一职责原则是实现<strong>高内聚、低耦合</strong>的指导方针</p><h4 id="实例">实例</h4><p>C/S系统中的 Login类 包含了 数据库连接，显示窗口，查询用户等，违反了SRP，重构（使用分层结构）如下：</p><p><img lazyload src="/images/loading.svg" data-src="https://imgss.s3.bitiful.net/2024/06/23/image-20240621205344048.png" alt="image-20240621205344048"></p><h3 id="Open-Closed-Principle-OCP">Open-Closed Principle, OCP</h3><h4 id="定义-2">定义</h4><p>一个软件实体应当<strong>对扩展开放，对修改关闭</strong>。</p><p>Software entities should be <strong>open for extension</strong>, but <strong>closed for modification</strong>.</p><h4 id="分析-2">分析</h4><ol><li><u><strong>软件实体</strong></u>可以指一个软件模块、一个由多个类组成的局部结构或一个独立的类。</li><li><strong>抽象化</strong>是开闭原则的关键。</li><li>开闭原则还可以通过一个更加具体的&quot;<strong>对可变性封装原则</strong>&quot;来描述，对可变性封装原则(<strong>Principle of Encapsulation of Variation, EVP</strong>)要求找到系统的可变因素并将其封装起来。</li></ol><h4 id="与其他人职责的关系">与其他人职责的关系</h4><ol><li>我们需要知道系统的哪些部分是变化的，<strong>开闭原则也是对单一职责原则的增强。</strong></li><li>而<strong>里氏代换原则</strong>和<strong>依赖倒置原则</strong>都是开闭原则的具体实现。</li></ol><h4 id="实例-2">实例</h4><p>某图形界面系统提供了各种不同形状的按钮，客户端代码可针对这些按钮进行编程，用户可能会改变需求要求使用不同的按钮，原始设计方案上利用<u><strong>抽象化+反射机制</strong></u>改进</p><p><strong>抽象化：设计了AbstractButton</strong></p><p><img lazyload src="/images/loading.svg" data-src="https://imgss.s3.bitiful.net/2024/06/23/image-20240621221506730.png" alt="image-20240621221506730"></p><blockquote><p><a href="https://bblog.031105.xyz/posts/%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/java%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6.html">Java反射机制参考</a></p><p>JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性；这种动态获取信息以及动态调用方法的功能成为反射机制。</p></blockquote><h3 id="Liskov-Substitution-Principle-LSP">Liskov Substitution Principle, LSP</h3><blockquote><p>UML关系，泛化关系=继承关系</p><p>关联和依赖：</p><p>前者通常具有长期性，持有引用，如 <code>Library</code> 和 <code>Book</code> 的关系，一个 <code>Library</code> 持有多个 <code>Book</code>（聚合也是关联的一种）</p><p>后者感觉是运行时会用到，短期性，如 <code>OrderProcessor</code> 和 <code>Order</code> 以及 <code>PaymentProcessor</code> 的关系</p></blockquote><img lazyload src="/images/loading.svg" data-src="https://imgss.s3.bitiful.net/2024/06/23/20200224123104360.png" alt="在这里插入图片描述" style="zoom:50%;"> <h4 id="定义-3">定义</h4><p>定义：所有引用基类（父类）的地方必须能透明地使用其子类的对象</p><p>通俗定义：<strong>在软件中如果能够使用基类对象，那么一定能够使用其子类对象。</strong></p><h4 id="分析-3">分析</h4><p>里氏代换原则是<strong>实现开闭原则</strong>的重要方式之一，由于使用基类对象的地方都可以使用子类对象</p><p>由该原则引出的一条建议：<u><strong>在程序中尽量使用基类类型来对对象进行定义，而在运行时再确定其子类类型，用子类对象来替换父类对象。</strong></u></p><h3 id="Dependence-Inversion-Principle-DIP">Dependence Inversion Principle, DIP</h3><h4 id="定义-4">定义</h4><ol><li><p>高层模块<strong>不应该依赖低层模块</strong>，它们都应该<strong>依赖抽象</strong>。<strong>抽象不应该依赖于细节，细节应该依赖于抽象</strong>。High level modules should not depend upon low level modules, both should depend upon abstractions. Abstractions should not depend upon details, details should depend upon abstractions.</p></li><li><p>【另一种表述】<strong>要针对接口编程，不要针对实现编程。</strong></p></li></ol><h4 id="分析-4">分析</h4><ol><li>简单来说，依赖倒转原则就是指：<ul><li><strong>代码要依赖于抽象的类，而不要依赖于具体的类；</strong></li><li><strong>要针对接口或抽象类编程，而不是针对具体类编程</strong>。</li></ul></li><li>依赖倒转原则的<u>常用实现方式</u>之一是<u><strong>在代码中使用抽象类，而将具体类放在配置文件</strong></u><ul><li>将抽象放进代码，将细节放进元数据</li><li>Put Abstractions in Code, Details in <strong>Metadata</strong></li></ul></li></ol><h4 id="类之间的耦合">类之间的耦合</h4><ol><li><strong>零耦合</strong>关系：最好情况</li><li><strong>具体耦合</strong>关系（比如组合关系）</li><li><strong>抽象耦合</strong>关系：依赖倒转要求至少一端是抽象的</li></ol><div class="markdown-alert markdown-alert-note"><p class="markdown-alert-title"><svg class="octicon octicon-info mr-2" viewbox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="M0 8a8 8 0 1 1 16 0A8 8 0 0 1 0 8Zm8-6.5a6.5 6.5 0 1 0 0 13 6.5 6.5 0 0 0 0-13ZM6.5 7.75A.75.75 0 0 1 7.25 7h1a.75.75 0 0 1 .75.75v2.75h.25a.75.75 0 0 1 0 1.5h-2a.75.75 0 0 1 0-1.5h.25v-2h-.25a.75.75 0 0 1-.75-.75ZM8 6a1 1 0 1 1 0-2 1 1 0 0 1 0 2Z"/></svg>Note</p><p></p><p>在面向对象设计中，**耦合（Coupling）**是描述两个或者多个类之间关系的一个术语。耦合强度的高低直接影响到代码的可维护性和可扩展性。</p><p>a. **零耦合关系：**这是最理想的情况，表示两个类之间没有任何关系，修改一个类不会影响到另一个类。</p><p>b. **具体耦合关系：**这是一种较强的耦合关系，表示一个类依赖于另一个类的具体实现。这种情况下，如果一个类发生了变化，可能会影响到依赖于它的所有类。</p><p>c. **抽象耦合关系：**这是一种较弱的耦合关系，表示一个类依赖于另一个类的抽象（例如，接口或抽象类）。这种情况下，如果抽象没有变化，那么具体的实现可以自由地变化，不会影响到依赖于抽象的类。</p><p>依赖倒转原则（Dependency Inversion Principle）就是要求我们在设计类和类之间的关系时，尽可能地使它们成为<strong>抽象耦合关系</strong>。也就是说，一个类应该依赖于抽象，而不是依赖于具体的实现。这样可以使得代码更加灵活和可扩展，因为抽象的变化通常远小于具体实现的变化。</p></div><h4 id="实例-3">实例</h4><p>由于需求的变化，该系统可能需要增加新的数据源或者新的文件格式，每增加一个新的类型的数据源或者新的类型的文件格式，<strong>客户类MainClass都需要修改源代码，以便使用新的类</strong>，但<strong>违背了开闭原则</strong>。现使用<strong>依赖倒转原则+反射机制</strong>对其进行重构。</p><p><img lazyload src="/images/loading.svg" data-src="https://imgss.s3.bitiful.net/2024/06/23/image-20240621234959863.png" alt="image-20240621234959863"></p><h3 id="Interface-Segregation-Principle-ISP">Interface Segregation Principle, ISP</h3><blockquote><p>组合聚合不一定就产生了具体耦合，比如可以持有抽象引用</p></blockquote><h4 id="定义-5">定义</h4><ol><li><p>客户端<strong>不应该依赖</strong>那些<strong>它不需要的接口</strong>。</p><p>Clients should not be forced to depend upon interfaces that they do not use.</p></li><li><p>另一种：<u><strong>一旦一个接口太大，则需要将它分割成一些更细小的接口，使用该接口的客户端仅需知道与之相关的方法即可。</strong></u><br>Once an interface has gotten too ‘fat’ it needs to be <strong>split into smaller and more specific interfaces</strong> so that any clients of the interface will only know about the methods that pertain to them.</p></li></ol><h4 id="分析-5">分析</h4><ol><li>使用接口隔离原则拆分接口时，首先必须满足<strong>单一职责原则</strong>，将一组相关的操作定义在一个接口中，且在满足高内聚的前提下，接口中的方法越少越好。</li><li>可以在进行系统设计时采用<u><strong>定制服务</strong></u>的方式，即<strong>为不同的客户端提供宽窄不同的接口</strong>，只提供用户需要的行为，而隐藏用户不需要的行为。</li></ol><h4 id="实例-4">实例</h4><p>下图展示了一个拥有多个客户类的系统，在系统中定义了一个巨大的接口（胖接口，fat接口）AbstractService来服务所有的客户类。可以使用接口隔离原则对其进行重构。</p><p><img lazyload src="/images/loading.svg" data-src="https://imgss.s3.bitiful.net/2024/06/23/image-20240622003533028.png" alt="image-20240622003533028"></p><h3 id="Composite-Reuse-Principle-CRP"><strong>Composite Reuse Principle, CRP</strong></h3><p>又称为组合/聚合复用原则(Composition/ Aggregate Reuse Principle,CARP)</p><h4 id="定义-6">定义</h4><p><strong>尽量使用对象组合</strong>，而<strong>不是继承</strong>来达到复用的目的。</p><p>Favor composition of objects over inheritance as a reuse mechanism.</p><h4 id="组合与聚合">组合与聚合</h4><ol><li><u><strong>聚合是弱拥有关系，部分可以脱离整体存在；组合是强拥有关系，同生命周期</strong></u></li><li>聚合是<strong>空心菱形箭头</strong>，组合是<strong>实心菱形箭头</strong></li></ol><blockquote><p>组合：鸟与翅膀。就是关系强；聚合：大雁与雁群。就是关系弱</p></blockquote><h4 id="组合聚合vs继承">组合聚合vs继承</h4><p>简言之：<strong>要尽量使用组合/聚合实现复用，少用慎用继承来实现复用</strong>。</p><p>均是实现复用的方法</p><p>在面向对象设计中，可以通过两种基本方法在不同的环境中复用已有的设计和实现，即通过<strong>组合/聚合关系</strong>或通过<strong>继承</strong>。</p><ol><li>**继承复用：**实现简单，易于扩展。破坏系统的封装性；从基类继承而来的实现是静态的，不可能在运行时发生改变，没有足够的灵活性；只能在有限的环境中使用。（&quot;<strong>白箱</strong>&quot;复用）</li><li><strong>组合/聚合复用：</strong><u>耦合度相对较低</u>，选择性地调用成员对象的操作；可以在运行时动态进行。（&quot;<strong>黑箱</strong>&quot;复用）</li></ol><blockquote><p>继承是强耦合，都&quot;is-a&quot;了还不强？</p></blockquote><h4 id="实例-5">实例</h4><p><img lazyload src="/images/loading.svg" data-src="https://imgss.s3.bitiful.net/2024/06/23/image-20240622111226459.png" alt="image-20240622111226459"></p><blockquote><p>左边的都叫Util还能去继承也是挺…</p><p>左边的问题在于如果来了新的扩展困难，会违反OCP目标</p><p><a class="link" href="https://imgss.s3.bitiful.net/2024/06/22/20240622111827.png">左右设计对比ByGPT <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p></blockquote><h3 id="Law-of-Demeter-LoD">Law of Demeter, LoD</h3><h4 id="定义-7">定义</h4><ol><li><strong>不要和&quot;陌生人&quot;说话</strong>。英文定义为：Don’t talk to strangers.</li><li><strong>只与你的直接朋友通信</strong>。英文定义为：Talk only to your immediate friends.</li><li><strong>每一个软件单位对其他的单位都只有最少的知识，而且局限于那些与本单位密切相关的软件单位</strong>。英文定义为：Each unit should have only limited knowledge about other units: only units “closely” related to the current unit.</li></ol><h4 id="分析-6">分析</h4><p>简单地说，迪米特法则就是指<strong>一个软件实体应当尽可能少的与其他实体发生相互作用</strong>。这样，当一个模块修改时，就会尽量少的影响其他的模块，扩展会相对容易</p><p>在迪米特法则中，对于一个对象，其<strong>朋友</strong>包括以下几类：</p><ol><li>当前对象本身(this)</li><li>以参数形式传入到当前对象方法中的对象</li><li>当前对象的成员对象</li><li>如果当前对象的成员对象是一个集合，那么集合中的元素也都是朋友</li><li>当前对象所创建的对象（比如某个方法是创建了某个对象返回）</li></ol><p>a. 狭义迪米特法则</p><p><strong>如果两个类之间不必彼此直接通信，那么这两个类就不应当发生直接的相互作用</strong>，如果其中的一个类需要调用另一个类的某一个方法的话，可以通过<strong>第三者转发这个调用</strong>。</p><p>优点：可以<strong>降低类之间的耦合（直接关联的数量少了自然低了）</strong>，可以<strong>使一个系统的局部设计简化</strong></p><p>缺点：会在系统中增加大量的小方法并散落在系统的各个角落，会<strong>造成系统的不同模块之间的通信效率降低</strong>，使得系统的不同模块之间不容易协调。</p><p><img lazyload src="/images/loading.svg" data-src="https://imgss.s3.bitiful.net/2024/06/23/1710818748127-ff7d9217-9d37-467c-8166-d2bb29d9393c.webp" alt="img"></p><p>b. 广义迪米特法则</p><p>指<strong>对对象之间的信息流量、流向以及信息的影响的控制</strong>，主要是<strong>对信息隐藏的控制</strong>。</p><blockquote><p>总结：感觉就是狭义的控制的太死了，广义的才算传达一种思想理念</p><p><strong>狭义的迪米特法则</strong>：具体化，限制直接对象交互，强调局部设计和低耦合。</p><p><strong>广义的迪米特法则</strong>：概念化，控制信息流量和隐藏，强调模块独立和系统整体性。</p></blockquote><p>迪米特法则的<u><strong>主要用途在于控制信息的过载</strong></u>：</p><ol><li>在类的划分上，应当<strong>尽量创建松耦合的类</strong></li><li>在类的结构设计上，应当<strong>尽量降低其成员变量和成员函数的访问权限</strong></li><li>在类的设计上，<strong>一个类型应当设计成不变类</strong></li><li>在对其他类的引用上，<strong>一个对象对其他对象的引用应当降到最低</strong></li></ol><blockquote><p>第三条，不变类的状态在创建后不能被修改，这种设计可以帮助减少对象间的复杂依赖。</p></blockquote><h4 id="实例-6">实例</h4><p><img lazyload src="/images/loading.svg" data-src="https://imgss.s3.bitiful.net/2024/06/23/image-20240622114137553.png" alt="image-20240622114137553"></p><h4 id="思考">思考</h4><p>在JDK 中，java.util.Stack是java.util.Vector类的子类，该设计合理吗？若不合理，请分析解释该设计存在的问题。</p><ol><li><strong>违反LSP(里式替换原则)和合成复用CRP</strong><ul><li><strong>行为不一致</strong>：根据LSP，子类对象应该能够替换任何父类出现的地方，而且保证原来的行为不变。然而，Stack的行为（后入先出）与Vector（可以在任何位置插入和删除元素）的行为是不一致的。</li></ul></li><li>更好的方式应该是使用合成复用原则，将让stack “has-a” vector，但也有其他的一些问题</li></ol><h2 id="（不考）表驱动">（不考）表驱动</h2><blockquote><p><a class="link" href="https://cchroot.github.io/2020/05/23/%E8%A1%A8%E9%A9%B1%E5%8A%A8%E6%B3%95/">https://cchroot.github.io/2020/05/23/表驱动法/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p></blockquote><p><strong>简单讲是指用查表的方法获取值。</strong></p><p>表驱动法是一种编程模式 (scheme)，从表里面查找信息而不使用逻辑语句 (if 和 case)。表驱动法的另一个好处是可以<strong>将复杂逻辑从代码中独立出来，以便于单独维护</strong></p><p><img lazyload src="/images/loading.svg" data-src="https://imgss.s3.bitiful.net/2024/06/23/image-20240622123138373.png" alt="image-20240622123138373"></p><h3 id="使用表驱动法的两个问题">使用表驱动法的两个问题</h3><ol><li><p><strong>在表里存放什么信息</strong></p><ul><li>主要存放的是数据，但在一些特殊情况下也存放动作</li></ul></li><li><p><strong>如何快速从表中查询条目</strong></p><ul><li>直接访问 (Direct access)<ul><li>最直观朴素的，使用键值对</li></ul></li><li>索引访问 (Indexed access)<ul><li>间接访问</li><li>对于索引访问表，它适用于这样的情况，假设你经营一家商店，有100种商品，每种商品都有一个 id 号，但很多商品的描述都差不多，所以 只有30条不同的描述，现在的问题是建立商品与商品描述的表，如何建立？还是同上面的直接访问表的做法来一一对应吗？那样描述会扩充到100的，会有70个描述是重复的！如何解决这个问题呢？方法是建立一个100长的索引，然后这些索引指向相应的描述，注意不同的索引可以指向相同的描述，这样就解决了表数据冗余的问题啦。</li><li><img lazyload src="/images/loading.svg" data-src="https://imgss.s3.bitiful.net/2024/06/23/image-20240622124042939.png" alt="image-20240622124042939"></li></ul></li><li>阶梯访问 (Stair-step access)<ul><li>它适用于数据不是一个固定的值，而是一个范围的问题，比如将百分制成绩转成五级分制（我们用的优、良、中、合格、不合格，西方用的 A、B、C、D 和F）</li><li>申请一个 100 长度的表，然后在这个表中填充相应的等级就行了？但这样太浪费空间了，有没有更好的方法？</li><li><img lazyload src="/images/loading.svg" data-src="https://imgss.s3.bitiful.net/2024/06/23/image-20240622124249873.png" alt="image-20240622124249873"></li></ul></li></ul></li></ol><h2 id="设计模式">设计模式</h2><p>设计模式(Design Pattern)是一套<u><strong>被反复使用</strong></u>、<u><strong>多数人知晓的</strong></u>、<u><strong>经过分类编目的</strong></u>、<u><strong>代码设计经验的总结</strong></u></p><p><strong>设计模式的基本要素</strong></p><p>1.模式名称 (Pattern name) 2.问题 (Problem) 3.解决方案 (Solution) 4.效果 (Consequences)</p><p><strong>设计模式的分类</strong></p><ul><li>根据其<mark>目的</mark>(模式是用来做什么的)可分为**创建型(Creational)，结构型(Structural)和行为型(Behavioral)**三种：<ol><li><u><strong>创建型模式</strong></u>主要用于<strong>创建对象。</strong></li><li><u><strong>结构型模式</strong></u>主要用于<strong>处理类或对象的组合。</strong></li><li><u><strong>行为型模式</strong></u>主要用于<strong>描述对类或对象怎样交互和怎样分配职责。</strong></li></ol></li><li>根据<mark>范围</mark>，即模式<mark>主要是用于处理类之间关系还是处理对象之间的关系</mark>，可分为<strong>类模式和对象模式</strong>两种：<ol><li><u><strong>类模式</strong></u>处理类和子类之间的关系，这些关系通过<strong>继承</strong>建立，在编译时刻就被确定下来，是属于静态的。</li><li><u><strong>对象模式</strong></u>处理对象间的关系，这些关系在运行时刻变化，更具动态性。</li></ol></li></ul><p><img lazyload src="/images/loading.svg" data-src="https://imgss.s3.bitiful.net/2024/06/23/image-20240621125730304.png" alt="image-20240621125730304"></p><h3 id="Simple-Factory-Pattern（类模式-创建型模式）">Simple Factory Pattern（类模式+创建型模式）</h3><p>又称为**静态工厂方法(Static Factory Method)**模式</p><blockquote><p>因为<strong>Java一般会提供一个static的方法</strong>，这样就不必实例化工厂对象。</p></blockquote><p>在简单工厂模式中，可以根据参数的不同返回不同类的实例。简单工厂模式专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类。</p><p>工厂角色提供<strong>静态工厂方法</strong>来创建其他类的实例，这样子满足了原则：</p><ol><li>满足LoD。减少了客户端与具体实现类的直接交互。客户端只需知道如何使用工厂方法，而不需要了解具体类的创建细节。这符合迪米特法则的要求，减少了对象之间的耦合度。</li><li>满足SRP。<strong>将对象的创建和使用分离</strong>(创建本质上和使用是强耦合的)，将复杂度降低，<strong>并将变化的部分和不变的部分分离开。</strong></li><li>但是对OCP的支持不太好。内部根据参数用if else返回不同的类，要新增类的话这里就会违反OCP了。也就是说<u>简单工厂模式最大的问题在于<strong>工厂类的职责相对过重</strong>，增加新的产品需要修改工厂类的判断逻辑，这一点<strong>与开闭原则</strong>是相违背的。</u></li></ol><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 简单工厂类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Product <span class="title function_">createProduct</span><span class="params">(String type)</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;ProductA&quot;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ProductA</span>();</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;ProductB&quot;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ProductB</span>();</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Unknown product type&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="示例">示例</h4><p>根据不同的权限等级创建不同等级的用户对象，<strong>不同等级的用户对象拥有不同的操作权限</strong>。现使用简单工厂模式来设计该权限管理模块。</p><p><img lazyload src="/images/loading.svg" data-src="https://imgss.s3.bitiful.net/2024/06/23/1710828678593-8b68d92c-6f5f-4ed0-9daf-87fe3bac2e69.webp" alt="img"></p><blockquote><p>实线三角：继承；虚线箭头：依赖</p></blockquote><h4 id="优点">优点</h4><ol><li>（SRP）工厂类含有必要的判断逻辑，可以决定在什么时候创建哪一个产品类的实例，客户端可以免除直接创建产品对象的责任，而仅仅&quot;消费&quot;产品，从而<strong>实现了对责任的分割，它提供了专门的工厂类用于创建对象。</strong></li><li>（LoD）<strong>客户端无须知道所创建的具体产品类的类名，只需要知道具体产品类所对应的参数即可</strong>，对于一些复杂的类名，通过简单工厂模式可以减少使用者的记忆量。</li><li><strong>通过引入配置文件，可以在不修改任何客户端代码的情况下更换和增加新的具体产品类</strong>，在一定程度上提高了系统的灵活性。</li></ol><h4 id="缺点">缺点</h4><ol><li>由于<strong>工厂类集中了所有产品创建逻辑</strong>，一旦不能正常工作，整个系统都要受到影响（单个职责过大）</li><li><strong>增加了系统中类的个数</strong>，在一定程序上增加了系统的复杂度和理解难度</li><li><strong>系统扩展困难，一旦添加新产品就不得不修改工厂逻辑，在产品类型较多时</strong>。<u><strong>会违背OCP原则</strong></u></li><li><strong>无法形成基于继承的等级结构</strong></li></ol><h4 id="适用场景">适用场景</h4><p>在以下情况下可以使用简单工厂模式：</p><ol><li><strong>工厂类负责创建的对象比较少</strong>：由于创建的对象较少，不会造成工厂方法中的业务逻辑<strong>太过复杂</strong>(如果扩展使比较少的)</li><li><strong>客户端只知道传入工厂类的参数，对于如何创建对象不关心</strong>：客户端既不需要关心创建细节，甚至连类名都不需要记住，只需要知道类型所对应的参数(比如只知道名称参数)</li></ol><h4 id="模式应用">模式应用</h4><ol><li><p>在JDK类库中广泛使用了<strong>简单工厂模式</strong>，如工具类java.text.DateFormat，它用于格式化一个本地日期或者时间。</p><p><img lazyload src="/images/loading.svg" data-src="https://imgss.s3.bitiful.net/2024/06/23/1711367623310-1d574e0a-dd9e-4b71-b895-d734f6ffae10-1719039264661-18.webp" alt="image.png"></p></li><li><p>Java加密技术：对称加密和非对称加密，但是变化比较少</p><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Cipher</span> <span class="variable">encryptCipher</span> <span class="operator">=</span> Cipher.getInstance(<span class="string">&quot;RSA&quot;</span>);</span><br></pre></td></tr></table></figure></div></li></ol><h4 id="模式扩展">模式扩展</h4><p>**简单工厂模式的简化：**在有些情况下工厂类可以由抽象产品角色扮演，一个抽象产品类同时也是子类的工厂，也就是说把静态工厂方法写到抽象产品类中。</p><p><img lazyload src="/images/loading.svg" data-src="https://imgss.s3.bitiful.net/2024/06/23/1710828678238-85eb779e-203f-4987-b0f1-a0a92c0097b8.webp" alt="img"></p><h3 id="Factory-Method-Pattern（类模式-创建型模式）">Factory Method Pattern（类模式+创建型模式）</h3><p>工厂方法模式(Factory Method Pattern)又称为工厂模式，也叫<strong>虚拟构造器(Virtual Constructor)模式或者多态工厂(Polymorphic Factory)模式</strong>，它属于<strong>类创建型模式</strong>。</p><p><u><strong>延迟</strong></u></p><ol><li>在工厂方法模式中，<strong>工厂父类</strong>负责定义创建产品对象的公共接口，而<strong>工厂子类</strong>则负责生成具体的产品对象，<u>这样做的目的是将产品类的实例化操作延迟到工厂子类中完成，即通过工厂子类来确定究竟应该实例化哪一个具体产品类。</u></li><li>工厂方法是以<strong>继承方法</strong>为主，工厂子类是<strong>继承工厂父类</strong>的。</li></ol><p><img lazyload src="/images/loading.svg" data-src="https://imgss.s3.bitiful.net/2024/06/23/1710828678747-e44bf3de-d5b0-4d7d-90a4-d41ec4d56a65.webp" alt="img"></p><p>工厂方法模式保持了简单工厂模式的优点，而且克服了它的缺点。<strong>在工厂方法模式中，核心的工厂类不再负责所有产品的创建，而是将具体创建工作交给子类去做</strong>。这个核心类仅仅负责给出具体工厂必须实现的接口，而不负责哪一个产品类被实例化这种细节，这使得<strong>工厂方法模式可以允许系统在不修改工厂角色的情况下引进新产品</strong>。</p><p>很好的符合了OCP</p><h4 id="示例-2">示例</h4><p><img lazyload src="/images/loading.svg" data-src="https://imgss.s3.bitiful.net/2024/06/23/1710828678838-05794b8e-9891-4989-be17-50d3f1033087.webp" alt="img"></p><h4 id="优点-2">优点</h4><blockquote><p>用户无需关心创建细节；工厂自主确定，封装细节在具体工厂；易加入新产品</p></blockquote><ol><li><strong>用户</strong>只需要关心所需产品对应的工厂，无须关心创建细节</li><li><strong>工厂可以自主</strong>确定创建何种产品对象，而如何创建这个<strong>对象的细节则完全封装</strong>在具体工厂内部。</li><li><strong>在系统中加入新产品</strong>时，无须修改抽象工厂和抽象产品提供的接口，无须修改客户端，也无须修改其他的具体工厂和具体产品，而只要添加一个具体工厂和具体产品就可以了。</li></ol><h4 id="缺点-2">缺点</h4><blockquote><p>类太多了，并且看起来很复杂</p></blockquote><ol><li>在添加新产品时，<strong>需要编写新的具体产品类，而且还要提供与之对应的具体工厂类，系统中类的个数将成对增加，在一定程度上增加了系统的复杂度</strong>，有更多的类需要编译和运行，会给系统带来一些额外的开销。</li><li>由于考虑到系统的可扩展性，需要引入抽象层，在客户端代码中均使用抽象层进行定义，<strong>增加了系统的抽象性和理解难度</strong>，且在实现时可能需要用到DOM、反射等技术，增加了系统的实现难度。</li></ol><h4 id="适用场景（感觉不重要">适用场景（感觉不重要</h4><ol><li><strong>一个类不知道它所需要的对象的类</strong></li><li><strong>一个类通过其子类来指定创建哪个对象</strong></li><li><strong>将创建对象的任务委托给多个工厂子类中的某一个，客户端在使用时可以无须关心是哪一个工厂子类创建产品子类，需要时再动态指定</strong></li><li>希望能够<strong>推迟创建</strong>的时候</li></ol><h3 id="Abstract-Factory-Pattern（对象模式-创建型模式）">Abstract Factory Pattern（对象模式+创建型模式）</h3><p>有时候<strong>我们需要一个工厂可以提供多个产品对象，而不是单一的产品对象</strong>。</p><p>两个概念：</p><ol><li><strong>产品等级结构</strong>：不同品牌的同一产品<ul><li>如一个抽象类是电视机，其子类有海尔电视机、海信电视机、TCL电视机，<strong>则抽象电视机与具体品牌的电视机之间构成了一个产品等级结构</strong></li></ul></li><li><strong>产品族</strong>：同一品牌的不同产品。<ul><li>海尔电视机位于电视机产品等级结构中，海尔电冰箱位于电冰箱产品等级结构中。</li></ul></li></ol><p>区分：</p><p><u><strong>工厂方法模式针对的是一个产品等级结构，而抽象工厂模式则需要面对多个产品等级结构</strong></u></p><p><img lazyload src="/images/loading.svg" data-src="https://imgss.s3.bitiful.net/2024/06/23/image-20240622153307169.png" alt="image-20240622153307169"></p><p>如上图，抽象工厂模式包含如下角色：</p><ol><li>AbstractFactory：抽象工厂</li><li>ConcreteFactory：具体工厂</li><li>AbstractProduct：抽象产品</li><li>Product：具体产品</li></ol><h4 id="示例-3">示例</h4><p><strong>数据库操作工厂。<strong>某系统为了改进数据库操作的性能，自定义数据库连接对象Connection和语句对象Statement，可针对</strong>不同类型的数据库</strong>提供<strong>不同的连接对象和语句对象</strong>，如提供Oracle或SQL Server专用连接类和语句类，而且用户可以通过配置文件等方式根据实际需要动态更换系统数据库。</p><p><img lazyload src="/images/loading.svg" data-src="https://imgss.s3.bitiful.net/2024/06/23/1710828679540-a80fa4df-0172-474d-aea0-27e54f97aba0.webp" alt="img"></p><h4 id="优点-3">优点</h4><ol><li><strong>隔离了具体类的生成</strong>，所有的具体工厂都实现了抽象工厂中定义的那些公共接口，因此<strong>只需改变具体工厂的实例，就可以在某种程度上改变整个软件系统的行为</strong>。实现了高内聚低耦合</li><li><strong>能够保证客户端始终只使用同一个产品族中的对象</strong>（具体工厂是不同的牌子）</li><li><strong>增加新的具体工厂和产品族很方便，无须修改已有系统，符合OCP</strong></li></ol><h4 id="缺点-3">缺点</h4><p>在添加新的产品对象时，<strong>难以扩展抽象工厂来生产新种类的产品</strong>，这是因为在抽象工厂角色中规定了所有可能被创建的产品集合，要支持新种类的产品就意味着要对该接口进行扩展，而这将涉及到对抽象工厂角色及其所有子类的修改，显然会带来较大的不便。</p><p>开闭原则的倾斜性体现在此：<strong>增加新的工厂和产品族容易，增加新的产品等级结构麻烦</strong></p><blockquote><p>加一个新的品牌很方便，但是新的产品（产品等级结构），比如品牌123都生产ABC，加一个品牌4也生产123很简单，但是想加一个生产D，就比较麻烦了，会违反OCP</p></blockquote><h4 id="适用场景-2">适用场景</h4><ol><li>一个系统<strong>不应当依赖于产品类实例如何被创建、组合和表达的细节</strong>，这对于所有类型的工厂模式都是重要的。</li><li>系统中有<strong>多于一个的产品族，而每次只使用其中某一产品族。</strong>（对应优点2）并且<strong>属于同一个产品族的产品将在一起使用</strong>，这一约束必须在系统的设计中体现出来。</li><li><strong>所有的产品以同样的接口出现</strong>，从而<strong>使客户端不依赖于具体实现</strong>。</li></ol><h4 id="模式扩展-2">模式扩展</h4><p>工厂模式的退化</p><p>抽象工厂 -》工厂方法 -》简单工厂</p><p>牌子123生产ABC（抽象工厂模式）-&gt;只有一个产品等级结构，如只生产A（工厂方法模式）-&gt;抽象工厂合并到具体工厂，只用一个具体工厂（简单工厂模式</p><h3 id="（不考）Builder-Pattern（对象模式-创建型模式）">（不考）Builder Pattern（对象模式+创建型模式）</h3><p><strong>生成器模式</strong>是一种创建型设计模式， 使你能够分步骤创建复杂对象。 该模式允许你使用相同的创建代码生成不同类型和形式的对象。</p><p>复用相同的对象构造代码</p><p>将<strong>一个复杂对象的构建与它的表示分离</strong>，使得<strong>同样的构建过程可以创建不同的表示</strong>。</p><p><img lazyload src="/images/loading.svg" data-src="https://imgss.s3.bitiful.net/2024/06/23/2.png" alt="img"></p><p>组装汽车、KFC套餐</p><p><img lazyload src="/images/loading.svg" data-src="https://imgss.s3.bitiful.net/2024/06/23/example-zh.png" alt="生成器模式结构示例"></p><h3 id="Prototype-Pattern（对象模式-创建型模式）">Prototype Pattern（对象模式+创建型模式）</h3><blockquote><p>原型模式将克隆过程委派给被克隆的实际对象。 模式为所有支持克隆的对象声明了一个通用接口， 该接口让你能够克隆对象， 同时又无需将代码和对象所属类耦合。 通常情况下， 这样的接口中仅包含一个 <code>克隆</code>方法。</p></blockquote><p>在软件系统中，有些对象的创建过程较为复杂，而且有时候需要频繁创建，<strong>原型模式</strong>通过<strong>给出一个原型对象来指明所要创建的对象的类型</strong>，然后<strong>通过复制</strong>这个原型对象的办法<strong>创建出更多同类型的对象</strong>，这就是原型模式的意图所在。</p><p><img lazyload src="/images/loading.svg" data-src="https://imgss.s3.bitiful.net/2024/06/23/4.png" alt="img"></p><blockquote><p>+表示public，-表示private</p></blockquote><ol><li>抽象原型类是定义具有克隆自己的方法的接口（比如java中就是Object）</li><li><strong>具体原型类实现具体的克隆方法</strong>，在克隆方法中返回自己的一个克隆对象</li></ol><p>java.lang.Object | Cloneable接口</p><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrototypeDemo</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">clone</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            object = <span class="built_in">super</span>.clone();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException exception) &#123;</span><br><span class="line">            System.err.println(<span class="string">&quot;Not support cloneable&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> object;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><blockquote><p>Java语言提供的clone()方法将对象复制了一份并返回给调用者。一般而言，clone()方法满足:</p><ol><li>对任何的对象x，都有x.clone() !=x，<strong>即克隆对象与原对象不是同一个对象。</strong></li><li>对任何的对象x，都有x.clone().getClass()==x.getClass()，即克隆对象与原对象的类型一样。</li><li>如果对象x的equals()方法定义恰当，那么x.clone().equals(x)应该成立。</li></ol></blockquote><p><strong>深克隆和浅克隆</strong></p><p><strong>浅克隆</strong>：只克隆对象本身，成员对象的引用保持不变。适用于成员对象不需要独立变化的情况。</p><p><strong>深克隆</strong>：克隆对象及其所有成员对象。适用于需要完全独立的克隆对象的情况。</p><p><strong>java中的clone()方法是浅克隆</strong></p><p>在 Java 中，<code>Object</code> 类提供了一个 <code>clone()</code> 方法，这个方法默认实现的是<strong>浅克隆（Shallow Clone）</strong>。浅克隆的含义是，当一个对象被克隆时，只复制对象本身，而不复制对象包含的引用类型成员对象。<strong>即，克隆对象和原对象共享同一个引用类型成员对象。</strong></p><h4 id="示例-4">示例</h4><p>由于邮件对象包含的内容较多（如发送者、接收者、标题、内容、日期、附件等），某系统中现需要<strong>提供一个邮件复制功能</strong>，对于已经创建好的邮件对象，<strong>可以通过复制的方式创建一个新的邮件对象，如果需要改变某部分内容，无须修改原始的邮件对象，<strong>只需要修改复制后得到的邮件对象即可。在本实例中使用</strong>浅克隆</strong>实现邮件复制，即复制邮件(Email)的同时不复制附件(Attachment)。</p><p><img lazyload src="/images/loading.svg" data-src="https://imgss.s3.bitiful.net/2024/06/23/1710828856419-400b1a13-e8fe-43c0-9ad8-174e21fbceab.webp" alt="img"></p><h4 id="优点-4">优点</h4><ol><li><strong>简化</strong>对象的创建过程</li><li>可以<strong>动态增加或减少产品类</strong></li><li>可以使用深克隆的方式<strong>保存</strong>对象的状态。</li></ol><h4 id="缺点-4">缺点</h4><ol><li>需要为每一个类配备一个克隆方法，<strong>而且这个克隆方法需要对类的功能进行通盘考虑</strong>，这对全新的类来说不是很难，但对已有的类进行改造时，不一定是件容易的事，必须修改其源代码，<strong>违背了OCP</strong></li><li>在实现深克隆时<strong>需要编写较为复杂的代码</strong></li></ol><h4 id="适用场景-3">适用场景</h4><ol><li><p><strong>创建新对象成本较大</strong></p></li><li><p>如果<strong>系统要保存对象的状态</strong>，而对象的状态变化很小，或者对象本身占内存不大的时候</p></li><li><p>需要<strong>避免使用分层次的工厂类来创建分层次的对象</strong>，并且类的实例对象只有一个或很少的几个组合状态</p><blockquote><p>比如按钮有开关状态，犯不着用工厂类，直接复制一个改下状态就行</p></blockquote></li></ol><h4 id="模式扩展-3">模式扩展</h4><p>带原型管理器的原型模式</p><p><img lazyload src="/images/loading.svg" data-src="https://imgss.s3.bitiful.net/2024/06/23/1710828857053-4f673b9b-c4a7-4bc6-8def-d3f3933ab115.webp" alt="img"></p><p>就是用一个hashtable来存取管理下</p><h3 id="（不考）Singleton-Pattern（对象模式-创建型模式）">（不考）Singleton Pattern（对象模式+创建型模式）</h3><p><strong>单例模式</strong>是一种创建型设计模式， 让你能够保证一个类只有一个实例， 并提供一个访问该实例的全局节点。</p><h3 id="Adapter-Pattern（类-对象模式-结构型模式）">Adapter Pattern（类/对象模式+结构型模式）</h3><blockquote><p><a class="link" href="https://refactoringguru.cn/design-patterns/adapter">https://refactoringguru.cn/design-patterns/adapter <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a><br>这里的两张图很清晰</p></blockquote><p><strong>将一个接口转换成客户希望的另一个接口</strong>，适配器模式使<strong>接口不兼容的那些类可以一起工作</strong>，其别名为<strong>包装器(Wrapper)</strong>。适配器模式既可以作为<u>类结构型模式</u>，也可以作为<u>对象结构型模式</u>。</p><p>对象适配器</p><img lazyload src="/images/loading.svg" data-src="https://imgss.s3.bitiful.net/2024/06/23/1712646835467-4a35969f-9df0-4274-9047-8b9578d5fadb.png" alt="img" style="zoom: 33%;"> <blockquote><p>Target可以抽象或者具体</p></blockquote><p>类适配器</p><img lazyload src="/images/loading.svg" data-src="https://imgss.s3.bitiful.net/2024/06/23/1712646835505-374cdc08-cdd2-48f0-8649-7d615a0a3433.png" alt="img" style="zoom:33%;"> <blockquote><p>Target只能抽象</p></blockquote><ul><li>Target 目标抽象类</li><li>Adapter 适配器类</li><li>Adaptee 适配者类</li><li>Client 客户类</li></ul><h4 id="对象适配器">对象适配器</h4><p>适配器实现了其中一个对象的接口， 并对另一个对象进行封装。</p><p><img lazyload src="/images/loading.svg" data-src="https://imgss.s3.bitiful.net/2024/06/23/image-20240622170211690.png" alt="image-20240622170211690"></p><h4 id="类适配器">类适配器</h4><p>适配器同时继承两个对象的接口。 请注意， 这种方式仅能在支持<strong>多重继承</strong>的编程语言中实现， 例如 C++</p><p><img lazyload src="/images/loading.svg" data-src="https://imgss.s3.bitiful.net/2024/06/23/image-20240622170229492.png" alt="image-20240622170229492"></p><ol><li>典型的类适配器代码：</li></ol><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Adapter</span> <span class="keyword">extends</span> <span class="title class_">Adaptee</span> <span class="keyword">implements</span> <span class="title class_">Target</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">request</span><span class="params">()</span>&#123;</span><br><span class="line">        specificRequest();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><ol><li>典型的对象适配器代码：</li></ol><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Adapter</span> <span class="keyword">extends</span> <span class="title class_">Target</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Adaptee adaptee;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Adapter</span><span class="params">(Adaptee adaptee)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.adaptee=adaptee;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">request</span><span class="params">()</span>&#123;</span><br><span class="line">        adaptee.specificRequest();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="示例-5">示例</h4><p><strong>仿生机器人</strong>。现需要设计一个可以模拟各种动物行为的机器人，在机器人中定义了一系列方法，如机器人叫喊方法cry()、机器人移动方法move()等。如果希望在不修改已有代码的基础上使得机器人能够像狗一样叫，像狗一样跑，使用适配器模式进行系统设计。</p><img lazyload src="/images/loading.svg" data-src="https://imgss.s3.bitiful.net/2024/06/23/1712646835522-761c73f5-626e-44fa-98fa-7cdfeb32f489.webp" alt="img" style="zoom:50%;"> <blockquote><p>类适配器，适配器的方法对应Target的方法</p></blockquote><p><strong>加密适配器</strong>。某系统需要提供一个加密模块，将用户信息（如密码等机密信息）加密之后再存储在数据库中，系统已经定义好了数据库操作类。为了提高开发效率，现需要重用已有的加密算法，这些算法封装在一些由第三方提供的类中，有些甚至没有源代码。使用适配器模式设计该加密模块，实现在不修改现有类的基础上重用第三方加密方法。</p><img lazyload src="/images/loading.svg" data-src="https://imgss.s3.bitiful.net/2024/06/23/1712646835454-6bd3cefc-0f4c-4f2e-8d10-4f3b727a31a0.webp" alt="img" style="zoom: 33%;"> <blockquote><p>对象适配器，与Caesar是组合关系</p></blockquote><h4 id="优点-5">优点</h4><ol><li><strong>将目标类和适配者类解耦</strong>，通过引入一个适配器类来重用现有的适配者类，而无须修改原有代码。</li><li><strong>增加了类的透明性和复用性</strong>，将具体的实现封装在适配者类中，对于客户端类来说是透明的，而且提高了适配者的复用性。</li><li><strong>灵活性和扩展性都非常好</strong>，通过使用配置文件，可以很方便地更换适配器，也可以在不修改原有代码的基础上增加新的适配器类，完全符合&quot;开闭原则&quot;。</li></ol><h5 id="类适配器的优缺点">类适配器的优缺点</h5><p>优点：由于Adapter是Adaptee的子类，因此<strong>可以在适配器类中置换一些适配者的方法，使得适配器的灵活性更强</strong>。</p><p>缺点：对于Java、C#等不支持多重继承的语言，一次最多只能适配一个适配者类，而且目标抽象类只能为抽象类，不能为具体类，<strong>其使用有一定的局限性</strong>，不能将一个适配者类和它的子类都适配到目标接口。</p><h5 id="对象适配器模式">对象适配器模式</h5><p>优点：<strong>同一个适配器可以把适配者类和它的子类都适配到目标接口</strong>（因为是用的组合，而不是继承</p><p>缺点：<strong>想要置换适配者类的方法不容易</strong>（因为不是继承，只是关联/组合/聚合这样，继承的话可以重新实现方法之类的</p><h4 id="适用场景-4">适用场景</h4><p>在以下情况下可以使用适配器模式：</p><ol><li>系统<strong>需要使用现有的类</strong>，而这些类的接口不符合系统的需要。</li><li><strong>想要建立一个可以重复使用的类，用于与一些彼此之间没有太大关联的一些类</strong>，包括一些可能在将来引进的类<strong>一起工作</strong>。</li></ol><h4 id="模式应用-2">模式应用</h4><p><strong>每一个具体数据库引擎</strong>（如SQL Server、Oracle、MySQL等）<strong>的JDBC驱动软件都是一个介于JDBC接口和数据库引擎接口之间的适配器软件</strong>。</p><h4 id="模式扩展-4">模式扩展</h4><p><strong>默认适配器模式</strong>（Default Adapter Pattern）或缺省适配器模式</p><p>当不需要全部实现接口提供的方法时，可以设计一个适配器抽象类实现接口，并为接口中的每个方法提供默认方法，抽象类的子类就可以有选择的覆盖父类的某些方法实现需求，它适用于一个接口不想使用所有的方法的情况。**在java8后，接口中可以有default方法，就不需要这种缺省适配器模式了。**接口中方法都设置为default，实现为空，这样同样可以达到缺省适配器模式同样的效果。</p><blockquote><p>就是给接口先搞一个抽象类，弄点默认方法，然后子类可以有选择地去覆盖，其他的方法保持默认，因为java8之前接口类还没有default关键字，现在没啥用了这个</p></blockquote><img lazyload src="/images/loading.svg" data-src="https://imgss.s3.bitiful.net/2024/06/23/1712646836335-cefe80a7-fdc4-4b0a-bbb0-acfa78ef7d46.webp" alt="img" style="zoom:50%;"> <p><strong>双向适配器</strong>（bidirectional adapter）</p><blockquote><p>作为Target和Adaptee之间的互调工具人</p></blockquote><p>在对象适配器的使用过程中，如果<strong>在适配器中同时包含对目标类和适配者类的引用，适配者可以通过它调用目标类中的方法，目标类也可以通过它调用适配者类中的方法</strong>，那么该适配器就是一个<strong>双向适配器</strong>。</p><img lazyload src="/images/loading.svg" data-src="https://imgss.s3.bitiful.net/2024/06/23/1712646836590-78b79def-3d93-4250-bb70-91e02c66a13a.png" alt="img" style="zoom: 33%;"> <h3 id="Composite-Pattern（对象模式-结构型模式）">Composite Pattern（对象模式+结构型模式）</h3><blockquote><p>由于容器对象和叶子对象在功能上的区别，在使用这些对象的客户端代码中必须<strong>有区别地对待容器对象和叶子对象</strong>，而实际上<strong>大多数情况下客户端希望一致地处理它们，因为对于这些对象的区别对待将会使得程序非常复杂</strong>。</p></blockquote><p>组合模式又可以称为<strong>整体-部分(Part-Whole)模式</strong></p><p>组合多个对象形成<strong>树形结构</strong>以<strong>表示&quot;整体-部分&quot;的结构层次</strong>。组合模式对<strong>单个对象（即叶子对象）<strong>和</strong>组合对象（即容器对象）<strong>的</strong>使用具有一致性</strong>。</p><p>组合模式包含如下角色：</p><ol><li>Component: 抽象构件</li><li>Leaf: 叶子构件</li><li>Composite: 容器构件</li><li>Client: 客户类</li></ol><img lazyload src="/images/loading.svg" data-src="https://imgss.s3.bitiful.net/2024/06/23/1712646836574-891e05aa-4c89-46fe-b067-db8a15a17ffc.webp" alt="img" style="zoom:50%;"> <blockquote><p>右边的聚合关系意思就是，容器内可以有多个Component（Leaf或者Composite）</p></blockquote><p>组合模式的<u><strong>关键</strong></u>是<u><strong>定义了一个抽象构件类</strong></u>，它既可以代表叶子，又可以代表容器，而<strong>客户端针对该抽象构件类进行编程</strong>，无须知道它到底表示的是叶子还是容器，可以对其进行统一处理。</p><p>同时<u><strong>容器对象与抽象构件类之间还建立一个聚合关联关系</strong></u>，在容器对象中既可以包含叶子，也可以包含容器，以此<strong>实现递归组合，形成一个树形结构</strong>。</p><h4 id="示例-6">示例</h4><img lazyload src="/images/loading.svg" data-src="https://imgss.s3.bitiful.net/2024/06/23/1712646836756-945603ce-365a-465c-b58e-62be8da3033d.webp" alt="img" style="zoom:50%;"> <p><strong>水果盘</strong>。在水果盘(Plate)中有一些水果，如苹果(Apple)、香蕉(Banana)、梨子(Pear)，当然大水果盘中还可以有小水果盘，现需要对盘中的水果进行遍历（吃），当然如果对一个水果盘执行&quot;吃&quot;方法，实际上就是吃其中的水果。使用组合模式模拟该场景。</p> <img lazyload src="/images/loading.svg" data-src="https://imgss.s3.bitiful.net/2024/06/23/1712646836980-eb2f9070-5c80-423f-aee2-0f9f8f831a28.webp" alt="img" style="zoom:50%;"><h4 id="优点-6">优点</h4><ol><li>可以清楚地定义<strong>分层次的复杂对象</strong>，表示对象的全部或部分层次，使得增加新构件也更容易。</li><li>客户端可以<strong>一致的使用组合结构或其中单个对象</strong></li><li>定义了包含叶子对象和容器对象的<strong>类层次结构</strong>，可以形成<strong>复杂的树形结构</strong>。</li><li><strong>更容易在组合体内加入对象构件</strong>，客户端不必因为加入了新的对象构件而更改原有代码。（继承下就行，反正容器放的是抽象构件对象</li></ol><h4 id="缺点-5">缺点</h4><ol><li><strong>使设计变得更加抽象</strong>，对象的业务规则如果很复杂，则实现组合模式具有很大挑战性，<u><strong>而且不是所有的方法都与叶子对象子类都有关联。</strong></u></li><li>增加新构件时可能会产生一些问题，<strong>很难对容器中的构件类型进行限制</strong>。</li></ol><h4 id="模式应用-3">模式应用</h4><p>XML文档解析 | <strong>操作系统中的目录结构</strong> | JDK的<strong>AWT/Swing</strong></p><blockquote><p>JDK的<strong>AWT/Swing</strong>有Component，Container之类的</p></blockquote><h4 id="模式扩展-5">模式扩展</h4><p>更复杂的组合模式</p><img lazyload src="/images/loading.svg" data-src="https://imgss.s3.bitiful.net/2024/06/23/1712646837561-23f6c72e-788a-48e1-a1af-764115da3eca.png" alt="img" style="zoom: 33%;"> <p>组合模式<strong>根据抽象构件类的定义形式</strong>，又可以分为透明组合模式和安全组合模式。</p><p><strong>透明组合模式</strong>（其实就是普通组合模式？</p><img lazyload src="/images/loading.svg" data-src="https://imgss.s3.bitiful.net/2024/06/23/1712646837539-17003bd1-0cb6-478b-a319-beb78e0287cb.webp" alt="img" style="zoom:33%;"> <p>统一了叶子节点和组合节点的接口</p><blockquote><p><strong>优点</strong>：简化客户端代码，因为它对待叶子节点和组合节点无需区分。</p><p><strong>缺点</strong>：叶子节点包含了一些本不应支持的操作，例如添加或删除子节点，这违反了设计的最小知识原则，即一个类不应该包含它不使用的方法。</p></blockquote><p><strong>安全组合模式：违反了里氏代换原则</strong></p><img lazyload src="/images/loading.svg" data-src="https://imgss.s3.bitiful.net/2024/06/23/1712646837869-883071bd-79f2-4105-a5c4-2c8886ec536d.webp" alt="img" style="zoom:33%;"> <p>Component只放共有的operation操作</p><p>安全性高，一个类不接触它不需要的接口。</p><h3 id="Decorator-Pattern（对象模式-结构型模式）">Decorator Pattern（对象模式+结构型模式）</h3><p>装饰模式以<strong>对客户透明的方式动态地给一个对象附加上更多的责任</strong>，换言之，客户端并不会觉得对象在装饰前和装饰后有什么不同。装饰模式可以在<strong>不需要创造更多子类的情况下，将对象的功能加以扩展</strong>。这就是装饰模式的模式动机。</p><p><strong>动态地给一个对象增加一些额外的职责</strong>(Responsibility)，其别名也可以称为<strong>包装器</strong>(Wrapper)，与适配器模式的别名相同，但它们适用于不同的场合。</p><p>装饰模式也有人翻译为&quot;油漆工模式&quot;，它是一种<strong>对象结构型模式</strong>。</p><img lazyload src="/images/loading.svg" data-src="https://imgss.s3.bitiful.net/2024/06/23/1712802180958-16b938cc-80e7-490f-88dc-e122496a321e.webp" alt="img" style="zoom:50%;"> <p>递归构建，上面部分很像组合模式（容器+叶子）。<strong>ConcreteComponent和Decorator只有能不能继续装饰的区别，是一种终止条件，其实没有本质区分。</strong></p><p>装饰模式包含如下角色：</p><ol><li>Component: 抽象构件</li><li><strong>ConcreteComponent: 具体构件</strong></li><li>Decorator: 抽象装饰类</li><li><strong>ConcreteDecorator: 具体装饰类</strong></li></ol><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Decorator</span> <span class="keyword">extends</span> <span class="title class_">Component</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">private</span> Component component;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Decorator</span><span class="params">(Component component)</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">this</span>.component=component;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operation</span><span class="params">()</span></span><br><span class="line">   &#123;</span><br><span class="line">   component.operation();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteDecorator</span> <span class="keyword">extends</span> <span class="title class_">Decorator</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">ConcreteDecorator</span><span class="params">(Component component)</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">super</span>(component);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operation</span><span class="params">()</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">super</span>.operation();</span><br><span class="line">    addedBehavior();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addedBehavior</span><span class="params">()</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">//新增方法</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><blockquote><p>其实感觉就是包了一层，持有了component，所以叫wrapper也合理</p></blockquote><h4 id="示例-7">示例</h4><p><strong>变形金刚。</strong><u><strong>变形金刚在变形之前是一辆汽车，它可以在陆地上移动</strong></u>。当它变成机器人之后除了能够在陆地上移动之外，还可以说话；如果需要，它还可以变成飞机，除了在陆地上移动还可以在天空中飞翔。</p><img lazyload src="/images/loading.svg" data-src="https://imgss.s3.bitiful.net/2024/06/23/1712802180962-6ff050fc-8b56-492b-8215-483bd58b2186.webp" alt="img" style="zoom:50%;"> <blockquote><p>变成Robot</p><p>Transform car = new Car()</p><p>Transform robot = new Robot(car)</p></blockquote><p><strong>多重加密系统</strong>。某系统提供了一个数据加密功能，可以对字符串进行加密。最简单的加密算法通过对字母进行移位来实现，同时还提供了稍复杂的逆向输出加密，还提供了更为高级的求模加密。用户先使用最简单的加密算法对字符串进行加密，如果觉得还不够可以对加密之后的结果使用其他加密算法进行二次加密，当然也可以进行第三次加密。现使用装饰模式设计该多重加密系统。</p><img lazyload src="/images/loading.svg" data-src="https://imgss.s3.bitiful.net/2024/06/23/1712802181281-852c4348-6ed4-4edd-901c-a16ca63cb2e8.webp" alt="img" style="zoom:50%;"> <h4 id="优点-7">优点</h4><ol><li>装饰模式可以<strong>提供比继承更多的灵活性</strong></li><li><strong>通过一种动态的方式来扩展一个对象的功能</strong></li><li>排列组合可以创造很多不同行为的组合</li><li><strong>具体构件类与具体装饰类可以独立变化，符合“开闭原则”</strong></li></ol><h4 id="缺点-6">缺点</h4><ol><li>产生小对象，系统复杂</li><li>易出错，难排错</li></ol><h4 id="模式扩展-6">模式扩展</h4><p><strong>如果只有一个具体构件类而没有抽象构件类，那么抽象装饰类可以作为具体构件类的直接子类</strong>。</p><p>可以简化如右图</p><p><img lazyload src="/images/loading.svg" data-src="https://imgss.s3.bitiful.net/2024/06/23/image-20240622212238300.png" alt="image-20240622212238300"></p><p><strong>透明</strong>装饰模式（多重加密系统）</p><p>在透明装饰模式中，要求<strong>客户端完全针对抽象编程</strong>，装饰模式的透明性要求客户端程序不应该声明具体构件类型和具体装饰类型，而应该全部声明为抽象构件类型。</p><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Cipher sc,cc,ac; </span><br><span class="line">sc=<span class="keyword">new</span> <span class="title class_">SimpleCipher</span>(); </span><br><span class="line">cc=<span class="keyword">new</span> <span class="title class_">ComplexCipher</span>(sc); </span><br><span class="line">ac=<span class="keyword">new</span> <span class="title class_">AdvancedCipher</span>(cc);</span><br></pre></td></tr></table></figure></div><p><strong>半透明</strong>装饰模式（变形金刚）</p><p>**半透明(semi-transparent)**的装饰模式允许用户在客户端声明具体装饰者类型的对象，调用在具体装饰者中新增的方法。</p><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Transform camaro; </span><br><span class="line">camaro=<span class="keyword">new</span> <span class="title class_">Car</span>(); </span><br><span class="line">camaro.move(); </span><br><span class="line">Robot bumblebee=<span class="keyword">new</span> <span class="title class_">Robot</span>(camaro); </span><br><span class="line">bumblebee.move(); </span><br><span class="line">bumblebee.say(); <span class="comment">// 调用具体装饰者中新增的方法</span></span><br></pre></td></tr></table></figure></div><h3 id="Facade-Pattern（对象模式-结构型模式）">Facade Pattern（对象模式+结构型模式）</h3><p>外部与一个子系统的通信必须通过一个<strong>统一的外观对象</strong>进行，为子系统中的一组接口<strong>提供一个一致的界面</strong>，外观模式<u><strong>定义了一个高层接口</strong></u>，这个接口使得这一子系统更加容易使用。</p><p>外观模式又称为<strong>门面模式</strong>，它是一种对象结构型模式。</p><p>外观模式是<strong>SRP</strong>、<strong>LoD</strong>法则的体现</p><img lazyload src="/images/loading.svg" data-src="https://imgss.s3.bitiful.net/2024/06/23/1719063544493-78.png" alt="img" style="zoom: 25%;"> <p>Facade：外观角色</p><p>SubSystem: 子系统角色</p><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Facade</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">SubSystemA</span> <span class="variable">obj1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SubSystemA</span>();</span><br><span class="line">  <span class="keyword">private</span> <span class="type">SubSystemB</span> <span class="variable">obj2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SubSystemB</span>();</span><br><span class="line">  <span class="keyword">private</span> <span class="type">SubSystemC</span> <span class="variable">obj3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SubSystemC</span>();</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>&#123;</span><br><span class="line">    obj1.method();</span><br><span class="line">    obj2.method();</span><br><span class="line">    obj3.method();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="示例-8">示例</h4><p>案例：电源总开关</p><img lazyload src="/images/loading.svg" data-src="https://imgss.s3.bitiful.net/2024/06/23/3.png" alt="img" style="zoom:50%;"> <p><strong>文件加密。<strong>某系统需要提供一个文件加密模块，加密流程包括三个操作，分别是读取源文件、加密、保存加密之后的文件。读取文件和保存文件使用流来实现，这三个操作相对独立，其业务代码封装在三个不同的类中。现在需要提供</strong>一个统一的加密外观类</strong>，用户可以直接使用该加密外观类完成文件的读取、加密和保存三个操作，而不需要与每一个类进行交互，使用外观模式设计该加密模块。</p><img lazyload src="/images/loading.svg" data-src="https://imgss.s3.bitiful.net/2024/06/23/4-1719063877363-87.png" alt="img" style="zoom: 33%;"> <h4 id="优点-8">优点</h4><ol><li>对<strong>客户屏蔽子系统组件</strong>，减少了客户处理的对象数目并<strong>使得子系统使用起来更加容易</strong></li><li>实现了子系统与客户之间的<strong>松耦合关系</strong></li><li><strong>降低了大型软件系统中的编译依赖性，并简化了系统在不同平台之间的移植过程</strong></li><li><u><strong>只是提供了一个访问子系统的统一入口，并不影响用户直接使用子系统类</strong></u></li></ol><h4 id="缺点-7"><strong>缺点</strong></h4><ol><li><u><strong>不能很好地限制客户使用子系统类</strong></u></li><li>在不引入抽象外观类的情况下，增加新的子系统可能需要修改外观类或客户端的源代码，<strong>违背了“开闭原则”</strong></li></ol><h4 id="模式应用-4">模式应用</h4><p>Session外观模式是外观模式在Java EE框架中的应用。</p><img lazyload src="/images/loading.svg" data-src="https://imgss.s3.bitiful.net/2024/06/23/5-1719064060541-92.png" alt="img" style="zoom:33%;"> <h4 id="模式扩展-7">模式扩展</h4><ol><li>一个系统卡哇伊有多个外观类，通常会是单例，也可以多个</li><li>不要试图通过外观类为子系统增加新行为</li><li><u><strong>外观模式和迪米特法则</strong></u><ul><li><strong>外观模式创造出一个外观对象，将客户端所涉及的属于一个子系统的协作伙伴的数量减到最少，使得客户端与子系统内部的对象的相互作用被外观对象所取代</strong>。外观类充当了客户类与子系统类之间的“第三者”，降低了客户类与子系统类之间的耦合度，<u>外观模式就是实现代码重构以便达到“迪米特法则”要求的一个强有力的武器。</u></li></ul></li><li>抽象外观类的引入</li></ol><p><strong>抽象外观类</strong>：</p><ul><li>外观模式最大的缺点在于<strong>违背了“开闭原则”</strong>，当增加新的子系统或者移除子系统时需要修改外观类，可以通过引入抽象外观类在一定程度上解决该问题，<strong>客户端针对抽象外观类进行编程</strong>。</li><li>对于新的业务需求，不修改原有外观类，而<strong>对应增加一个新的具体外观类</strong>，由新的具体外观类来关联新的子系统对象，同时通过修改配置文件来达到不修改源代码并更换外观类的目的。</li></ul><img lazyload src="/images/loading.svg" data-src="https://imgss.s3.bitiful.net/2024/06/23/image-20240622215105460.png" alt="image-20240622215105460" style="zoom: 67%;"> <h3 id="Template-Method-Pattern（类模式-行为型模式）">Template Method Pattern（类模式+行为型模式）</h3><img lazyload src="/images/loading.svg" data-src="https://imgss.s3.bitiful.net/2024/06/23/12.png" alt="img" style="zoom:33%;"> <h4 id="定义-8">定义</h4><p>定义一个操作中<strong>算法的骨架</strong>，而将一些步骤延迟到子类中，模板方法使得子类可以<strong>不改变一个算法的结构即可重定义该算法的某些特定步骤</strong>。模板方法是一种<strong>类</strong>行为型模式。（因为是基于继承的代码复用方式嘛）</p><h4 id="结构">结构</h4><img lazyload src="/images/loading.svg" data-src="https://imgss.s3.bitiful.net/2024/06/23/13.png" alt="img" style="zoom:50%;"> <p>模板方法模式包含如下角色：</p><ol><li>AbstractClass: 抽象类</li><li>ConcreteClass: 具体子类</li></ol><h4 id="模式分析">模式分析</h4><ol><li><p>模板方法模式是一种类的行为型模式，在它的结构图中<strong>只有类之间的继承关系，没有对象关联关系</strong>。</p></li><li><p>在模板方法模式的使用过程中，要求开发抽象类和开发具体子类的设计师之间进行协作。一个设计师负责给出<strong>一个算法的轮廓和骨架</strong>，另一些设计师则<strong>负责给出这个算法的各个逻辑步骤</strong>。实现这些具体逻辑步骤的方法称为<strong>基本方法(Primitive Method)</strong>，<u>而将这些基本法方法汇总起来的方法称为<strong>模板方法(Template Method)</strong>，模板方法模式的名字从此而来。</u></p></li><li><p>模板方法<strong>即templateMethod</strong>：一个模板方法是<strong>定义在抽象类中的、把基本操作方法组合在一起</strong>形成一个总算法或一个总行为的方法。（用于组合的那个方法）</p></li><li><p>基本方法（有三种）：基本方法是<strong>实现算法各个步骤的方法</strong>，是模板方法的组成部分。</p><ol><li><p>抽象方法(Abstract Method)</p></li><li><p>具体方法(Concrete Method)</p></li><li><p>钩子方法(Hook Method)：挂钩方法和空方法</p><ul><li><p>挂钩方法：让子类可以影响父类中定义的算法的执行路径，从而让模板方法中的某些<strong>步骤是可选的</strong>。比如下列例子中列举的<code>isPrint()</code>算法。</p><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 钩子方法示例</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">template</span><span class="params">()</span>&#123;</span><br><span class="line">   open();</span><br><span class="line">   display();</span><br><span class="line">   <span class="keyword">if</span>(isPrint())&#123;</span><br><span class="line">      print();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPrint</span><span class="params">()</span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li><li><p><strong>空方法</strong>：留一个占位，如果需要在某些地方加入操作，可以在子类中加入。</p></li></ul></li></ol></li></ol><p>基本框架代码</p><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractClass</span> &#123;</span><br><span class="line">    <span class="comment">// 模板方法，定义算法的骨架</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">templateMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        primitiveOperation1();</span><br><span class="line">        primitiveOperation2();</span><br><span class="line">        primitiveOperation3();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 基本方法 - 具体方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">primitiveOperation1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 实现代码</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Operation 1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 基本方法 - 抽象方法，由子类实现</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">primitiveOperation2</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 基本方法 - 钩子方法，提供默认实现，子类可以选择性重写</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">primitiveOperation3</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 默认实现</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Default hook operation 3&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteClass</span> <span class="keyword">extends</span> <span class="title class_">AbstractClass</span> &#123;</span><br><span class="line">    <span class="comment">// 实现抽象方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">primitiveOperation2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 实现代码</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Concrete operation 2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重写钩子方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">primitiveOperation3</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 实现代码</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Customized hook operation 3&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><blockquote><p>看起来钩子方法和具体方法好像没啥区别，应该是用处不太一样？</p></blockquote><h4 id="示例-9">示例</h4><p>**银行业务办理流程。**在银行办理业务时，一般都包含几个基本步骤，首先需要取号排队，然后办理具体业务，最后需要对银行工作人员进行评分。无论具体业务是取款、存款还是转账，其基本流程都一样。现使用模板方法模式模拟银行业务办理流程。</p> <img lazyload src="/images/loading.svg" data-src="https://imgss.s3.bitiful.net/2024/06/23/14.png" alt="img" style="zoom:33%;"><p>**数据库操作模板。**对数据库的操作一般包括连接、打开、使用、关闭等步骤，<strong>在数据库操作模板类中我们定义了connDB()、openDB()、useDB()、closeDB()四个方法分别对应这四个步骤</strong>。对于不同类型的数据库（如SQL Server和Oracle），其操作步骤都一致，只是连接数据库connDB()方法有所区别，现使用模板方法模式对其进行设计。</p> <img lazyload src="/images/loading.svg" data-src="https://imgss.s3.bitiful.net/2024/06/23/15.png" alt="img" style="zoom:33%;"><h4 id="优点-9">优点</h4><ul><li>模板方法模式在一个类中<strong>抽象地定义算法</strong>，而由它的子类实现细节的处理。</li><li>模板方法模式是一种<strong>代码复用</strong>的基本技术。</li><li>模板方法模式导致一种<strong>反向</strong>的控制结构，通过一个父类调用其子类的操作，通过对子类的扩展增加新的行为，符合“<strong>开闭原则”</strong>。</li></ul><h4 id="缺点-8">缺点</h4><p>每个不同的实现都需要定义一个子类，这会导致<strong>类的个数增加</strong>，系统更加庞大，设计也更加抽象，但是更加符合“<strong>单一职责原则</strong>”，使得类的内聚性得以提高。</p><h4 id="适用环境">适用环境</h4><ul><li>一次性实现一个算法的不变的部分，并将<strong>可变的行为留给子类来实现</strong>。</li><li><strong>各子类中公共的行为应被提取出来并集中到一个公共父类</strong>中以避免代码重复。</li><li><strong>对一些复杂的算法进行分割</strong>，将其算法中固定不变的部分设计为模板方法和父类具体方法，而一些可以改变的细节由其子类来实现。</li><li>控制<strong>子类的扩展</strong></li></ul><h4 id="模式应用-5">模式应用</h4><ol><li><p>模板方法模式广泛应用于框架设计（如Spring，Struts等）中，<strong>以确保父类控制处理流程的逻辑顺序</strong>（如框架的初始化）。</p></li><li><p>Java单元测试工具JUnit中的TestCase类的设计</p><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">runBare</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">    setUp();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        runTest();</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">        tearDown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li></ol><h4 id="模式扩展-8">模式扩展</h4><p>关于继承的讨论</p><ol><li>模板方法模式鼓励我们<strong>恰当使用继承</strong>，此模式可以用来改写一些拥有相同功能的相关类，<strong>将可复用的一般性的行为代码移到父类里面</strong>，而将特殊化的行为代码移到子类里面。<strong>模板方法模式就是体现继承优势的模式之一</strong>。</li></ol><p>好莱坞原则</p><ol><li>在模板方法模式中，子类不显式调用父类的方法，而是通过覆盖父类的方法来实现某些具体的业务逻辑，<strong>父类控制对子类的调用</strong>，这种机制被称为<strong>好莱坞原则</strong>(Hollywood Principle)，好莱坞原则的定义为：“<strong>不要给我们打电话，我们会给你打电话(Don‘t call us, we’ll call you)</strong>”。</li><li>在模板方法模式中，好莱坞原则体现在：<u><strong>子类不需要调用父类，而通过父类来调用子类，将某些步骤的实现写在子类中，由父类来控制整个过程。</strong></u></li></ol><p>钩子方法的使用</p><ol><li>钩子方法的引入使得子类可以控制父类的行为。</li><li>最简单的钩子方法就是<strong>空方法</strong>，<strong>或者在钩子方法中定义一个默认的实现</strong>，如果子类不覆盖钩子方法，则执行父类的默认实现代码。</li><li>比较复杂一点的钩子方法<strong>可以对其他方法进行约束</strong>，这种钩子方法通常返回一个boolean类型，即返回true或false，用来判断是否执行某一个基本方法。（挂钩方法？）</li></ol><h3 id="Command-Pattern（对象模式-行为型模式）">Command Pattern（对象模式+行为型模式）</h3><p>模式动机：<u><strong>发送者和接收者完全解耦（请求和执行解耦</strong></u>），invoker只知道发送命令，<strong>不需要知道如何完成命令</strong></p><p><strong>将一个请求封装为一个对象</strong>，从而使我们可用<strong>不同的请求对客户进行参数化</strong>；<strong>对请求排队或者记录请求日志，以及支持可撤销的操作</strong>。</p><p>别名为动作(Action)模式或事务(Transaction)模式。</p><ul><li>Command 抽象命令类</li><li>ConcreteCommand 具体命令类</li><li>Invoker 调用者</li><li>Receiver 接收者</li><li>Client 客户类</li></ul><img lazyload src="/images/loading.svg" data-src="https://imgss.s3.bitiful.net/2024/06/23/1719069805511-103.png" alt="img" style="zoom: 33%;"> <blockquote><p>Client和ConcreteCommand之间的关联是因为在创建Command的时候需要把Receiver给它</p><p>invoker下达指令执行某个Command，然后command利用持有的receiver去执行，执行调用的是receiver的一些action</p></blockquote> <div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Command</span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Invoker</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Command command;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Invoker</span><span class="params">(Command command)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.command = command;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCommand</span><span class="params">(Command command)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.command = command;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">call</span><span class="params">()</span> &#123;</span><br><span class="line">        command.execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteCommand</span> <span class="keyword">extends</span> <span class="title class_">Command</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Receiver receiver;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span> &#123;</span><br><span class="line">        receiver.action();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Receiver</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">action</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// Do something</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="分析-7">分析</h4><ol><li>命令模式的本质是<strong>对命令进行封装</strong>，<strong>将发出命令的责任和执行命令的责任分割开</strong>。</li><li>每一个命令都是一个操作：<strong>请求的一方发出请求，要求执行一个操作；接收的一方收到请求，并执行操作</strong>。</li><li>命令模式允许请求的一方和接收的一方独立开来，<strong>使得请求的一方不必知道接收请求的一方的接口</strong>，更不必知道请求是怎么被接收，以及操作是否被执行、何时被执行，以及是怎么被执行的。</li><li>命令模式<strong>使请求本身成为一个对象</strong>，这个对象和其他对象一样可以被存储和传递。</li><li>命令模式的关键在于<strong>引入了抽象命令接口</strong>，且<strong>发送者针对抽象命令接口编程</strong>，只有实现了抽象命令接口的<strong>具体命令才能与接收者相关联</strong>。</li></ol><h4 id="顺序图（有助理解）">顺序图（有助理解）</h4><p><img lazyload src="/images/loading.svg" data-src="https://imgss.s3.bitiful.net/2024/06/23/1710833940411-4fcf464e-055e-4e6f-97ae-bc587a308e24.png" alt="img"></p><h4 id="示例-10">示例</h4><p><strong>电视机遥控器</strong>。电视机是请求的接收者，遥控器是请求的发送者，遥控器上有一些按钮，不同的按钮对应电视机的不同操作。抽象命令角色由一个命令接口来扮演，有三个具体的命令类实现了抽象命令接口，这三个具体命令类分别代表三种操作：打开电视机、关闭电视机和切换频道。显然，电视机遥控器就是一个典型的命令模式应用实例。</p><p><img lazyload src="/images/loading.svg" data-src="https://imgss.s3.bitiful.net/2024/06/23/1710833940442-a23288b5-0749-4543-829a-c424ef88e47a.webp" alt="img"></p><p><strong>功能键设置</strong>。为了用户使用方便，某系统提供了一系列功能键，用户可以自定义功能键的功能，如功能键FunctionButton可以用于退出系统(SystemExitClass)，也可以用于打开帮助界面(DisplayHelpClass)。用户可以通过修改配置文件来改变功能键的用途，现使用命令模式来设计该系统，使得功能键类与功能类之间解耦，相同的功能键可以对应不同的功能。</p><p><img lazyload src="/images/loading.svg" data-src="https://imgss.s3.bitiful.net/2024/06/23/1710833940484-57a09064-a6b5-40db-91f5-7b7c4af283e5.webp" alt="img"></p><h4 id="优点-10"><strong>优点</strong></h4><ol><li>降低系统耦合度</li><li><strong>新的命令可以很容易地加入到系统中</strong></li><li>可以比较容易地设计一个<strong>命令队列</strong>和<strong>宏命令</strong></li><li><u><strong>可以方便地实现对请求的Undo和Redo</strong></u></li></ol><h4 id="缺点-9"><strong>缺点</strong></h4><p>导致系统有过多的<strong>具体命令类</strong>。</p><h4 id="模式适用">模式适用</h4><p>将请求调用者和请求接收者解耦</p><ol><li><strong>需要在不同的时间指定请求、将请求排队和执行请求</strong></li><li><strong>需要支持命令的撤销操作和回复操作</strong></li><li><strong>需要将一组操作组合在一起</strong></li></ol><h4 id="撤销操作的实现">撤销操作的实现</h4><p><img lazyload src="/images/loading.svg" data-src="https://imgss.s3.bitiful.net/2024/06/23/1710833940772-87e3074c-71a8-4c05-8a05-ad071ec322fe.webp" alt="img"></p><blockquote><p>在Command的抽象和实现里，加个undo就行了，执行相反/撤销操作</p></blockquote><h4 id="宏命令">宏命令</h4><ol><li>宏命令又称为<strong>组合命令</strong>，它是<strong>命令模式和组合模式</strong>联用的产物。</li><li>宏命令也是一个具体命令，不过它包含了对其他命令对象的引用，<strong>在调用宏命令的execute()方法时，将递归调用它所包含的每个成员命令的execute()方法</strong>，一个宏命令的成员对象可以是简单命令，还可以继续是宏命令。<u><strong>执行一个宏命令将执行多个具体命令，从而实现对命令的批处理。</strong></u></li></ol><p><img lazyload src="/images/loading.svg" data-src="https://imgss.s3.bitiful.net/2024/06/23/1710833940830-d4632cf6-d13e-4ab8-9851-0c0e3d0242fe.webp" alt="img"></p><blockquote><p>Composite Command就用不着关联Receiver了</p></blockquote><h3 id="Mediator-Pattern（对象模式-行为型模式）">Mediator Pattern（对象模式+行为型模式）</h3><h4 id="模式动机">模式动机</h4><p><img lazyload src="/images/loading.svg" data-src="https://imgss.s3.bitiful.net/2024/06/23/1711593299503-b79ce465-921e-4b7d-9096-3f9bac55bd58.webp" alt="img"></p><p>在用户与用户直接聊天的设计方案中，<strong>用户对象之间存在很强的关联性</strong>，将导致系统出现如下问题：</p><ol><li><strong>系统结构复杂</strong>：对象之间存在大量的相互关联和调用，若有一个对象发生变化，则需要跟踪和该对象关联的其他所有对象，并进行适当处理。</li><li><strong>对象可重用性差</strong>：由于一个对象和其他对象具有很强的关联，若没有其他对象的支持，一个对象很难被另一个系统或模块重用，这些对象表现出来更像一个不可分割的整体，职责较为混乱。</li><li><strong>系统扩展性低</strong>：增加一个新的对象需要在原有相关对象上增加引用，增加新的引用关系也需要调整原有对象，系统耦合度很高，对象操作很不灵活，扩展性差。</li></ol><p>根据<strong>SRP</strong>，我们<strong>应该尽量将对象细化，使其只负责或呈现单一的职责</strong>。</p><p><u>对于一个模块，可能由很多对象构成，而且这些对象之间可能存在相互的引用，<strong>为了减少对象两两之间复杂的引用关系，使之成为一个松耦合的系统，我们需要使用中介者模式</strong>，这就是中介者模式的模式动机。</u></p><h4 id="模式定义">模式定义</h4><p>用一个中介对象来<strong>封装一系列的对象交互</strong>，中介者使各对象不需要显式地相互引用，从而<strong>使其耦合松散</strong>，而且<strong>可以独立地改变它们之间的交互</strong>。</p><p>中介者模式又称为<strong>调停者模式</strong>，它是一种<strong>对象行为型模式</strong></p><h4 id="模式结构">模式结构</h4><p><a href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2021-Software-System-Design/img/lec06/9.png"><img lazyload src="/images/loading.svg" data-src="https://imgss.s3.bitiful.net/2024/06/23/1711593299490-4f71cd9a-cbac-4ac9-b2e5-a73d6654c443.png" alt="img"></a></p><p>中介者模式包含如下角色：</p><ol><li>Mediator: 抽象中介者</li><li>ConcreteMediator: 具体中介者</li><li>Colleague: 抽象同事类</li><li>ConcreteColleague: 具体同事类</li></ol><h4 id="模式分析-2">模式分析</h4><p>中介者模式可以使对象之间的关系数量急剧减少：</p><p><img lazyload src="/images/loading.svg" data-src="https://imgss.s3.bitiful.net/2024/06/23/1711593299556-bb181fdf-2d4c-48a1-9e5f-93f52b6833c0-1719107151987-8.webp" alt="img"></p><p>中介者承担两方面的职责：</p><ol><li><strong>中转作用（结构性）</strong>：通信时通过Mediator进行中转。该中转作用属于中介者<strong>在结构上的支持</strong>。</li><li><strong>协调作用（行为性）</strong>：中介者根据封装在自身内部的协调逻辑，对同事的请求进行进一步处理，将同事成员之间的关系行为进行分离和封装。该协调作用属于中介者<strong>在行为上的支持</strong>。</li></ol><h4 id="典型代码">典型代码</h4><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Mediator</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> ArrayList&lt;Colleague&gt; colleagues = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">register</span><span class="params">(Colleague colleague)</span> &#123;</span><br><span class="line">        colleagues.add(colleague);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">operation</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteMediator</span> <span class="keyword">extends</span> <span class="title class_">Mediator</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operation</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 示例操作，调用第一个同事的方法1</span></span><br><span class="line">        <span class="keyword">if</span> (!colleagues.isEmpty()) &#123;</span><br><span class="line">            colleagues.get(<span class="number">0</span>).method1();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Colleague</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> Mediator mediator;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Colleague</span><span class="params">(Mediator mediator)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.mediator = mediator;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteColleague</span> <span class="keyword">extends</span> <span class="title class_">Colleague</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ConcreteColleague</span><span class="params">(Mediator mediator)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(mediator);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 具体实现</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">()</span> &#123;</span><br><span class="line">        mediator.operation();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="示例-11">示例</h4><p>**虚拟聊天室。**某论坛系统欲增加一个虚拟聊天室，允许论坛会员通过该聊天室进行信息交流，普通会员(CommonMember)可以给其他会员发送文本信息，钻石会员(DiamondMember)既可以给其他会员发送文本信息，还可以发送图片信息。该聊天室可以对不雅字符进行过滤，如“日”等字符；还可以对发送的图片大小进行控制。用中介者模式设计该虚拟聊天室。</p><p><img lazyload src="/images/loading.svg" data-src="https://imgss.s3.bitiful.net/2024/06/23/1711593299791-d550b3c7-b9cf-4ff7-8f68-728600793888.webp" alt="img"></p><blockquote><p>注意ChatGroup的sentText和Member的sendText参数不一样（多一个from），这就是中介者式的关键了，题目中的权限控制的话直接在各自的具体类做就行了</p></blockquote><h4 id="优点-11">优点</h4><ul><li>简化了对象之间的交互</li><li>将各同事解耦</li><li>减少子类生成</li><li>可以简化各同事类的设计和实现</li></ul><h4 id="缺点-10">缺点</h4><p>在具体中介者类中包含了同事之间的交互细节，<strong>可能会导致具体中介者类非常复杂</strong>，<strong>使得系统难以维护。</strong></p><h4 id="适用环境-2">适用环境</h4><ol><li>对象之间存在复杂的引用关系</li><li><strong>一个对象由于引用了其他很多对象并且直接和这些对象通信，导致</strong>难以复用该对象**。**</li><li><strong>想通过一个中间类来封装多个类的行为，又不想生成太多子类</strong>。改变行为可以增加新的中介者类。</li></ol><h4 id="应用">应用</h4><ol><li>事件驱动类（GUI组件之间的交互）</li><li>MVC - <strong>Controller作为一种中介者</strong><img lazyload src="/images/loading.svg" data-src="https://imgss.s3.bitiful.net/2024/06/23/1719108264357-13.jpeg" alt="img"></li></ol><h4 id="模式扩展-9">模式扩展</h4><p><strong>1.中介者模式与迪米特法则</strong></p><p>将系统中有关的对象所引用的其他对象数目减少到最少，<strong>因此，中介者模式就是迪米特法则的一个典型应用。</strong></p><p><strong>2.中介者模式与GUI开发</strong></p><p>中介者模式可以方便地应用于图形界面(GUI)开发中，在比较复杂的界面中可能存在多个界面组件之间的交互关系。</p><p>对于这些复杂的交互关系，有时候我们可以引入一个中介者类，将这些交互的组件作为具体的同事类，将它们之间的引用和控制关系交由中介者负责，在一定程度上简化系统的交互，<strong>这也是中介者模式的常见应用之一。</strong></p><h3 id="Observer-Pattern（对象模式-行为型模式）">Observer Pattern（对象模式+行为型模式）</h3><p><img lazyload src="/images/loading.svg" data-src="https://imgss.s3.bitiful.net/2024/06/23/1712038561127-523f525d-1560-4b07-8af5-c4cbbb70fcb4.webp" alt="image.png"></p><p>建立一种<strong>对象与对象之间的依赖关系</strong>，一个对象发生改变时将自动通知其他对象，其他对象将相应做出反应。</p><ol><li>发生改变的对象称为<strong>观察目标</strong></li><li>被通知的对象称为<strong>观察者</strong></li></ol><p>一个观察目标可以对应多个观察者，而且这些观察者之间没有相互联系，<strong>可以根据需要增加和删除观察者，使得系统更易于扩展</strong>，这就是观察者模式的模式动机。</p><h4 id="定义-9">定义</h4><p><u>观察者模式(Observer Pattern)：定义对象间的一种<strong>一对多依赖关系</strong>，使得<strong>每当一个对象状态发生改变</strong>时，其<strong>相关依赖对象皆得到通知并被自动更新</strong>。</u></p><p>观察者模式又叫做<strong>发布-订阅（Publish/Subscribe）模式、模型-视图（Model/View）模式、源-监听器（Source/Listener）模式或从属者（Dependents）模式</strong>。观察者模式是一种<strong>对象行为型</strong>模式。</p><ul><li><strong>publisher, subscriber这种其实用的更多</strong></li></ul><h4 id="模式结构-2">模式结构</h4><ol><li>Observer抽象观察者</li><li>ConcreteObserver具体观察者</li><li>Subject抽象主题：目标，会拥有一个<strong>observers列表，方法上会有比如attach,detach,notify等</strong></li><li>ConcreteSubject具体主题</li></ol><p><img lazyload src="/images/loading.svg" data-src="https://imgss.s3.bitiful.net/2024/06/23/1711593298953-e2237678-5f74-42a2-af4e-f128e51610f2.webp" alt="img"></p><ol><li><p>一般说抽象，不区分抽象类或者抽象接口，但在观察者模式，明确区分了<strong>目标对象是抽象类，观察者是抽象接口</strong>，为什么？</p><ul><li>对于Subject类，可以复用attach和detach的实现。类承担了通信职责和数据职责。</li><li>对于Observer类，update的方法都一样，数据观察是通用的。其实只有一个通信职责，所以接口就差不多了，没必要抽象类？<ul><li>个人感觉还是主要出于java不能多继承的考虑…，设计成接口更灵活的去implement</li></ul></li><li>更好的方法是，<strong>subject和observer都声明成抽象接口</strong>。因为通信职责和本来的职责正交，可以分解。</li></ul></li><li><p><strong>观察者对象其实持有目标对象的引用（图上没画，可见后面具体代码）</strong>，目的是什么？</p><ul><li>对于observer来说，是否监听应该由observer决定（调用attach和detach）。</li><li>不能称作对subject的依赖，这个持有引用是由观察者模式决定的。</li></ul></li></ol><h4 id="松耦合">松耦合</h4><img lazyload src="/images/loading.svg" data-src="https://imgss.s3.bitiful.net/2024/06/23/1712040525216-cd5f005e-26ca-40b7-a73b-c84539ea317c.png" alt="img" style="zoom:50%;"> <p>松耦合不是<strong>依赖倒转原则</strong>，而是<strong>最小知识原则</strong></p><p><strong>而依赖倒置原则则是说，高层模块不应该依赖低层模块，两者都应该依赖抽象。</strong></p><p><strong>因为依赖倒转是一方具体一方抽象？而这里是两边都是松耦合</strong></p><h4 id="示例-12">示例</h4><p><img lazyload src="/images/loading.svg" data-src="https://imgss.s3.bitiful.net/2024/06/23/1712041476229-a86fd07b-649a-4800-8288-cd32a20b0c74.png" alt="image.png"></p><p><strong>代码</strong></p><img lazyload src="/images/loading.svg" data-src="https://imgss.s3.bitiful.net/2024/06/23/image-20240623104518370.png" alt="image-20240623104518370" style="zoom:50%;"> <blockquote><p>如上文所说，具体观察者类持有对于Subject的引用，因为其实Observer这边才是主导的一端，具有主动性</p></blockquote><h4 id="优点-12">优点</h4><ul><li><strong>实现表示层和数据逻辑层的分离</strong>，使得可以有不同的表示层作为具体观察者角色</li><li>在观察目标和观察者之间建立一个<strong>抽象的耦合</strong>（松耦合）</li><li><strong>支持广播通信</strong></li><li><strong>符合开闭原则</strong></li></ul><h4 id="缺点-11">缺点</h4><ul><li>观察者太多，<strong>通知所有观察者耗时长</strong></li><li>如果有循环依赖-&gt;可能会有系统崩溃的风险</li><li>观察者模式<strong>没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的</strong>，而仅仅只是知道观察目标发生了变化。</li></ul><h4 id="模式适用-2">模式适用</h4><p>一个改变-&gt;多个改变，不知具体有多少对象，不知道是谁</p><p>需要在系统中创建一个触发链</p><h4 id="Java语言提供的对观察者模式的支持">Java语言提供的对观察者模式的支持</h4><p>在JDK的java.util包中，提供了<strong>Observable类</strong>以及<strong>Observer接口</strong>，它们构成了Java语言对观察者模式的支持。</p><p><img lazyload src="/images/loading.svg" data-src="https://imgss.s3.bitiful.net/2024/06/23/asynccode.png" alt="img"></p><h4 id="MVC模式">MVC模式</h4><p>算是中介者+观察者？（思想上算是结合了</p><ul><li>模型Model：目标</li><li>视图View ：观察者</li><li>控制器Controller：中介者</li></ul><p>当模型层的数据发生改变时，视图层将自动改变其显示内容。</p><p><img lazyload src="/images/loading.svg" data-src="https://imgss.s3.bitiful.net/2024/06/23/asynccode.png" alt="img"></p><h4 id="push-pull模式">push/pull模式</h4><p>当数据量差不多的时候，使用push模式。subject把数据都传给observer。</p><p>当数据需要定制化更新的时候，使用pull模式，subject告知更新，observer自己update所需属性。</p><p>**观察者模式又分为两种模式：push和pull。**push是指suject在状态变化时将所有的状态信息都发给observer，pull则是suject通知observer更新时，observer获取自己感兴趣的状态。</p><p>两种模式在实现上的区别</p><ol><li>push模式下，observer的update方法接收的是状态信息</li><li>pull模式下，update方法接收的是suject对象，这种情况下，suject须提供状态信息的get方法，让observer可以获取自己感兴趣的信息。</li></ol><p>两种模式的优劣</p><ol><li><strong>push模式要求suject必须了解observer需要的状态</strong>，pull则是observer按需获取</li><li>push模式下observer的update方法的参数是具体的状态信息，发生变化时必须要重写update方法，pull模式则是将suject对象本身传给update，是最大的参数集合。</li></ol><h3 id="State-Pattern（对象模式-行为型模式）">State Pattern（对象模式+行为型模式）</h3><p>一个对象的<strong>行为</strong>取决于一个或多个<strong>动态变化的属性</strong>，这样的属性叫作<strong>状态</strong>，这样的对象叫做有状态的(stateful)对象。</p><p>状态模式的<strong>关键</strong>是<strong>引入了一个抽象类来专门表示对象的状态</strong>，这个类我们叫做<strong>抽象状态类</strong>，而对象的每一种具体状态类都继承了该类，并在<strong>不同具体状态类中实现了不同状态的行为，包括各种状态之间的转换</strong>。</p><p>状态是最可能变化的地方，需要做一个封装。</p><img lazyload src="/images/loading.svg" data-src="https://imgss.s3.bitiful.net/2024/06/23/1710833939854-b1b3b886-c52a-43e4-9344-584f675ff244.webp" alt="img" style="zoom:50%;"> <p>状态模式包含如下角色</p><ul><li>Context: 环境类</li><li>State: 抽象状态类</li><li>ConcreteState: 具体状态类</li></ul><p><strong>在结构上策略模式和状态模式是一致的，但是在使用上是很不同的</strong></p><ul><li>Context是状态模式关联的上下文环境</li><li>策略模式是封装好的，而状态模式为了追求对用户透明则牺牲了开闭原则（状态的切换在Context中无法避免修改</li></ul><p><strong>具体耦合</strong></p><blockquote><p>继承是强耦合</p></blockquote><p>状态模式存在具体耦合，状态切换写在环境类中比较好，因为都有具体耦合，都写在一个地方比较好，不至于太分散。因此<strong>状态模式不能完全支持OCP</strong>。因为产生了具体耦合，存在从一个状态类转变到另一个状态类，就必定会有具体耦合</p><p><strong>房间入住示例</strong></p><img lazyload src="/images/loading.svg" data-src="https://imgss.s3.bitiful.net/2024/06/23/1710833939847-80f82152-2834-4b08-8e2a-dc1fd0346951.webp" alt="img" style="zoom: 33%;"> <blockquote><p><a class="link" href="https://refactoringguru.cn/design-patterns/state">https://refactoringguru.cn/design-patterns/state <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p><p>房间类里面的比如预订等操作应该是调用状态的</p><p>state.预订()</p></blockquote><p><strong>论坛用户等级示例</strong>（感觉有点乱，不看也罢）</p><img lazyload src="/images/loading.svg" data-src="https://imgss.s3.bitiful.net/2024/06/23/1710833939852-476de22a-1fc1-4e5c-9ccd-0160b8f0acd8.webp" alt="img" style="zoom: 33%;"> <blockquote><p>上图的checkState位置其实可以放在account？</p></blockquote><p>同时注意到环境类ForumAccount和状态类AbstractState是相互持有引用的，为什么不合并为一个类？将设置状态的职责抽离出来，更符合状态管理类的单一职责。</p><p><strong>状态的转换是最重要的，什么时候由环境类转换，什么时候由状态类转换？</strong></p><p>由属性（积分）转变引发的转换vs由行为（入住退房）引发的转换：属性由环境类承担</p><p>所有类的转换行为一样vs与现在处于哪个状态有关</p><h4 id="优点-13"><strong>优点</strong></h4><ol><li><p><strong>封装了转换原则</strong></p></li><li><p><strong>枚举了可能的状态</strong></p></li><li><p><strong>可以方便地增加新的状态</strong>，只需要改变对象状态即可改变对象的行为。</p><blockquote><p>新增状态有可能破坏OCP，因为状态转换的代码会要变</p></blockquote></li><li><p><strong>状态转换逻辑与状态对象合成一体</strong>，而不是某一个巨大的条件语句块。</p></li><li><p><strong>让多个环境对象共享状态对象</strong>（多个房间都是预定的状态），从而减少系统中对象的个数。</p></li></ol><h4 id="缺点-12"><strong>缺点</strong></h4><ol><li>状态模式的使用必然会<strong>增加系统类和对象的个数</strong>。</li><li>状态模式的结构与实现都较为复杂，<strong>如果使用不当将导致程序结构和代码的混乱</strong>。</li><li><strong>对”开闭原则“的支持并不太好</strong>，产生了具体耦合（在具体对象中切换）</li></ol><h4 id="适用环境-3"><strong>适用环境</strong></h4><ol><li>对象的行为依赖于它的状态（属性）并且可以根据它的状态改变而改变它的相关行为</li><li><strong>代码中包含大量与对象状态有关的条件语句</strong></li></ol><blockquote><p>如工作流、游戏</p></blockquote><h4 id="状态模式扩展">状态模式扩展</h4><ol><li><strong>共享状态</strong>：在有些情况下<strong>多个环境对象需要共享同一个状态</strong>，如果希望在系统中实现多个环境对象实例共享一个或多个状态对象，那么需要将这些状态对象定义为<strong>环境的静态成员对象</strong></li><li>**简单状态模式：**状态都相互独立，**状态之间无须进行转换（额…）**的状态模式。它遵循“开闭原则”，可以在客户端实例化状态类，可以将具体状态类写入配置文件。</li><li>**可切换状态的状态模式（大多数状态模式）：**在具体状态类内部需要调用环境类Context的setState()方法进行状态的转换操作。</li></ol><h3 id="Strategy-Pattern（对象模式-行为型模式）">Strategy Pattern（对象模式+行为型模式）</h3><p>别名：<strong>Policy</strong> Pattern</p><p>定义了一系列算法或策略，并将每个算法<strong>封装</strong>在独立的类中，使得它们可以<strong>互相替换</strong>。<u><strong>一个类的行为或其算法可以在运行时更改。</strong></u></p><p>引入示例的解决：</p><p>想让鸭子飞起来……（添加fly的方法），可是鸭子会飞，橡皮鸭和木鸭子不会飞：</p><ol><li>鸭子抽象类实现fly，不会飞的自己覆盖掉</li><li>实现flyable的接口，会飞的自己接口</li></ol><p><strong>单独设计行为类，动态修改鸭子的行为</strong></p><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 聚合鸭子的行为</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Duck</span>&#123;</span><br><span class="line">    QuackBehavior quackBehavior;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> performQuack&#123;</span><br><span class="line">        quackBehavior.quack();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><strong>用到的设计原则：</strong></p><p>单一职责 、依赖倒转、合成复用</p><p><strong>启发：</strong></p><ol><li>所有子类都一样，在父类中实现</li><li>子类都不一样，在子类中实现</li><li>部分子类一样，在接口中实现</li></ol><img lazyload src="/images/loading.svg" data-src="https://imgss.s3.bitiful.net/2024/06/23/1711355091509-162e075f-83ff-4508-895c-861cff4f7979.webp" alt="img" style="zoom:50%;"> <p>环境类（Context）：维护一个指向策略对象的引用。</p><p>抽象策略类（Strategy）：定义所有支持的算法的公共接口。</p><p>具体策略类（Concrete Strategy）：实现抽象策略定义的接口，提供具体的算法实现。</p><h4 id="Applicability-适用性">Applicability-适用性</h4><ol><li>许多相关的类仅在<strong>行为</strong>上有所不同，策略提供了一种使用多种行为之一配置类的方法。</li><li>您需要算法的不同变体。**例如，您可能定义了反映不同空间/时间权衡的算法。将这些变体实现为算法的类层次结构时，可以使用策略。**往往实现的是相同的行为，但是是不同的算法</li><li>一种算法使用客户端不应该知道的数据。<strong>使用策略模式可避免暴露复杂的、特定于算法的数据结构</strong></li><li>**一个类定义了许多行为，这些行为在其操作中显示为多个条件语句。**代替许多条件，将相关的条件分支移到他们自己的策略类中。</li></ol><h4 id="Consequences-结果">Consequences-结果</h4><p>一个策略模式的潜在缺陷：客户必须意识到不同的策略。即<strong>客户在选择合适的策略之前必须先了解策略的不同</strong>，不然客户可能会遇到实现问题。</p><ul><li><strong>用户需要去了解实现的细节</strong></li><li>其实是破坏了封装</li></ul><p><strong>模式一般都会有的缺点：</strong></p><ol><li>增加设计的复杂度和增加类的个数（增加辅助类）</li></ol><h2 id="一些疑惑">一些疑惑</h2><ol><li><p>为什么工厂方法模式是类创建型，抽象工厂模式就是对象创建型了</p><p>A：个人理解是工厂方法模式通过定义一个创建对象的接口，让子类决定实例化哪一个类。其重点在于让子类来决定创建哪种具体类型的对象，因此更强调继承关系，<strong>因此是类模式</strong>；抽象工厂模式提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。其重点在于产品族的创建，通过组合多个产品对象来实现不同的品牌或系列，<strong>因此是对象模式。</strong></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 期末复习 </category>
          
          <category> 软件系统设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件系统设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>24-Spring-数据库开发期末复习</title>
      <link href="/posts/%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%BC%80%E5%8F%91/24-spring-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%BC%80%E5%8F%91%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0.html"/>
      <url>/posts/%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%BC%80%E5%8F%91/24-spring-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%BC%80%E5%8F%91%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>24 Spring 数据库开发期末复习</p><p>ChrisDing1105 version 1.4</p><p>Salute to the Legendary Software Workers <a class="link" href="https://github.com/SEBugMaker">SEBugMaker <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> <a class="link" href="https://github.com/ZUOHS">ZUOHS <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> <a class="link" href="https://github.com/huangwei021230">huangwei021230 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> <a class="link" href="https://github.com/quas-modo">quas-modo <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p><p>文字版复习录音转写：<a class="link" href="https://d412hlgjpp.feishu.cn/docx/YsHfdpdljomhApx3kOlcutVQnRf?from=from_copylink">https://d412hlgjpp.feishu.cn/docx/YsHfdpdljomhApx3kOlcutVQnRf?from=from_copylink <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p></blockquote><h2 id="题型">题型</h2><h3 id="难点：三道SQL">难点：三道SQL</h3><h4 id="时间、字符串、数值三选二">时间、字符串、数值三选二</h4><p>代码行数不会超过15-20</p><p>关键是要记得常见的函数:replace等</p><p>数值要考虑空值(平均值) COALESCE 中位数、众数不太好考</p><p>日期要知道使用索引有三种写法(前一天后一天范围怎么写、算日期之间的差 practice on class7.7)</p><p>标注用的mysql还是oracle</p><h4 id="会考一个递归-withas-树状结构自顶向下查询">会考一个递归(withas) 树状结构自顶向下查询</h4><p>起始体，union all，递归体，合并成一个视图的形式，最后写一句sql</p><h4 id="有一道可能会使用外连接">有一道可能会使用外连接</h4><p>会把外连接和那几个sql的计算变量融在一起</p><p>结构合理、关键字合理，函数用对都有分，细节对了全分</p><p>实在不会就写select from，不要空</p><h3 id="索引结构一定会考">索引结构一定会考</h3><p>n n+1个link</p><p>B树？对枝叶节点插入，如果满了会造成分裂，删除可能造成合并 在叶节点和内部节点不一样，是什么逻辑，怎么影响上面的节点(那两张图)</p><p>讲过例子，看下PPT</p><h3 id="日志">日志</h3><p>redo undo 怎么完成、区别，怎么实现(物理组织的PPT里写清楚了)</p><h3 id="分区分表分库">分区分表分库</h3><p>也是在物理组织部分</p><p>原因是什么，能够解决什么问题，会遇到什么问题（又怎么解决）</p><h3 id="SQL解释器：基于成本和基于规则">SQL解释器：基于成本和基于规则</h3><p>可能会考一个，关于SQL基于成本呢解释器的成本计算，成本优化？</p><p>（知道sql优化的基本逻辑）怎么计算优化路径的成本呢</p><p>等价变化，算出多个路径，估算每个路径的成本，哪些估算哪些是实际的，，有什么问题，为什么要改写sql</p><h3 id="送分题">送分题?</h3><p>可能还会再出一道题，自己思考，有什么建议和想法，纯粹的主观题</p><blockquote><p>以下为复习部分</p></blockquote><h2 id="SQL">SQL</h2><h3 id="聚合函数">聚合函数</h3><p>注意：当使用聚合函数（如 MAX, SUM, AVG 等）时，所有非聚合字段必须出现在 GROUP BY ⼦句中。否则，SQL 引擎无法确定如何处理这些字段。</p><p>Select后面接的结果集字段只有两种</p><ul><li>要么是group by出现的字段</li><li>要么是group by后出现的字段+聚合函数的组合</li></ul><p><img lazyload src="/images/loading.svg" data-src="24-Spring-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%BC%80%E5%8F%91%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20240616154704762.png" alt="image-20240616154704762"></p><blockquote><p>但实际运行好像无论MySQL5.7还是8.0也能选没group的</p></blockquote><h3 id="NULL如何成组">NULL如何成组?</h3><p>利用coalesce函数</p><p><img lazyload src="/images/loading.svg" data-src="24-Spring-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%BC%80%E5%8F%91%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20240616155109877.png" alt="image-20240616155109877"></p><h3 id="coalesce函数">coalesce函数</h3><p><code>COALESCE</code> 是 SQL 中的一个函数，它的作用是返回第一个非空表达式的结果。如果所有的表达式都是空（NULL），则 <code>COALESCE</code> 函数返回 NULL。这个函数常用于处理可能为 NULL 的数据列，确保查询结果中不会出现 NULL 值，而是使用一个默认的值。</p><p>语法：</p><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">COALESCE</span>(expression1, expression2, ..., expressionN)</span><br></pre></td></tr></table></figure></div><p>参数：</p><p><code>expression1, expression2, ..., expressionN</code>：可以是列名或值，<code>COALESCE</code> 会从左到右检查这些表达式，返回第一个非 NULL 的结果。</p><h3 id="字符串">字符串</h3><h4 id="substr-完整str-pos-长度">substr(完整str, pos, 长度)</h4><p>Q：把EMP表中的ENAME=KING的字符串拆开显示为4行，每行一个字符</p><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> substr(e.ename, iter.pos, <span class="number">1</span>) <span class="keyword">as</span> C</span><br><span class="line"><span class="keyword">from</span> (<span class="keyword">select</span> ename <span class="keyword">from</span> emp <span class="keyword">where</span> ename <span class="operator">=</span> <span class="string">&#x27;KING&#x27;</span>) e,</span><br><span class="line">(<span class="keyword">select</span> id <span class="keyword">as</span> pos <span class="keyword">from</span> t10) iter</span><br><span class="line"><span class="keyword">where</span> iter.pos <span class="operator">&lt;=</span> length(e.ename)</span><br></pre></td></tr></table></figure></div><p><strong>t10表</strong></p><p><code>t10</code> 表：这是一个特殊的表，通常在 Oracle 数据库中用来生成一个从 1 到 10 的数字序列。这个表的每一行都有一个 <code>id</code> 列，包含一个数字，用于表示序列中的一个位置。</p><blockquote><p>在 MySQL 数据库中，并没有像 Oracle 中的 <code>t10</code> 表这样的内置表来直接生成数字序列。不过，MySQL 可以通过其他方式来生成数字序列，例如使用递归的公用表表达式（Common Table Expressions, CTE）或者临时表。</p><p>以下是使用递归 CTE 生成数字序列的一个例子：</p><div class="highlight-container" data-rel="Pgsql"><figure class="iseeu highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">复制<span class="keyword">WITH</span> <span class="keyword">RECURSIVE</span> num(n) <span class="keyword">AS</span> (</span><br><span class="line">  <span class="keyword">SELECT</span> <span class="number">1</span></span><br><span class="line">  <span class="keyword">UNION</span> <span class="keyword">ALL</span></span><br><span class="line">  <span class="keyword">SELECT</span> n + <span class="number">1</span> <span class="keyword">FROM</span> num <span class="keyword">WHERE</span> n &lt; <span class="number">10</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> num;</span><br></pre></td></tr></table></figure></div><p>这个递归 CTE 会生成从 1 到 10 的数字序列。你可以调整 <code>n &lt; 10</code> 的条件来改变生成的序列长度。</p></blockquote><h4 id="replace函数">replace函数</h4><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">REPLACE(string, <span class="keyword">search</span>, replace)</span><br></pre></td></tr></table></figure></div><p>参数（会替换所有的）</p><ul><li><code>string</code>：要搜索和替换的原始字符串。</li><li><code>search</code>：要在 <code>string</code> 中搜索的子字符串。</li><li><code>replace</code>：用于替换 <code>search</code> 子字符串的新字符串。</li></ul><p><strong>使用 <code>REPLACE</code> 统计字符出现次数</strong></p><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> (length(<span class="string">&#x27;10,CLARK,MANAGER&#x27;</span>) <span class="operator">-</span> length(REPLACE(<span class="string">&#x27;10,CLARK,MANAGER&#x27;</span>, <span class="string">&#x27;,&#x27;</span>, <span class="string">&#x27;&#x27;</span>))) <span class="operator">/</span> length(<span class="string">&#x27;,&#x27;</span>) <span class="keyword">as</span> cnt;</span><br></pre></td></tr></table></figure></div><p>思路：把找到的字符串换成空，再计算长度差，注意除以本身长度</p><h4 id="translate函数">translate函数</h4><p>感觉就是强化版replace</p><p><strong>语法（Oracle）：</strong></p><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">TRANSLATE</span>(string, from_string, to_string)</span><br></pre></td></tr></table></figure></div><p><strong>参数：</strong></p><ul><li><code>string</code>：要进行字符转换的原始字符串。</li><li><code>from_string</code>：一个包含要被替换的字符的字符串。</li><li><code>to_string</code>：一个包含用于替换的字符的字符串，顺序应与 <code>from_string</code> 中的字符顺序相对应。</li></ul><p><strong>删除不想要的字符</strong></p><p>Oracle才有translate</p><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> replace(<span class="built_in">translate</span>(ename, <span class="string">&#x27;AEIOU&#x27;</span>,<span class="string">&#x27;aaaaa&#x27;</span>), <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;&#x27;</span>) <span class="keyword">as</span> stripped1,</span><br><span class="line">       sal</span><br><span class="line">       replace(sal, <span class="number">0</span>, <span class="string">&#x27;&#x27;</span>) <span class="keyword">as</span> stripped2 <span class="keyword">from</span> emp  </span><br></pre></td></tr></table></figure></div><p>先全换成某个字符，比如’a’，然后再删掉</p><h4 id="regexp-replace">regexp_replace</h4><p>分离数字和字符数据</p><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> data,</span><br><span class="line">    regexp_replace(ename, <span class="string">&#x27;[0-9]&#x27;</span>, <span class="string">&#x27;&#x27;</span>) <span class="keyword">as</span> characters</span><br><span class="line">    regexp_replace(ename, <span class="string">&#x27;[^0-9]&#x27;</span>, <span class="string">&#x27;&#x27;</span>) <span class="keyword">as</span> numbers</span><br><span class="line"><span class="keyword">from</span> emp</span><br></pre></td></tr></table></figure></div><h4 id="regexp">regexp</h4><p>判断是否含有数字或字符</p><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> ename <span class="keyword">from</span> V</span><br><span class="line"><span class="keyword">where</span> ename regexp <span class="string">&#x27;[^0-9a-zA-Z]&#x27;</span> <span class="operator">=</span> <span class="number">0</span></span><br></pre></td></tr></table></figure></div><h4 id="rpad">rpad</h4><blockquote><p>Oracle/Postgre</p></blockquote><p><code>RPAD</code> 函数的语法如下：</p><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RPAD(string, length, pad_string)</span><br></pre></td></tr></table></figure></div><ul><li><code>string</code>：要填充的原始字符串。</li><li><code>length</code>：目标字符串的长度。</li><li><code>pad_string</code>：用来填充的字符串。</li></ul><p>Q：</p><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> REPLACE(</span><br><span class="line">    REPLACE(</span><br><span class="line">        <span class="built_in">TRANSLATE</span>(REPLACE(<span class="string">&#x27;Stewie Griffin&#x27;</span>, <span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;&#x27;</span>), </span><br><span class="line">            <span class="string">&#x27;abcdefghijklmnopqrstuvwxyz&#x27;</span>, </span><br><span class="line">            RPAD(<span class="string">&#x27;#&#x27;</span>, <span class="number">26</span>, <span class="string">&#x27;#&#x27;</span>)), <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;&#x27;</span>), <span class="string">&#x27; &#x27;</span>, <span class="string">&#x27;.&#x27;</span>) <span class="operator">||</span> <span class="string">&#x27;.&#x27;</span></span><br><span class="line"><span class="keyword">FROM</span> t1;</span><br></pre></td></tr></table></figure></div><p><code>Stewie Griffin</code> -&gt; <code>Stewie Griffin</code> -&gt; <code>S##### G######</code> -&gt; <code>S G</code> -&gt; <code>S.G</code> -&gt; <code>S.G.</code></p><h3 id="数值处理">数值处理</h3><h4 id="平均值（要考虑空值">平均值（要考虑空值</h4><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">avg</span>(<span class="built_in">coalesce</span>(salary, <span class="number">0</span>)) <span class="keyword">as</span> average_score <span class="keyword">from</span> emp</span><br></pre></td></tr></table></figure></div><h4 id="累计求和-Running-Total">累计求和 Running Total</h4><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> e.ename, e.sal</span><br><span class="line">    (<span class="keyword">select</span> <span class="built_in">sum</span>(d.sal) <span class="keyword">from</span> emp d</span><br><span class="line">    <span class="keyword">where</span> d.empno <span class="operator">&lt;=</span> e.empno) <span class="keyword">as</span> runnin_total</span><br><span class="line"><span class="keyword">from</span> emp e</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> <span class="number">3</span></span><br></pre></td></tr></table></figure></div><blockquote><p>没什么新的</p></blockquote><h4 id="条件语句-百分比">条件语句-百分比</h4><p><strong>IF</strong>（适合简单语句）</p><p>IF(condition, result_if_true, result_if_false)</p><p><strong>CASE WHEN</strong>（适合多条件）</p><p><code>CASE WHEN</code> 是一个通用的 SQL 语句，用于实现复杂的条件判断。它可以用于所有支持 SQL 的数据库，包括 MySQL、PostgreSQL、Oracle、SQL Server 等。</p><p><strong>语法</strong></p><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CASE</span></span><br><span class="line">    <span class="keyword">WHEN</span> condition1 <span class="keyword">THEN</span> result1</span><br><span class="line">    <span class="keyword">WHEN</span> condition2 <span class="keyword">THEN</span> result2</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">ELSE</span> resultN</span><br><span class="line"><span class="keyword">END</span></span><br></pre></td></tr></table></figure></div><p>计算部门编号为10的员工薪水总和占所有员工薪水总和的百分比。</p><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">    (<span class="built_in">SUM</span>(IF(deptno <span class="operator">=</span> <span class="number">10</span>, sal, <span class="number">0</span>)) <span class="operator">/</span> <span class="built_in">SUM</span>(sal)) <span class="operator">*</span> <span class="number">100</span> <span class="keyword">AS</span> pct</span><br><span class="line"><span class="keyword">FROM</span> emp;</span><br></pre></td></tr></table></figure></div><h4 id="计算平均值时去掉最大值和最小值">计算平均值时去掉最大值和最小值</h4><p>注意最大最小可能不止一个，所以用not in</p><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">AVG</span>(sal)</span><br><span class="line"><span class="keyword">FROM</span> emp</span><br><span class="line"><span class="keyword">WHERE</span> sal <span class="keyword">NOT</span> <span class="keyword">IN</span> (</span><br><span class="line">    (<span class="keyword">SELECT</span> <span class="built_in">MIN</span>(sal) <span class="keyword">FROM</span> emp),</span><br><span class="line">    (<span class="keyword">SELECT</span> <span class="built_in">MAX</span>(sal) <span class="keyword">FROM</span> emp)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></div><blockquote><p>Tag: 修改累计值 没看</p></blockquote><h3 id="日期处理">日期处理</h3><p><strong>需要知道算日期的差</strong></p><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">date_add(hiredate, <span class="type">interval</span> <span class="number">-5</span> <span class="keyword">day</span>) <span class="keyword">as</span> hd_add_1D</span><br></pre></td></tr></table></figure></div><p><strong>相差的日期</strong></p><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">date_diff(ward_hd, allen_hd)</span><br></pre></td></tr></table></figure></div><p><strong>依据特定时间单位检索数据</strong></p><p><strong>monthname，dayname</strong></p><p>MYSQL</p><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ename</span><br><span class="line"><span class="keyword">FROM</span> emp</span><br><span class="line"><span class="keyword">WHERE</span> MONTHNAME(hiredate) <span class="keyword">IN</span> (<span class="string">&#x27;February&#x27;</span>, <span class="string">&#x27;December&#x27;</span>)</span><br><span class="line">   <span class="keyword">OR</span> DAYNAME(hiredate) <span class="operator">=</span> <span class="string">&#x27;Tuesday&#x27;</span>;</span><br></pre></td></tr></table></figure></div><h3 id="Union">Union</h3><p>Union All + Distinct = Union</p><p>Union All不去重</p><blockquote><p>⼤体⽽⾔，使用union等同于针对union all的输出结果，再执⾏⼀次distinct操作</p></blockquote><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> CONCAT(ename, <span class="string">&#x27; &#x27;</span>, dname) <span class="keyword">AS</span> ename_and_dname, deptno</span><br><span class="line"><span class="keyword">FROM</span> emp</span><br><span class="line"><span class="keyword">JOIN</span> dept <span class="keyword">ON</span> emp.deptno <span class="operator">=</span> dept.deptno</span><br><span class="line"><span class="keyword">WHERE</span> emp.deptno <span class="operator">=</span> <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">UNION</span> <span class="keyword">ALL</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="string">&#x27;----------&#x27;</span> <span class="keyword">AS</span> ename_and_dname, <span class="keyword">NULL</span> <span class="keyword">AS</span> deptno</span><br><span class="line"></span><br><span class="line"><span class="keyword">UNION</span> <span class="keyword">ALL</span></span><br><span class="line"><span class="keyword">SELECT</span> dname <span class="keyword">AS</span> ename_and_dname, deptno</span><br><span class="line"><span class="keyword">FROM</span> dept;</span><br></pre></td></tr></table></figure></div><p>注意select选的两个要一样</p><h3 id="连接">连接</h3><p>join = inner join；left join = left outer join等</p><p>在 SQL 中，连接是用来结合两个或多个表的记录的一种机制。根据关联条件的不同，连接可以分为多种类型，主要包括内连接（INNER JOIN）、外连接（OUTER JOIN，具体又分为左外连接 LEFT JOIN、右外连接 RIGHT JOIN 和全外连接 FULL OUTER JOIN）以及交叉连接（CROSS JOIN）。下面详细解释每种连接类型，并给出示例。</p><h4 id="内连接（INNER-JOIN）">内连接（INNER JOIN）</h4><p><strong>内连接</strong>返回两个表中符合连接条件的记录。如果在一个表中的记录在另一个表中没有匹配，则这些记录不会出现在结果集中。</p><p><strong>示例</strong>：有两个表，一个是员工表 <code>employees</code>（包含员工编号 <code>eno</code> 和姓名 <code>ename</code>），另一个是部门表 <code>departments</code>（包含部门编号 <code>dno</code> 和部门名称 <code>dname</code>）。我们想找出所有员工及其所属部门的名称。</p><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> employees.ename, departments.dname</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> departments</span><br><span class="line"><span class="keyword">ON</span> employees.dno <span class="operator">=</span> departments.dno;</span><br></pre></td></tr></table></figure></div><p>这个查询会返回所有存在于 <code>employees</code> 表和 <code>departments</code> 表中的匹配部门编号的员工姓名和部门名称。</p><h4 id="左外连接（LEFT-JOIN）">左外连接（LEFT JOIN）</h4><p><strong>左外连接</strong>返回左表（<code>LEFT JOIN</code> 左侧的表）的所有记录和右表中符合连接条件的记录。如果左表的记录在右表中没有匹配，则相关的右表列将返回 NULL。</p><p><strong>示例</strong>：使用上述的员工表和部门表，如果我们想列出所有员工及其可能的部门名称（即使某些员工没有部门信息）。</p><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> employees.ename, departments.dname</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> departments</span><br><span class="line"><span class="keyword">ON</span> employees.dno <span class="operator">=</span> departments.dno;</span><br></pre></td></tr></table></figure></div><p>这个查询会返回所有员工的姓名，对于那些没有部门的员工，部门名称会显示为 NULL。</p><h4 id="右外连接（RIGHT-JOIN）">右外连接（RIGHT JOIN）</h4><p><strong>右外连接</strong>与左外连接相反，它返回右表（<code>RIGHT JOIN</code> 右侧的表）的所有记录和左表中符合连接条件的记录。如果右表的记录在左表中没有匹配，则相关的左表列将返回 NULL。</p><p><strong>示例</strong>：如果我们想要列出所有部门及其可能的员工名称（即使某些部门没有员工）。</p><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> employees.ename, departments.dname</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">RIGHT</span> <span class="keyword">JOIN</span> departments</span><br><span class="line"><span class="keyword">ON</span> employees.dno <span class="operator">=</span> departments.dno;</span><br></pre></td></tr></table></figure></div><p>这个查询会返回所有部门的名称，对于那些没有员工的部门，员工名称会显示为 NULL。</p><h4 id="全外连接（FULL-OUTER-JOIN）">全外连接（FULL OUTER JOIN）</h4><p><strong>全外连接</strong>返回左表和右表中的所有记录。如果左表的记录在右表中没有匹配，或右表的记录在左表中没有匹配，则相关的另一侧表列将返回 NULL。注意，并非所有的 SQL 数据库系统都支持全外连接。</p><p><strong>示例</strong>：列出所有员工和所有部门，不论它们是否有匹配。</p><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> employees.ename, departments.dname</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">FULL</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> departments</span><br><span class="line"><span class="keyword">ON</span> employees.dno <span class="operator">=</span> departments.dno;</span><br></pre></td></tr></table></figure></div><h4 id="交叉连接（CROSS-JOIN）">交叉连接（CROSS JOIN）</h4><h4 id="交叉连接的语法">交叉连接的语法</h4><p>在SQL中，交叉连接的语法如下：</p><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> table1</span><br><span class="line"><span class="keyword">CROSS</span> <span class="keyword">JOIN</span> table2;</span><br></pre></td></tr></table></figure></div><p><strong>或者可以用隐式的语法：</strong></p><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> table1, table2;</span><br></pre></td></tr></table></figure></div><p><strong>交叉连接</strong>产生左表和右表的笛卡尔积，每个左表的记录与右表的每个记录相组合。</p><p><strong>示例</strong>：如果我们想要列出员工和部门的所有可能组合。</p><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> employees.ename, departments.dname</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">CROSS</span> <span class="keyword">JOIN</span> departments;</span><br></pre></td></tr></table></figure></div><p>这个查询将为每个员工与每个部门之间创建一个组合，不考虑他们之间是否有实际的关联。</p><h3 id="递归查询">递归查询</h3><blockquote><p>PPT 6.0 数据库设计</p><p>内含 树的三种实际实现：邻接模型、物化路径模型、嵌套集合模型</p><ol><li><p>邻接模型就像家庭树中的每个人都有一个“父亲”指向谁是他的父亲。每个节点都知道自己的父节点是谁，但不一定知道自己的子节点是谁。</p></li><li><p>物化路径模型就像每个分类都带有一张地图，指示它从根分类到当前分类的完整路径。</p><p>用相同的分类系统，这次每个分类记录路径：</p><table><thead><tr><th>id</th><th>name</th><th>path</th></tr></thead><tbody><tr><td>1</td><td>电子产品</td><td>/1</td></tr><tr><td>2</td><td>笔记本电脑</td><td>/1/2</td></tr><tr><td>3</td><td>手机</td><td>/1/3</td></tr><tr><td>4</td><td>摄像机</td><td>/1/4</td></tr><tr><td>5</td><td>配件</td><td>/1/2/5</td></tr></tbody></table></li><li><p>嵌套集合模型就像每个分类都有一个范围，表示它和它的所有子分类的范围。范围用两个数字表示：左值（lft）和右值（rgt）。</p><p>还是相同的分类系统：</p><table><thead><tr><th>id</th><th>name</th><th>lft</th><th>rgt</th></tr></thead><tbody><tr><td>1</td><td>电子产品</td><td>1</td><td>10</td></tr><tr><td>2</td><td>笔记本电脑</td><td>2</td><td>7</td></tr><tr><td>3</td><td>手机</td><td>8</td><td>9</td></tr><tr><td>4</td><td>摄像机</td><td>10</td><td>11</td></tr><tr><td>5</td><td>配件</td><td>3</td><td>4</td></tr></tbody></table><p>这里，<code>lft</code> 和 <code>rgt</code> 表示这个分类和它的子分类在树结构中的位置。</p></li></ol></blockquote><h4 id="with-as">with-as</h4><p><code>WITH</code> 语法（也称为公用表表达式，Common Table Expressions，<strong>CTE</strong>）在 SQL 中用于定义临时的结果集，这些结果集可以在单个查询的上下文中多次引用。它使复杂查询变得更清晰和更易于维护。下面是对 <code>WITH</code> 语法的详细解释和一些示例。</p><p>基本的 <code>WITH</code> 语法如下：</p><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">WITH</span> cte_name <span class="keyword">AS</span> (</span><br><span class="line">    <span class="comment">-- 这里是子查询</span></span><br><span class="line">    <span class="keyword">SELECT</span> column1, column2, ...</span><br><span class="line">    <span class="keyword">FROM</span> table_name</span><br><span class="line">    <span class="keyword">WHERE</span> <span class="keyword">condition</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">SELECT</span> column1, column2, ...</span><br><span class="line"><span class="keyword">FROM</span> cte_name</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">condition</span>;</span><br></pre></td></tr></table></figure></div><p>示例</p><p>假设有一个员工表 <code>emp</code>，我们想要计算每个部门的平均工资，然后找出平均工资高于特定值的部门。</p><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">WITH</span> avg_salaries <span class="keyword">AS</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> deptno, <span class="built_in">AVG</span>(sal) <span class="keyword">AS</span> avg_sal</span><br><span class="line">    <span class="keyword">FROM</span> emp</span><br><span class="line">    <span class="keyword">GROUP</span> <span class="keyword">BY</span> deptno</span><br><span class="line">)</span><br><span class="line"><span class="keyword">SELECT</span> deptno, avg_sal</span><br><span class="line"><span class="keyword">FROM</span> avg_salaries</span><br><span class="line"><span class="keyword">WHERE</span> avg_sal <span class="operator">&gt;</span> <span class="number">5000</span>;</span><br></pre></td></tr></table></figure></div><p>你可以定义多个 CTE，通过逗号分隔它们。</p><h4 id="递归-SQL-的语法">递归 SQL 的语法</h4><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">WITH</span> <span class="keyword">RECURSIVE</span> cte_name (column_list) <span class="keyword">AS</span> (</span><br><span class="line">    <span class="comment">-- 初始查询</span></span><br><span class="line">    <span class="keyword">SELECT</span> ...</span><br><span class="line">    <span class="keyword">UNION</span> <span class="keyword">ALL</span></span><br><span class="line">    <span class="comment">-- 递归查询</span></span><br><span class="line">    <span class="keyword">SELECT</span> ...</span><br><span class="line">    <span class="keyword">FROM</span> cte_name</span><br><span class="line">    <span class="keyword">WHERE</span> ...</span><br><span class="line">)</span><br><span class="line"><span class="comment">-- 主查询</span></span><br><span class="line"><span class="keyword">SELECT</span> ...</span><br><span class="line"><span class="keyword">FROM</span> cte_name</span><br><span class="line"><span class="keyword">WHERE</span> ...;</span><br></pre></td></tr></table></figure></div><blockquote><p>关于column_list</p><p>你的递归CTE的写法是正确的，即使没有显式地写出 <code>column_list</code>。在许多SQL数据库中， <code>column_list</code> 是可选的，如果你在初始查询和递归查询中明确了所选列，那么数据库系统会自动推断出列名。</p><p>不过，为了代码的可读性和维护性，显式地写出 <code>column_list</code> 会更好，特别是在列名较多或结构复杂的情况下。这可以帮助你和其他阅读代码的人更清楚地了解CTE的输出列结构。</p><p>你可以显式地写出 <code>column_list</code>，像这样：</p><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">WITH</span> <span class="keyword">RECURSIVE</span> DepartmentHierarchy (dept_id, parent_dept_id, dept_name, level) <span class="keyword">AS</span> (</span><br><span class="line">    <span class="comment">-- 初始查询：选择顶级部门（没有父部门）作为起点</span></span><br><span class="line">    <span class="keyword">SELECT</span> dept_id, parent_dept_id, dept_name, <span class="number">1</span> <span class="keyword">AS</span> level</span><br><span class="line">    <span class="keyword">FROM</span> Departments</span><br><span class="line">    <span class="keyword">WHERE</span> parent_dept_id <span class="keyword">IS</span> <span class="keyword">NULL</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">UNION</span> <span class="keyword">ALL</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">-- 递归查询：连接上一级部门和当前部门</span></span><br><span class="line">    <span class="keyword">SELECT</span> d.dept_id, d.parent_dept_id, d.dept_name, dh.level <span class="operator">+</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">FROM</span> Departments d</span><br><span class="line">    <span class="keyword">JOIN</span> DepartmentHierarchy dh <span class="keyword">ON</span> d.parent_dept_id <span class="operator">=</span> dh.dept_id</span><br><span class="line">)</span><br><span class="line"><span class="comment">-- 主查询：查询所有部门及其层级关系</span></span><br><span class="line"><span class="keyword">SELECT</span> dept_id, parent_dept_id, dept_name, level</span><br><span class="line"><span class="keyword">FROM</span> DepartmentHierarchy</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> level, dept_id;</span><br></pre></td></tr></table></figure></div><p>这样写的好处是：</p><ol><li><strong>明确性</strong>：清楚地定义了CTE的输出列。</li><li><strong>一致性</strong>：确保初始查询和递归查询的列名一致。</li><li><strong>可读性</strong>：提高代码的可读性，使得其他人更容易理解。</li></ol><p>总结来说，虽然不显式写出 <code>column_list</code> 在大多数情况下也是正确的，但显式地写出它有助于提高代码的清晰度和可维护性。</p></blockquote><p><strong>示例</strong></p><p>假设我们有一个部门表 <code>Departments</code>，其结构如下：</p><table><thead><tr><th>dept_id</th><th>parent_dept_id</th><th>dept_name</th></tr></thead><tbody><tr><td>1</td><td>NULL</td><td>Corporate</td></tr><tr><td>2</td><td>1</td><td>Sales</td></tr><tr><td>3</td><td>1</td><td>HR</td></tr><tr><td>4</td><td>2</td><td>Domestic Sales</td></tr><tr><td>5</td><td>2</td><td>International Sales</td></tr><tr><td>6</td><td>3</td><td>Recruitment</td></tr><tr><td>7</td><td>3</td><td>Employee Relations</td></tr></tbody></table><p>希望查询所有部门及其层级关系</p><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">WITH</span> <span class="keyword">RECURSIVE</span> DepartmentHierarchy <span class="keyword">AS</span> (</span><br><span class="line">    <span class="comment">-- 初始查询：选择顶级部门（没有父部门）作为起点</span></span><br><span class="line">    <span class="keyword">SELECT</span> dept_id, parent_dept_id, dept_name, <span class="number">1</span> <span class="keyword">AS</span> level</span><br><span class="line">    <span class="keyword">FROM</span> Departments</span><br><span class="line">    <span class="keyword">WHERE</span> parent_dept_id <span class="keyword">IS</span> <span class="keyword">NULL</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">UNION</span> <span class="keyword">ALL</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">-- 递归查询：连接上一级部门和当前部门</span></span><br><span class="line">    <span class="keyword">SELECT</span> d.dept_id, d.parent_dept_id, d.dept_name, dh.level <span class="operator">+</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">FROM</span> Departments d</span><br><span class="line">    <span class="keyword">JOIN</span> DepartmentHierarchy dh <span class="keyword">ON</span> d.parent_dept_id <span class="operator">=</span> dh.dept_id</span><br><span class="line">)</span><br><span class="line"><span class="comment">-- 主查询：查询所有部门及其层级关系</span></span><br><span class="line"><span class="keyword">SELECT</span> dept_id, parent_dept_id, dept_name, level</span><br><span class="line"><span class="keyword">FROM</span> DepartmentHierarchy</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> level, dept_id;</span><br></pre></td></tr></table></figure></div><h4 id="关于递归查询的终止">关于递归查询的终止</h4><p>递归查询的结束条件由以下两部分决定：</p><ol><li><strong>递归查询部分的 <code>WHERE</code> 子句</strong>：用于控制递归的深度或范围。</li><li><strong>数据本身的结构</strong>：当没有更多的记录满足递归条件时，递归自然结束。</li></ol><p><u><strong>1.递归查询部分的 <code>WHERE</code> 子句</strong></u></p><p>在递归 CTE 中，<code>WHERE</code> 子句可以限制递归的范围或深度。例如，你可以通过 <code>WHERE</code> 子句限制递归的深度，以避免无限递归。虽然在你的示例中没有使用 <code>WHERE</code> 子句来限制递归，但在某些情况下，添加这样的限制可能是必要的。</p><p>示例：限制递归深度</p><p>假设我们希望限制部门层级的递归深度为3层，可以使用以下查询：</p><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">WITH</span> <span class="keyword">RECURSIVE</span> DepartmentHierarchy <span class="keyword">AS</span> (</span><br><span class="line">    <span class="comment">-- 初始查询：选择顶级部门（没有父部门）作为起点</span></span><br><span class="line">    <span class="keyword">SELECT</span> dept_id, parent_dept_id, dept_name, <span class="number">1</span> <span class="keyword">AS</span> level</span><br><span class="line">    <span class="keyword">FROM</span> Departments</span><br><span class="line">    <span class="keyword">WHERE</span> parent_dept_id <span class="keyword">IS</span> <span class="keyword">NULL</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">UNION</span> <span class="keyword">ALL</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">-- 递归查询：连接上一级部门和当前部门，限制层级深度为3</span></span><br><span class="line">    <span class="keyword">SELECT</span> d.dept_id, d.parent_dept_id, d.dept_name, dh.level <span class="operator">+</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">FROM</span> Departments d</span><br><span class="line">    <span class="keyword">JOIN</span> DepartmentHierarchy dh <span class="keyword">ON</span> d.parent_dept_id <span class="operator">=</span> dh.dept_id</span><br><span class="line">    <span class="keyword">WHERE</span> dh.level <span class="operator">&lt;</span> <span class="number">3</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">-- 主查询：查询所有部门及其层级关系</span></span><br><span class="line"><span class="keyword">SELECT</span> dept_id, parent_dept_id, dept_name, level</span><br><span class="line"><span class="keyword">FROM</span> DepartmentHierarchy</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> level, dept_id;</span><br></pre></td></tr></table></figure></div><p>在这个查询中，递归查询的 <code>WHERE dh.level &lt; 3</code> 子句限制了递归的深度，确保不会超过3层。</p><p><u><strong>2. 数据本身的结构</strong></u></p><p>即使没有显式的结束条件，递归查询也会根据数据结构自然结束。当递归查询中没有新的记录生成时，递归就会自动结束。在你的示例中，每次递归都从 <code>Departments</code> 表中选择子部门，直到没有更多的子部门可以选择为止。</p><p>考虑以下数据结构：</p><table><thead><tr><th>dept_id</th><th>parent_dept_id</th><th>dept_name</th></tr></thead><tbody><tr><td>1</td><td>NULL</td><td>Corporate</td></tr><tr><td>2</td><td>1</td><td>Sales</td></tr><tr><td>3</td><td>1</td><td>HR</td></tr><tr><td>4</td><td>2</td><td>Domestic Sales</td></tr><tr><td>5</td><td>2</td><td>International Sales</td></tr><tr><td>6</td><td>3</td><td>Recruitment</td></tr><tr><td>7</td><td>3</td><td>Employee Relations</td></tr></tbody></table><p>在上述数据中，部门4、5、6、7没有子部门，因此递归在达到这些部门时自然结束。</p><p><strong>递归 CTE 工作机制示意</strong></p><ol><li><strong>初始查询</strong>：找到顶级部门（没有父部门），作为递归的起点。</li><li><strong>递归查询</strong>：每次递归查询从上一步的结果集中选择子部门。</li><li><strong>结束条件</strong>：<ul><li>显式结束条件：如 <code>WHERE dh.level &lt; 3</code> 限制递归深度。</li><li>隐式结束条件：当没有更多记录满足递归条件时，递归自然结束。</li></ul></li></ol><h2 id="B树">B树</h2><h3 id="背景-B树与磁盘">背景-B树与磁盘</h3><p>扇出（fanout）：每个节点允许最大的子节点</p><p><strong>高扇出</strong>，以改善临近键的数据局限性；<strong>低高度</strong>，以减少遍历期间的寻道次数</p><p>B树（B-Tree）是一种平衡树数据结构，广泛用于数据库和文件系统中。它的设计目标是减少磁盘访问次数，提高大规模数据存取的效率。以下是B树与磁盘以及寻道之间的关系：</p><h4 id="B树结构和磁盘的关系">B树结构和磁盘的关系</h4><h4 id="块结构与分页">块结构与分页</h4><ul><li><strong>节点大小与磁盘块大小匹配</strong>：B树的每个节点大小通常与磁盘的块大小（或页大小）匹配。这样，每次从磁盘读取一个节点时，可以充分利用磁盘的读写效率，因为一次I/O操作能够读取或写入完整的节点。</li><li><strong>减少磁盘I/O次数</strong>：由于B树具有较高的扇出（即每个节点可以有多个子节点），树的高度相对较低。这意味着查找、插入或删除操作所需的磁盘访问次数较少，从而减少了I/O操作的开销。</li></ul><h4 id="B树与寻道的关系">B树与寻道的关系</h4><h4 id="寻道时间">寻道时间</h4><ul><li><strong>降低寻道次数</strong>：B树通过其平衡性和高扇出特性，显著减少了需要访问的节点数量，进而降低了磁盘寻道的次数。寻道时间是机械硬盘中将磁头移动到目标轨道所需的时间，是磁盘访问延迟的一个重要组成部分。</li></ul><blockquote><p><strong><u>B树构建了一个快速导航和定位搜索项的层次结构，达到这个目标需要高扇出，低树高</u></strong></p></blockquote><h3 id="B树结构">B树结构</h3><p>概念、插入：<a class="link" href="https://www.bilibili.com/video/BV1tJ4m1w7yR/?spm_id_from=333.788&amp;vd_source=54bdc0734ba281535b1404bbbce896ef">https://www.bilibili.com/video/BV1tJ4m1w7yR/?spm_id_from=333.788&amp;vd_source=54bdc0734ba281535b1404bbbce896ef <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p><p>删除：<a class="link" href="https://www.bilibili.com/video/BV1JU411d7iY/?spm_id_from=333.788&amp;vd_source=54bdc0734ba281535b1404bbbce896ef">https://www.bilibili.com/video/BV1JU411d7iY/?spm_id_from=333.788&amp;vd_source=54bdc0734ba281535b1404bbbce896ef <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p><p><strong>B树：多叉平衡搜索树</strong></p><p>B树需要满足三个特点(m阶B树就是最多有m个分支)</p><img lazyload src="/images/loading.svg" data-src="24-Spring-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%BC%80%E5%8F%91%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20240616232633809.png" alt="image-20240616232633809" style="zoom: 25%;"> <blockquote><p>上取整</p></blockquote><p>内存与硬盘（并且会有查找失败的可能</p><img lazyload src="/images/loading.svg" data-src="24-Spring-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%BC%80%E5%8F%91%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20240616232911847.png" alt="image-20240616232911847" style="zoom: 67%;"> <p><strong>B 树 与 B+树两者有何异同呢？</strong></p><ul><li>B 树的所有节点既存放键(key) 也存放数据(data)，而 B+树只有叶子节点存放 key 和 data，其他内节点只存放 key。</li><li>B 树的叶子节点都是独立的;B+树的叶子节点有一条引用链指向与它相邻的叶子节点。</li><li><strong>B 树的检索的过程</strong>相当于对范围内的每个节点的关键字做二分查找，**可能还没有到达叶子节点，检索就结束了。**而 <strong>B+树的检索效率</strong>就很稳定了，任何查找都是从根节点到叶子节点的过程，叶子节点的顺序检索很明显。</li><li>在 B 树中进行范围查询时，首先找到要查找的下限，然后对 B 树进行中序遍历，直到找到查找的上限；而 B+树的范围查询，只需要对链表进行遍历即可。</li></ul><p>综上，B+树与 B 树相比，具备更少的 IO 次数、更稳定的查询效率和更适于范围查询这些优势。</p><h3 id="B-树的节点分裂（叶节点）">B+树的节点分裂（叶节点）</h3><p><strong><u>B+树 叶节点 分裂 选一个移上去就行，需要复制，因为是非叶结点</u></strong></p><p>以下是4阶B树插入11：N是4-1=3</p><p><img lazyload src="/images/loading.svg" data-src="24-Spring-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%BC%80%E5%8F%91%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20240616235206850.png" alt="image-20240616235206850"></p><blockquote><p>这应该是B+树</p><p><img lazyload src="/images/loading.svg" data-src="24-Spring-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%BC%80%E5%8F%91%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20240616234710682.png" alt="image-20240616234710682"></p></blockquote><p>**Step 1: **查找算法定位目标叶节点，并将新值关联</p><p><strong>Step 2:</strong> 有空就插⼊，没空就叫“节点溢出”overflow，必须分裂</p><ol><li>C1:叶节点：只能放N个值（阶数-1）</li><li>C2:非叶节点：指针超过N+1（KEY也是只能N个）</li></ol><p>**Step 3: **分裂——分配新节点，将⼀半元素从原分裂节点传输给它，并添加它的第⼀个键和指向⽗节点的指针，这时候，键被提升了（promote）</p><p>执⾏分裂的数组下标称之为分裂点（也叫中点），分裂点之后的所有元素被传输到新创建的兄弟节点</p><blockquote><p>11插不进去，所以要分裂，先把原来的分裂下，13提上去</p></blockquote><h3 id="B-树的节点分裂（非叶节点）">B+树的节点分裂（非叶节点）</h3><p><img lazyload src="/images/loading.svg" data-src="24-Spring-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%BC%80%E5%8F%91%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20240616235311923.png" alt="image-20240616235311923"></p><p><strong><u>B+树 非叶节点 分裂选一个直接移上去就行，不需要复制，因为是非叶结点</u></strong></p><h3 id="B-树的叶节点合并（删除16后）">B+树的叶节点合并（删除16后）</h3><p><strong>如果是删除16</strong></p><p>删除可能会要节点合并</p><blockquote><p>删除会出现<strong>下溢出</strong>，也就是删完节点太少了，相邻加起来小于某个值了</p></blockquote><img lazyload src="/images/loading.svg" data-src="24-Spring-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%BC%80%E5%8F%91%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20240617000237631.png" alt="image-20240617000237631" style="zoom: 67%;"> <p>对于叶节点：两个相邻节点中的键值对数量 小于或等于 N</p><p>对于非叶节点：两个相邻节点中指针的数量 小于或等于 N+1（感觉是一个意思）</p><p><strong>如果是删除20</strong></p><p>⼀般50%是树状结构节点占用率的阈值</p><p>如果是删除20，那么20消失就行了</p><h3 id="B-树的非叶节点合并（删除10后）">B+树的非叶节点合并（删除10后）</h3><img lazyload src="/images/loading.svg" data-src="24-Spring-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%BC%80%E5%8F%91%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20240617003550839.png" alt="image-20240617003550839" style="zoom:50%;"> <h3 id="B树的分裂（插入）-合并（删除）">B树的分裂（插入）/合并（删除）</h3><p><strong>B树</strong>的<strong>非叶结点</strong><u>分裂合并</u>与<strong>B+树</strong>的<strong>非叶结点</strong><u>分裂合并</u>是一致的</p><p><strong>B树</strong>的<strong>非叶结点</strong><u>分裂合并</u>与<strong>B树</strong>的<strong>叶结点</strong><u>分裂合并</u>是一致的</p><p>叶节点自行领会，B+树的叶都得复制之类的，大致理解下</p><h2 id="分区分表分库-2">分区分表分库</h2><p>• 分区</p><ul><li>就是把一张表的数据分成N个区块，在逻辑上看最终只是一张表，但底层是由N个物理区块组成的</li></ul><p>• 分表（手搓分区）</p><ul><li>就是把一张表按一定的规则分解成N个具有独立存储空间的实体表</li><li>系统读写时需要根据定义好的规则得到对应的字表明，然后操作它</li></ul><p>• 分库</p><blockquote><p>04 B+树结构的物理实现</p></blockquote><p>用来解决下列问题：</p><ul><li>I/O瓶颈<ul><li>热点数据太多，数据缓存不够，每次查询产生大量I/O —— 分库，垂直分表</li><li>网络I/O瓶颈，带宽不够，连接数过多 —— 分库</li></ul></li><li>CPU瓶颈<ul><li>SQL问题，join、group by、order by —— SQL优化，构建索引</li><li>单表数据量过大，扫描行太多，SQL效率过低 —— 水平分表</li></ul></li></ul><h3 id="分区">分区</h3><p>一张表的数据分为N个区块，在逻辑上看最终只是一张表，但底层是由N个物理区块组成的</p><h4 id="要解决的问题">要解决的问题</h4><p>分区是一种数据分组方式，数据分组可以：</p><p>1、提高<strong>并发性</strong>和<strong>并行性</strong></p><p>2、扩增系统架构的<strong>可伸缩性</strong></p><p>分区目标：</p><p>分区想做到的：查询时可以过滤掉很多无用分区、分区本身不会带来很多代价</p><h4 id="面对两大问题">面对两大问题</h4><p><img lazyload src="/images/loading.svg" data-src="24-Spring-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%BC%80%E5%8F%91%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20240617150424273.png" alt="image-20240617150424273"></p><p><img lazyload src="/images/loading.svg" data-src="24-Spring-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%BC%80%E5%8F%91%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20240617150525113.png" alt="image-20240617150525113"></p><p><img lazyload src="/images/loading.svg" data-src="24-Spring-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%BC%80%E5%8F%91%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20240617150816868.png" alt="image-20240617150816868"></p><blockquote><p>• NULL值会使分区过滤无效（PATITION by RANGE COLUMN（order_date））</p><p>• 分区列和索引列不匹配（没有索引，或关联查询时关联条件不匹配索引）</p><p>• 选择分区的成本可能很高（范围分区的成本需要注意）</p><p><strong>• 打开并锁住所有底层表的成本可能很高（开销和分区类型无关，主键查找单行会带来明显开销）</strong></p><p>• 维护分区的成本可能很高</p></blockquote><h3 id="分库表">分库表</h3><p><strong>分区</strong>：将一个表划分成多个较小的部分（分区），逻辑上是一个表，物理上有多个部分。</p><p><strong>分表</strong>：将一个表水平拆分成多个独立的子表，可以分布在同一个或多个数据库实例中。</p><p><strong>分区表</strong>：将一个表按某种规则划分成多个分区，逻辑上是一个表，但在物理上存储在不同的区域。这是分区技术在一个表上的具体应用。</p><blockquote><p>感觉<strong>分区表</strong>就是一个管理底层表的东西？</p></blockquote><p><img lazyload src="/images/loading.svg" data-src="24-Spring-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%BC%80%E5%8F%91%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20240617151531213.png" alt="image-20240617151531213"></p><h3 id="分表">分表</h3><p>一张表按照一定规则分为N个独立存储空间的实体表，系统读写时需要根据定义好的规则得到对应的字表明，然后操作</p><h4 id="解决什么问题">解决什么问题</h4><ul><li><p>分表后单表的并发能力提高了，磁盘I/O性能也提高了，写操作效率提高了</p><blockquote><p>因为单表的并发量小了，不用的表在不同的磁盘上，可以同时读写了</p></blockquote></li><li><p>数据分布在不同的文件，磁盘I/O性能提高了</p><blockquote><p>不用的表在不同的磁盘上，可以同时读写了</p></blockquote></li><li><p>读写锁影响的数据量变小</p><blockquote><p>当一个分表在进行写操作时，只会锁定这个小表，不会影响到其他分表的读写操作。</p></blockquote></li><li><p>插入数据库需要重新建立索引的数据量减少</p></li></ul><h4 id="会遇到的问题">会遇到的问题</h4><p><u><strong>如何保证插入不同表的多条记录（事务）要么同时成功，要么同时失败？</strong></u></p><ul><li><p>TCC 柔性事务</p><blockquote><p>TCC柔性事务的三个步骤包括：首先，在<strong>Try</strong>阶段，系统会预留必要的资源，但不进行最终的操作，比如预留库存、生成临时订单和冻结用户余额。接着，在<strong>Confirm</strong>阶段，如果所有尝试步骤都成功，系统将正式执行这些操作，真正扣减库存、生成正式订单并扣款。最后，如果任何尝试步骤失败，系统会进入<strong>Cancel</strong>阶段，取消预留的资源并恢复原状，比如释放预留库存、取消临时订单和解冻余额。这种机制确保了在分布式系统中，所有相关操作要么全部成功，要么全部失败。</p></blockquote></li></ul><p><u><strong>分表的实现方式（复杂）</strong></u></p><ul><li>需要业务系统配合升级，工作量大</li></ul><p><strong>跨分片查询低效</strong>：使用中间件来支持跨分片查询</p><p>**数据分布不均（数据倾斜）：**使用更好的划分算法，哈希之类的</p><p>**维护和管理复杂性：**自动化运维工具，中间件等</p><blockquote><p>补充 by GPT4o</p><p><strong>3. 全局唯一ID生成</strong>：</p><ul><li><strong>问题</strong>：在多个分表中插入数据时，需要确保每个记录有唯一的标识符（ID）。传统的自增ID可能会在不同的分表中产生冲突。</li><li>解决方案：<ul><li><strong>UUID</strong>：使用全局唯一标识符（UUID），但UUID长度较长，且无序，影响性能。</li><li><strong>雪花算法（Snowflake）</strong>：生成全局唯一的、有序的ID，可以保证分布式系统中的唯一性和有序性。</li><li><strong>分布式ID生成服务</strong>：如Twitter的Snowflake、Flink的Flink ID等。</li></ul></li></ul><p><strong>4. 跨分片查询</strong>：</p><ul><li><strong>问题</strong>：有时需要对多个分表的数据进行联合查询（如统计分析），这类查询在分表环境中变得复杂和低效。</li><li>解决方案：<ul><li><strong>应用层合并</strong>：在应用层对各个分表的查询结果进行合并。</li><li><strong>中间件</strong>：使用数据库中间件（如ShardingSphere、Vitess）来支持跨分片查询。</li><li><strong>预计算和缓存</strong>：预先计算常用的统计结果，存储在缓存或单独的聚合表中。</li></ul></li></ul><p><strong>5. 数据分布不均（数据倾斜）</strong>：</p><ul><li><strong>问题</strong>：如果分表规则不合理，可能导致部分分表的数据量过大或过小，造成负载不均衡，影响系统性能。</li><li>解决方案：<ul><li><strong>合理的分片键</strong>：选择合适的分片键，保证数据均匀分布。</li><li><strong>动态分片</strong>：根据数据增长动态调整分片策略。</li><li><strong>哈希分片</strong>：使用哈希算法进行分片，通常能保证数据的均匀分布。</li></ul></li></ul><p><strong>6. 维护和管理复杂性</strong>：</p><ul><li><strong>问题</strong>：分表增加了数据库的维护和管理难度，如备份、恢复、监控等操作变得复杂。</li><li>解决方案：<ul><li><strong>自动化运维工具</strong>：使用自动化工具进行分表的管理和运维，如备份和恢复脚本、监控系统等。</li><li><strong>数据库中间件</strong>：使用中间件简化分表的管理工作。</li></ul></li></ul><p><strong>7. 跨分片的事务管理</strong>：</p><ul><li><strong>问题</strong>：传统的单机事务无法跨多个分表执行，需要分布式事务支持。</li><li>解决方案：<ul><li><strong>TCC柔性事务</strong>：如你所提到的，Try-Confirm-Cancel模式。</li><li><strong>XA协议</strong>：使用支持XA协议的数据库，进行两阶段提交。</li><li><strong>本地事务+补偿机制</strong>：先执行本地事务，再通过补偿机制确保最终一致性。</li></ul></li></ul><p><strong>8. 数据迁移和扩容</strong>：</p><ul><li><strong>问题</strong>：随着数据量增长，可能需要增加新的分表或重新分配数据，这些操作需要复杂的数据迁移。</li><li>解决方案：<ul><li><strong>分片重平衡</strong>：使用工具进行分片重平衡，自动将数据迁移到新的分片。</li><li><strong>中间件支持</strong>：使用支持动态扩容和数据迁移的中间件。</li></ul></li></ul><p><strong>9. 索引管理</strong>：</p><ul><li><strong>问题</strong>：每个分表的索引需要单独管理，且在查询时需要考虑跨表的索引优化。</li><li>解决方案：<ul><li><strong>统一索引策略</strong>：在所有分表上使用相同的索引策略，确保查询优化的一致性。</li><li><strong>全局索引</strong>：使用中间件或数据库支持全局索引，优化跨表查询。</li></ul></li></ul></blockquote><h4 id="分区和分表的区别和联系">分区和分表的区别和联系</h4><ul><li><u>目的都是减少数据库的负担，提高表的增删改查效率</u></li><li><u>分区只是一张表的物理存储位置发生变化，分表是将一张表分为多个实体表</u><ul><li>访问量大，数据大，两种配合</li><li>访问量不大，数据大，可以只分区（分表可以提升单表的并发能力，所以访问量不大只分个区也行</li><li>分表可以多库，分区不可以</li></ul></li><li>常见分区分表的策略是类似的</li></ul><h3 id="分库">分库</h3><p><strong>解决什么问题？</strong></p><ul><li>单台DB的存储空间不够</li><li>查询量的增加导致数据库服务器已经没法支撑</li></ul><p><strong>为什么要分库？</strong></p><p>突破单节点数据库服务器的I/O能力限制，解决数据库扩展性的问题</p><p><strong>怎么分库？</strong></p><p><img lazyload src="/images/loading.svg" data-src="24-Spring-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%BC%80%E5%8F%91%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20240617152718689.png" alt="image-20240617152718689"></p><p><strong>会遇到什么问题？</strong></p><p><img lazyload src="/images/loading.svg" data-src="24-Spring-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%BC%80%E5%8F%91%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20240617153056627.png" alt="image-20240617153056627"></p><h2 id="SQL成本计算">SQL成本计算</h2><blockquote><p>SQL解释器</p><ul><li><p>基于成本优化器</p><p>例如基于成本优化器的计算方式</p></li><li><p>基于规则优化器</p></li></ul></blockquote><h3 id="优化最重要的方向：连接">优化最重要的方向：连接</h3><p>连接就是把各个表中的记录都取出来依次进行匹配，并把匹配的组合返回</p><p>驱动表和被驱动表 A join B，A是驱动表</p><h4 id="嵌套循环连接">嵌套循环连接</h4><p>驱动表只访问一次，但被驱动表却可能被多次访问，访问次数取决于对驱动表执行单表查询后的结果集中的记录条数的连接执行方式称之为 嵌套循环连接 ( Nested-Loop Join )</p><blockquote><p>嵌套循环连接通过在外层循环中逐条读取驱动表记录，并在内层循环中查找被驱动表的匹配记录来实现连接。这种逐条匹配的过程类似于嵌套循环，因此得名嵌套循环连接（Nested-Loop Join）。</p></blockquote><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> customers.name, orders.order_id</span><br><span class="line"><span class="keyword">FROM</span> customers</span><br><span class="line"><span class="keyword">JOIN</span> orders <span class="keyword">ON</span> customers.customer_id <span class="operator">=</span> orders.customer_id;</span><br></pre></td></tr></table></figure></div><p>对customers的每一条都访问orders表</p><p><strong><u>一、使用索引加速连接查询</u></strong></p><ol><li><p><strong>被驱动表有索引时</strong>：被驱动表的数据在被驱动表筛选后，会进行多次基于索引的查询以加速连接。</p><blockquote><p>意思就是比如对驱动表的数据每条进行遍历，那每个驱动表的值就可以看作一个常数，然后就使用索引</p></blockquote></li><li><p><strong>多个条件的情况</strong>：如果查询有多个条件，优化器会选择最合适的索引来执行查询。</p></li><li><p><strong>连接查询和过滤条件</strong>：连接查询和过滤条件通常只涉及被驱动表的部分列。因此，在实际工作中，不建议使用<code>*</code>作为查询列表。</p></li></ol><p><strong><u>二、基于块的连接优化</u></strong>：通过减少对被驱动表的多次遍历来提高连接效率（感觉像是倒反天罡</p><img lazyload src="/images/loading.svg" data-src="24-Spring-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%BC%80%E5%8F%91%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20240617133051390.png" alt="image-20240617133051390" style="zoom: 50%;"> <ol><li>尽量减少访问被驱动表的次数（驱动表的记录不会都放入 join buffer，只会将部分列放入）</li><li>join buffer 足够大，就可以一次访问被驱动表完成连接</li><li>join buffer 一般 256KB（相比来看，索引仍然是最好的选择）</li></ol><h3 id="连接小结（总结的还可以">连接小结（总结的还可以</h3><p>• 本质上，连接就是把各个表中的记录都取出来依次进行匹配，并把匹配的组合返回</p><p>• 内连接和外连接的本质都是确定驱动表</p><p>• 嵌套循环连接算法是：驱动表只访问一次，但被驱动表可能会访问多次，访问次数取决于被驱动表执行单表查询后结果集中有多少条记录</p><ol><li><strong>被驱动表会被多次访问</strong>，所以，建立合适的索引用以加快访问速度</li><li><strong>被驱动表很大</strong>，多次访问会导致更多的磁盘 I/O，基于块的嵌套循环算法来缓解</li></ol><h3 id="基于成本的优化器-CBO">基于成本的优化器 CBO</h3><blockquote><p><a class="link" href="https://blog.csdn.net/wangen2010/article/details/100516113">https://blog.csdn.net/wangen2010/article/details/100516113 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p></blockquote><p>要点是<strong>执行计划的成本估算</strong></p><p>基础仍然是规则方案探索</p><p><img lazyload src="/images/loading.svg" data-src="24-Spring-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%BC%80%E5%8F%91%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/1718595481773-21.png" alt="img"></p><h4 id="什么是“成本”">什么是“成本”</h4><ul><li>一个查询有不同的执行方案，它会选择其中成本最低的（也就是代价最低的）</li><li>成本一般有两个方面组成<ul><li>I/O 成本，MyISAM 、 InnoDB 存储引擎都是将数据和索引存储到磁盘的<ul><li>从磁盘到内存的加载，涉及到“物理读写”，这种耗损的时间称之为 I/O 成本</li></ul></li><li>CPU 成本，读取记录，以及检测记录是否满足搜索条件、对结果集排序，称之为 CPU 成本</li></ul></li><li>一般来说，需要确定不同操作，不同算子的成本常数<ul><li><strong>物理读取一个页面</strong>默认成本是 1.0</li><li><strong>逻辑读取</strong>和<strong>检测条件</strong>默认为 0.2</li></ul></li></ul><h4 id="一个单表查询的例子">一个单表查询的例子</h4><p>单表查询，大意指不涉及连接</p><p><strong><u>单表查询成本优化基本步骤：</u></strong></p><ol><li><p>根据搜索条件，<strong>找出所有可能使用的索引</strong></p><blockquote><p><strong>二级索引</strong>就是除了主键索引之外的</p><p>我们分析一下上边查询中涉及到的几个搜索条件：</p><ul><li><code>key1 IN ('a', 'b', 'c')</code>，这个搜索条件可以使用二级索引<code>idx_key1</code>。</li><li><code>key2 &gt; 10 AND key2 &lt; 1000</code>，这个搜索条件可以使用二级索引<code>idx_key2</code>。</li><li><code>key3 &gt; key2</code>，<strong>这个搜索条件的索引列由于没有和常数比较，所以并不能使用到索引。</strong></li><li><code>key_part1 LIKE '%hello%'</code>，<code>key_part1</code>通过<code>LIKE</code>操作符和以通配符开头的字符串做比较，不可以适用索引。</li><li><code>common_field = '123'</code>，由于该列上压根儿没有索引，所以不会用到索引。</li></ul><p>综上所述，上边的查询语句可能用到的索引，也就是<code>possible keys</code>只有<code>idx_key1</code>和<code>idx_key2</code>。</p></blockquote></li><li><p>计算<strong>全表扫描</strong>的代价（row，Data_length)</p><blockquote><p>这两个信息可以通过语句<code>show table status like 'table_name' \ G</code>查询得到</p><ul><li><p><u><strong>Rows</strong></u></p><p>本选项表示表中的记录条数。对于使用<code>MyISAM</code>存储引擎的表来说，该值是准确的，对于使用<code>InnoDB</code>存储引擎的表来说，该值是一个<strong>估计值</strong>。从查询结果我们也可以看出来，由于我们的<code>single_table</code>表是使用<code>InnoDB</code>存储引擎的，所以虽然实际上表中有10000条记录，但是<code>SHOW TABLE STATUS</code>显示的<code>Rows</code>值只有9693条记录。</p></li><li><p><u><strong>Data_length</strong></u></p><p>本选项表示表占用的存储空间字节数。使用<code>MyISAM</code>存储引擎的表来说，该值就是数据文件的大小，对于使用<code>InnoDB</code>存储引擎的表来说，该值就相当于聚簇索引占用的存储空间大小，也就是说可以这样计算该值的大小：</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Data_length = 聚簇索引的页面数量 x 每个页面的大小</span><br></pre></td></tr></table></figure></div><p>我们的<code>single_table</code>使用默认<code>16KB</code>的页面大小，而上边查询结果显示<code>Data_length</code>的值是<code>1589248</code>，所以我们可以反向来推导出<code>聚簇索引的页面数量</code>：</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">聚簇索引的页面数量 = 1589248 ÷ 16 ÷ 1024 = 97</span><br></pre></td></tr></table></figure></div></li></ul><p>我们现在已经得到了聚簇索引占用的页面数量以及该表记录数的估计值</p></blockquote></li><li><p>计算<strong>使用不同索引的代价</strong></p></li><li><p>对比各种执行方案的代价，找出成本最低的那一个</p></li></ol><img lazyload src="/images/loading.svg" data-src="24-Spring-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%BC%80%E5%8F%91%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20240617125503524.png" alt="image-20240617125503524" style="zoom:50%;"> <blockquote><p>1.1，1.0这些都是常数，加一些偏置值而已</p></blockquote><h3 id="基于规则的优化器-RBO">基于规则的优化器 RBO</h3><p>要点是**<u>结构匹配和替换</u>**</p><ul><li>应用规则的算法<strong>一般需要先在关系代数结构上匹配一部分局部结构</strong></li><li>再根据结构的特点进行辩护乃至替换操作</li></ul><h4 id="基于规则的优化算法">基于规则的优化算法</h4><ul><li>变化规则的选择，哪些规则应该被应用，以什么顺序被使用？</li><li>变换效果的评价，经过变换的查询性能的评估，算子效率和数据集</li><li>所以，一般固定规则一定会构建人工的优先级顺序 =&gt; 通用性下降，适应范围变窄</li></ul><h4 id="优先级顺序和通用性">优先级顺序和通用性</h4><p>由于规则的应用顺序会影响优化效果，因此，优化器通常会给规则分配一个优先级顺序。这个优先级顺序是基于经验和常见查询模式人工设置的。虽然这种方法可以在特定场景下提高查询效率，但也有其局限性：</p><ul><li><strong>通用性下降</strong>：由于规则的优先级是固定的，优化器在某些情况下可能无法找到最优的查询执行计划。</li><li><strong>适应范围窄</strong>：固定优先级顺序意味着优化器在面对不同类型的查询时，可能不能很好地适应多变的查询模式和数据特性。</li></ul><h4 id="一个例子（GPT）">一个例子（GPT）</h4><img lazyload src="/images/loading.svg" data-src="24-Spring-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%BC%80%E5%8F%91%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20240617113254543.png" alt="image-20240617113254543" style="zoom:50%;"> <h2 id="日志-2">日志</h2><blockquote><p><a class="link" href="https://www.cnblogs.com/xiaolincoding/p/16396502.html">https://www.cnblogs.com/xiaolincoding/p/16396502.html <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p></blockquote><h3 id="ACID">ACID</h3><ul><li><strong>原子性（Atomicity）：事务的本质要求</strong><ul><li><code>单个事务，为一个不可分割的最小工作单元</code>，整个事务中的所有操作要么全部commit成功，要么全部失败rollback，对于一个事务来说，不可能只执行其中的一部分SQL操作，这就是事务的原子性。</li></ul></li><li><strong>一致性（Consistency）：数据完整的要求</strong><ul><li>定义最弱的属性，也是<u>唯一一个可以由开发者控制而不是仅凭数据库自身保证的属性</u></li><li>一致性指的是在事务执行前后，数据库必须从一个一致状态转变为另一个一致状态。也就是说，任何事务都必须使数据库保持一致的状态。具体来说，一致性要求：<ul><li><strong>数据库规则的满足</strong>：事务执行后，所有数据库的完整性约束（如余额不能为负数）都必须满足。</li><li><strong>数据的合法性</strong>：事务执行后，数据库中的数据必须是合法的，不会出现不合法的数据。</li><li><strong>正确的状态转变</strong>：事务执行后，数据库状态的变化是正确的，从一个正确的状态变为另一个正确的状态。</li></ul></li></ul></li><li><strong>隔离性（Isolation）：并发的本质要求</strong><ul><li>通常来说，一个事务所做的修改在最终提交以前，对其他事务是不可见的。在前面的例子中，当执行完第三条语句、第四条语句还未开始时，此时有另外一个账户查询余额SQL开始运行，则其看到的信用卡账户的余额并没有被减去100元。后面我们讨论隔离级别(Isolation level)的时候，会发现为什么我们要说事务通常来说是不可见的</li></ul></li><li><strong>持久性（Durability）：数据库系统的本质要求</strong><ul><li><u>一旦事务提交，那么对其所做的修改就会永久保存在数据库中</u>，此时即使系统崩溃，修改的数据也不会丢失</li></ul></li></ul><h3 id="缓冲区管理">缓冲区管理</h3><p><img lazyload src="/images/loading.svg" data-src="24-Spring-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%BC%80%E5%8F%91%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20240617092103635.png" alt="image-20240617092103635"></p><p><img lazyload src="/images/loading.svg" data-src="24-Spring-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%BC%80%E5%8F%91%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20240617092119912.png" alt="image-20240617092119912"></p><h3 id="请求页的基本步骤">请求页的基本步骤</h3><ul><li>检查该页是否已被缓存<ol><li>如果该页在缓存中，直接返回缓存的页；</li><li>如果没有缓存，则页缓存会将其逻辑地址或页id转化为物理地址，加载到内存，并返回；<ol><li>一旦返回，这个存有缓存页内容的缓冲区就被称为被<strong>引用的（referenced）</strong></li><li>用完之后将其归还给页缓存或解除引用</li></ol></li></ol></li><li>若想让页缓存不要换出某些页，则可以将其固定（pin）</li><li>如果某些页被修改，标记为脏页（dirty page），脏页表示内容与磁盘不同步，换出时必须将其刷写到磁盘</li></ul><h3 id="恢复Recovery">恢复Recovery</h3><p><img lazyload src="/images/loading.svg" data-src="24-Spring-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%BC%80%E5%8F%91%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20240617093143299.png" alt="image-20240617093143299"></p><blockquote><p>意思是本来事务提交是在缓存完成就修改就事务提交了，这样能快一点，但是就会存在<strong>在提交和写入磁盘</strong>之间崩溃的可能，无法恢复，违反持久性；所以一个方案是使用写入disk才算完成，这样固然可以，但是显然太麻烦，因此redo日志诞生。</p></blockquote><h3 id="Redo-log（重做日志）-的特点">Redo log（重做日志） 的特点</h3><ol><li>占用空间很小</li><li>顺序写入磁盘（顺序 I/O）</li></ol><h3 id="redo日志格式">redo日志格式</h3><blockquote><p>比ppt清晰</p><p><a class="link" href="https://www.cnblogs.com/kuangtf/articles/16353184.html#4log-sequeue-number">https://www.cnblogs.com/kuangtf/articles/16353184.html#4log-sequeue-number <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p></blockquote><p>Redo 日志格式不同数据库有不同的定义，但整体的分类就这三种：</p><ol><li>记录具体位置的物理修改</li><li>记录一个 page 的全部修改</li><li>记录操作（执行恢复的参数）</li></ol><p>一些数据库也会做一些压缩操作，比如 space id，page number 等</p><p><img lazyload src="/images/loading.svg" data-src="24-Spring-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%BC%80%E5%8F%91%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/1718588747996-1.png" alt="img"></p><blockquote><p>对应第一种</p></blockquote><p><img lazyload src="/images/loading.svg" data-src="24-Spring-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%BC%80%E5%8F%91%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20240617095405672.png" alt="image-20240617095405672"></p><blockquote><p>方案2大体对应第二种</p></blockquote><p><img lazyload src="/images/loading.svg" data-src="24-Spring-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%BC%80%E5%8F%91%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20240617095801000.png" alt="image-20240617095801000"></p><blockquote><p>大体上是第三种</p></blockquote><h3 id="Mini-Transaction">Mini-Transaction</h3><p>以组的形式写入 redo 日志</p><p>• 一组操作，一组日志的不可分割性</p><p>• 索引、基本表、聚簇、二级索引、目录等多个页的操作</p><p><strong>MLOG_MULTI_REC_END</strong></p><p><img lazyload src="/images/loading.svg" data-src="24-Spring-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%BC%80%E5%8F%91%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/1718589881176-4.png" alt="img"></p><h3 id="redo-log-block">redo log block</h3><p><img lazyload src="/images/loading.svg" data-src="24-Spring-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%BC%80%E5%8F%91%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/1718589935838-11.png" alt="img"></p><blockquote><p>512B，512K也太大了</p></blockquote><p><img lazyload src="/images/loading.svg" data-src="24-Spring-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%BC%80%E5%8F%91%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/1718589956060-14.png" alt="img"></p><h3 id="redo-log-的刷盘时机">redo log 的刷盘时机</h3><p>redo log刷盘是指将这些日志从内存中的log buffer（日志缓冲区）写入磁盘的过程。这个过程确保了数据的<strong>持久性</strong>，即使在系统崩溃或宕机后，数据库也能通过这些日志恢复到一致的状态。</p><ul><li>log buffer空间不足（50%的阈值）</li><li><strong>事务提交时</strong></li><li><strong>脏页刷新</strong></li><li>定时进程，固定频率刷新（1s，log buffer中的redo log刷新到硬盘）</li><li>正常关闭服务器</li></ul><h3 id="lsn值（log-sequence-number）">lsn值（log sequence number）</h3><p><strong><u>check point的步骤</u></strong></p><ol><li><p>计算当前系统可以被覆盖的redo日志对应的lsn值最大是多少</p></li><li><p>将信息写入日志文件的管理信息中，记录check point的操作</p></li></ol><blockquote><p>Checkpoint是数据库系统中的一个关键机制，用于确保数据一致性和加速恢复过程。执行checkpoint时，数据库会做以下事情：</p><ol><li><strong>刷新脏页</strong>：将所有脏页（内存中被修改但尚未写入磁盘的数据页）写入磁盘。</li><li><strong>记录LSN</strong>：将当前的LSN记录在某个稳定存储位置（如日志文件头部），这标志着所有在这个LSN之前的变更都已经持久化到磁盘。(<strong>checkpoint_lsn</strong>)</li></ol></blockquote><p><img lazyload src="/images/loading.svg" data-src="24-Spring-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%BC%80%E5%8F%91%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20240617102214425.png" alt="image-20240617102214425"></p><blockquote><p>checkpoint就是之前的都完成了，lsn是目前有多少了，最新的一个增长，应该跟buf_free对应的？</p></blockquote><h3 id="恢复">恢复</h3><p><a class="link" href="https://www.cnblogs.com/kuangtf/articles/16353184.html#4log-sequeue-number">https://www.cnblogs.com/kuangtf/articles/16353184.html#4log-sequeue-number <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p><p><strong>博客讲的很详细</strong></p><p>小trick就是使用Hash表，相同的页面不用多次取回</p><p><img lazyload src="/images/loading.svg" data-src="24-Spring-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%BC%80%E5%8F%91%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20240617103555399.png" alt="image-20240617103555399"></p><h3 id="Undo日志（Undo-log）">Undo日志（Undo log）</h3><ul><li>事务保证原子性靠的就是日志<ul><li>错误：服务器、操作系统、断电</li><li>手动或自动rollback</li></ul></li><li>对每一条记录进行改动的时候，需要留一手<ul><li>INSERT，记录主键，rollback就删除主键</li><li>DELECT，记录内容，rollback恢复记录</li><li>UPDATE，记录内容，rollback恢复记录</li></ul></li></ul><p>每一个事务对数据的修改都会被记录到 undo log ，当执行事务过程中出现错误或者需要执行回滚操作的话，MySQL 可以利用 undo log 将数据恢复到事务开始之前的状态。</p><p><strong>undo log 属于逻辑日志，记录的是 SQL 语句</strong></p><p>比如说事务执行一条 DELETE 语句，那 undo log 就会记录一条相对应的 INSERT 语句。同时，undo log 的信息也会被记录到 redo log 中，因为 undo log 也要实现持久性保护。<strong>并且，undo-log 本身是会被删除清理的，例如 INSERT 操作，在事务提交之后就可以清除掉了；UPDATE/DELETE 操作在事务提交不会立即删除，会加入 history list，由后台线程 purge 进行清理。</strong></p><h3 id="Write-Ahead-Log-WAL（GPT）">Write-Ahead Log WAL（GPT）</h3><p>基本原理</p><ul><li><strong>保证数据库系统的持久性语义，即操作日志必须在修改页之前写入磁盘。</strong></li><li><strong>系统崩溃时，通过操作日志重建内存中丢失的更改。</strong></li></ul><p>性能优化</p><ul><li>后台独立进程循环刷写（如PostgreSQL的后台刷写器）。</li><li>定期执行Checkpoint操作。</li></ul><p>日志语义</p><ul><li>WAL是仅追加的，已写入内容不可变。</li><li>强制刷盘操作确保事务提交记录完成后才视为“已提交”。</li><li>LSN（Log Sequence Number）唯一且单调递增。</li></ul><h3 id="Redo-log-Undo-log">Redo log &amp; Undo log</h3><ul><li><p><strong>前像（before-image）和后像（after-image）的相互转换</strong></p></li><li><p><strong>Undo：一个事务在执行过程中，还未提交，发生崩溃或者需要回滚</strong></p><p><mark>保障原⼦性、实现MVCC（多版本并发控制）</mark></p><ul><li>Undo log 撤销回滚的日志，记录更新前的数据到undo日志文件中</li><li>Undo日志记录的是操作记录，插入记录主键、删除记录内容、更新记录旧值</li><li>Undo日志只在乎“操作之前”（roll_pointer指针串成链表/版本表，trx_id事务id）</li></ul></li><li><p><strong>Redo：掉电，磁盘I/O崩了，之前提交的记录如何保存（crash-safe 奔溃恢复）</strong></p><p><mark>保障持久性</mark></p><ul><li>事务提交时，未必检查点同步，事务提交成功的标记是——redo日志持久化了</li><li>Redo日志记录的是物理修改，（xxx数据页yyy的偏移量做了zzz的修改/影子页）</li><li>循环写，不用于备份恢复、主从复制，用于掉电等故障恢复——binlog用于全局备份</li></ul></li><li><p>被修改的Undo log本身，也会记录Redo log</p><blockquote><img lazyload src="/images/loading.svg" data-src="24-Spring-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%BC%80%E5%8F%91%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20240617110010159.png" alt="image-20240617110010159" style="zoom: 67%;"> </blockquote></li></ul><h3 id="steal和force策略">steal和force策略</h3><p><img lazyload src="/images/loading.svg" data-src="24-Spring-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%BC%80%E5%8F%91%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20240617110532293.png" alt="image-20240617110532293"></p><blockquote><p>事务提交前能不能刷脏页？能 steal（要undo日志，未能提交的话要恢复）</p><p>事务提交前要不要保证所有的脏页都刷了？不要保证 no-force（要redo日志），要保证 force</p></blockquote><p><img lazyload src="/images/loading.svg" data-src="24-Spring-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%BC%80%E5%8F%91%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20240617110548879.png" alt="image-20240617110548879"></p><h2 id="SQL题目补充（一开始跳了几道">SQL题目补充（一开始跳了几道</h2><blockquote><p>全用mysql，不用oracle吧</p></blockquote><h3 id="Any和All关键字">Any和All关键字</h3><p>其实可以用min/max等价实现</p><p><strong>any/some</strong></p><ol><li>Select * from t1 where m1 &gt; any (select m2 from t2)</li><li>如果子查询结果集存在小于m1列的值，则表达式为true</li><li>Select * from t1 where m1 &gt; (select min(m2) from t2)</li></ol><p><strong>all</strong></p><ol><li>Select * from t1 where m1 &gt; all(select m2 from t2)</li><li>如果子查询的结果集中所有值都小于m1，则表达式为true</li><li>Select * from t1 where m1 &gt; (select max(m2) from t2)</li></ol><h3 id="char-length和length">char_length和length</h3><table><thead><tr><th>example_column</th><th>byte_length</th><th>char_length</th></tr></thead><tbody><tr><td>hello</td><td>5</td><td>5</td></tr><tr><td>你好</td><td>6</td><td>2</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 期末复习 </category>
          
          <category> 数据库开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ZeroSSL-域名SSL配置说明</title>
      <link href="/posts/%E5%AE%9E%E8%B7%B5%E8%AE%B0%E5%BD%95/zerossl-%E5%9F%9F%E5%90%8Dssl%E9%85%8D%E7%BD%AE%E8%AF%B4%E6%98%8E.html"/>
      <url>/posts/%E5%AE%9E%E8%B7%B5%E8%AE%B0%E5%BD%95/zerossl-%E5%9F%9F%E5%90%8Dssl%E9%85%8D%E7%BD%AE%E8%AF%B4%E6%98%8E.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>待完善，先记录下，好不容易理清楚我干了什么</p></blockquote><h2 id="起因">起因</h2><p>收到了ZeroSSL证书即将过期的通知</p><p><img lazyload src="/images/loading.svg" data-src="ZeroSSL-%E5%9F%9F%E5%90%8DSSL%E9%85%8D%E7%BD%AE%E8%AF%B4%E6%98%8E/image-20240613164048436.png" alt="image-20240613164048436"></p><p>于是不得不回顾下当时搞了啥</p><h2 id="流水线配置">流水线配置</h2><p>先看下流水线干了啥</p><div class="highlight-container" data-rel="Yml"><figure class="iseeu highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">variables:</span></span><br><span class="line">  <span class="attr">VITE_API_URL:</span> <span class="string">&quot;https://49.235.142.226:8701/api&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">stages:</span> <span class="comment"># List of stages for jobs, and their order of execution</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">build</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">test</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">deploy</span></span><br><span class="line"></span><br><span class="line"><span class="attr">docker-build-job:</span></span><br><span class="line">  <span class="attr">stage:</span> <span class="string">build</span></span><br><span class="line">  <span class="attr">tags:</span> [ <span class="string">nancy</span> ]</span><br><span class="line">  <span class="attr">script:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">docker</span> <span class="string">build</span> <span class="string">--build-arg</span> <span class="string">VITE_API_URL=&quot;$VITE_API_URL&quot;</span> <span class="string">-t</span> <span class="string">front:latest</span> <span class="string">-f</span> <span class="string">INeedGithub/Dockerfile</span> <span class="string">INeedGithub</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">docker</span> <span class="string">save</span> <span class="string">-o</span> <span class="string">front.tar</span> <span class="string">front:latest</span></span><br><span class="line">  <span class="attr">artifacts:</span></span><br><span class="line">    <span class="attr">untracked:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="attr">unit-test-job-data-center:</span></span><br><span class="line">  <span class="attr">stage:</span> <span class="string">test</span></span><br><span class="line">  <span class="attr">script:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">echo</span> <span class="string">&quot;Running unit tests for data-center... This will take about 10 seconds.&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">lint-test-job:</span> <span class="comment"># This job also runs in the test stage.</span></span><br><span class="line">  <span class="attr">tags:</span> [ <span class="string">nancy</span> ]</span><br><span class="line">  <span class="attr">stage:</span> <span class="string">test</span> <span class="comment"># It can run at the same time as unit-test-job (in parallel).</span></span><br><span class="line">  <span class="attr">script:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">echo</span> <span class="string">&quot;Linting code... This will take about 10 seconds.&quot;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">sleep</span> <span class="number">1</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">echo</span> <span class="string">&quot;No lint issues found.&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">deploy-job:</span></span><br><span class="line">  <span class="attr">tags:</span> [ <span class="string">nancy</span> ]</span><br><span class="line">  <span class="attr">stage:</span> <span class="string">deploy</span></span><br><span class="line">  <span class="attr">environment:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">production</span></span><br><span class="line">  <span class="attr">script:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">sshpass</span> <span class="string">-p</span> <span class="string">&quot;$APP_SERVER_PWD&quot;</span> <span class="string">scp</span> <span class="string">-o</span> <span class="string">StrictHostKeyChecking=no</span> <span class="string">front.tar</span> <span class="string">ubuntu@&quot;$APP_SERVER_IP&quot;:~</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">sshpass</span> <span class="string">-p</span> <span class="string">&quot;$APP_SERVER_PWD&quot;</span> <span class="string">ssh</span> <span class="string">-o</span> <span class="string">StrictHostKeyChecking=no</span> <span class="string">ubuntu@&quot;$APP_SERVER_IP&quot;</span> <span class="string">&#x27;docker container rm -f front-v2; docker load -i front.tar; docker run -d --name front-v2 -p 8700:80 -p 8701:443 -v /usr/share/mynginxconf/certificate.crt:/etc/nginx/ssl/your_domain.crt -v /usr/share/mynginxconf/private.key:/etc/nginx/ssl/your_domain.key front:latest /bin/bash -c &quot;nginx; tail -f /dev/null&quot;&#x27;</span></span><br></pre></td></tr></table></figure></div><p>主要是</p><div class="highlight-container" data-rel="Yml"><figure class="iseeu highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">deploy-job:</span></span><br><span class="line">  <span class="attr">tags:</span> [ <span class="string">nancy</span> ]</span><br><span class="line">  <span class="attr">stage:</span> <span class="string">deploy</span></span><br><span class="line">  <span class="attr">environment:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">production</span></span><br><span class="line">  <span class="attr">script:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">sshpass</span> <span class="string">-p</span> <span class="string">&quot;$APP_SERVER_PWD&quot;</span> <span class="string">scp</span> <span class="string">-o</span> <span class="string">StrictHostKeyChecking=no</span> <span class="string">front.tar</span> <span class="string">ubuntu@&quot;$APP_SERVER_IP&quot;:~</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">sshpass</span> <span class="string">-p</span> <span class="string">&quot;$APP_SERVER_PWD&quot;</span> <span class="string">ssh</span> <span class="string">-o</span> <span class="string">StrictHostKeyChecking=no</span> <span class="string">ubuntu@&quot;$APP_SERVER_IP&quot;</span> <span class="string">&#x27;docker container rm -f front-v2; docker load -i front.tar; docker run -d --name front-v2 -p 8700:80 -p 8701:443 -v /usr/share/mynginxconf/certificate.crt:/etc/nginx/ssl/your_domain.crt -v /usr/share/mynginxconf/private.key:/etc/nginx/ssl/your_domain.key front:latest /bin/bash -c &quot;nginx; tail -f /dev/null&quot;&#x27;</span></span><br></pre></td></tr></table></figure></div><p>这部分涉及我当时docker都搞了些啥，OK</p><ol><li>将docker内的80和443分别映射到了服务器的8700和8701</li><li>配置文件从本机/usr/share/mynginxconf/certificate.crt和/usr/share/mynginxconf/private.key映射过去</li></ol><h2 id="前端容器内的nginx-conf">前端容器内的nginx.conf</h2><div class="highlight-container" data-rel="Nginx"><figure class="iseeu highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">user</span> nginx;</span><br><span class="line"><span class="attribute">worker_processes</span> <span class="number">1</span>;</span><br><span class="line"><span class="attribute">error_log</span> /var/log/nginx/<span class="literal">error</span>.log <span class="literal">warn</span>;</span><br><span class="line"><span class="attribute">pid</span> /var/run/nginx.pid;</span><br><span class="line"></span><br><span class="line"><span class="section">events</span> &#123;</span><br><span class="line">    <span class="attribute">worker_connections</span> <span class="number">1024</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">    <span class="attribute">include</span> /etc/nginx/mime.types;</span><br><span class="line">    <span class="attribute">default_type</span> application/octet-stream;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">log_format</span> main <span class="string">&#x27;<span class="variable">$remote_addr</span> - <span class="variable">$remote_user</span> [<span class="variable">$time_local</span>] &quot;<span class="variable">$request</span>&quot; &#x27;</span></span><br><span class="line">    <span class="string">&#x27;<span class="variable">$status</span> <span class="variable">$body_bytes_sent</span> &quot;<span class="variable">$http_referer</span>&quot; &#x27;</span></span><br><span class="line">    <span class="string">&#x27;&quot;<span class="variable">$http_user_agent</span>&quot; &quot;<span class="variable">$http_x_forwarded_for</span>&quot;&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">access_log</span> /var/log/nginx/access.log main;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">sendfile</span> <span class="literal">on</span>;</span><br><span class="line">    <span class="attribute">keepalive_timeout</span> <span class="number">65</span>;</span><br><span class="line">    <span class="attribute">client_max_body_size</span> <span class="number">100m</span>;</span><br><span class="line"></span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line"></span><br><span class="line">        <span class="section">location</span> / &#123;</span><br><span class="line">            <span class="attribute">root</span> /app;</span><br><span class="line">            <span class="attribute">try_files</span> <span class="variable">$uri</span> <span class="variable">$uri</span>/ /index.html;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="section">location</span> /api/ &#123;</span><br><span class="line">            <span class="attribute">proxy_pass</span> http://&lt;后端服务器ip&gt;:8080/;</span><br><span class="line">            <span class="attribute">proxy_set_header</span> Host <span class="variable">$host</span>;</span><br><span class="line">            <span class="attribute">proxy_set_header</span> X-Real-IP <span class="variable">$remote_addr</span>;</span><br><span class="line">            <span class="attribute">proxy_set_header</span> X-Forwarded-For <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">error_page</span> <span class="number">500</span> <span class="number">502</span> <span class="number">503</span> <span class="number">504</span> /50x.html;</span><br><span class="line">        <span class="section">location</span> = /50x.html &#123;</span><br><span class="line">            <span class="attribute">root</span> /usr/share/nginx/html;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span> <span class="number">443</span> ssl;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">ssl_certificate</span> /etc/nginx/ssl/your_domain.crt;</span><br><span class="line">        <span class="attribute">ssl_certificate_key</span> /etc/nginx/ssl/your_domain.key;</span><br><span class="line"></span><br><span class="line">        <span class="section">location</span> / &#123;</span><br><span class="line">            <span class="attribute">root</span> /app;</span><br><span class="line">            <span class="attribute">try_files</span> <span class="variable">$uri</span> <span class="variable">$uri</span>/ /index.html;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="section">location</span> /api/ &#123;</span><br><span class="line">            <span class="attribute">proxy_pass</span> http://&lt;后端服务器ip&gt;:8080/;</span><br><span class="line">            <span class="attribute">proxy_set_header</span> Host <span class="variable">$host</span>;</span><br><span class="line">            <span class="attribute">proxy_set_header</span> X-Real-IP <span class="variable">$remote_addr</span>;</span><br><span class="line">            <span class="attribute">proxy_set_header</span> X-Forwarded-For <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">error_page</span> <span class="number">500</span> <span class="number">502</span> <span class="number">503</span> <span class="number">504</span> /50x.html;</span><br><span class="line">        <span class="section">location</span> = /50x.html &#123;</span><br><span class="line">            <span class="attribute">root</span> /usr/share/nginx/html;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="renew过程">renew过程</h2><p>To Be Co</p>]]></content>
      
      
      <categories>
          
          <category> 实践记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 服务器 </tag>
            
            <tag> SSL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于Langchain的SQL交互Agent</title>
      <link href="/posts/%E5%AE%9E%E8%B7%B5%E8%AE%B0%E5%BD%95/2024-Spring-%E8%BD%AF%E5%B7%A5%E4%B8%89/%E5%9F%BA%E4%BA%8Elangchain%E7%9A%84sql%E4%BA%A4%E4%BA%92agent.html"/>
      <url>/posts/%E5%AE%9E%E8%B7%B5%E8%AE%B0%E5%BD%95/2024-Spring-%E8%BD%AF%E5%B7%A5%E4%B8%89/%E5%9F%BA%E4%BA%8Elangchain%E7%9A%84sql%E4%BA%A4%E4%BA%92agent.html</url>
      
        <content type="html"><![CDATA[<h2 id="Github链接">Github链接</h2><p>代码已开源，点点❤家人们，顶着一堆作业写的QAQ</p><p><a class="link" href="https://github.com/SYuan03/llm4db">https://github.com/SYuan03/llm4db <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p><h2 id="参考链接">参考链接</h2><p>官网</p><ol><li><a class="link" href="https://python.langchain.com/v0.1/docs/use_cases/sql/">https://python.langchain.com/v0.1/docs/use_cases/sql/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li><li><a class="link" href="https://python.langchain.com/v0.1/docs/use_cases/sql/quickstart/">https://python.langchain.com/v0.1/docs/use_cases/sql/quickstart/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li></ol><p>DashScope（阿里云）API</p><p><a class="link" href="https://dashscope.console.aliyun.com/dashboard">https://dashscope.console.aliyun.com/dashboard <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p><blockquote><p>好多地方都用了gpt-3.5-turbo的模型，4o又太贵，所以体验下Qwen的模型，体验额度还挺大的</p></blockquote><h2 id="Process">Process</h2><p>以下记录几个问题点</p><h3 id="处理密码特殊字符">处理密码特殊字符</h3><p>这步有点气人咳咳</p><p>了解到密码中含有@等特殊词汇需要使用</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib.parse <span class="keyword">import</span> quote_plus</span><br></pre></td></tr></table></figure></div><p>然后用了发现还是连不上，OK排查了一番后发现填成服务器密码了QAQ</p><p>改了之后终于连好了</p><style>.zptlugespfmu{zoom:50%;}</style><img lazyload src="/images/loading.svg" data-src="/posts/%E5%AE%9E%E8%B7%B5%E8%AE%B0%E5%BD%95/2024-Spring-%E8%BD%AF%E5%B7%A5%E4%B8%89/%E5%9F%BA%E4%BA%8Elangchain%E7%9A%84sql%E4%BA%A4%E4%BA%92agent/image-20240609213451239.png" class="zptlugespfmu" alt="image-20240609213451239"> <h3 id="StrOutputParser">StrOutputParser</h3><p>OutputParser that parses LLMResult into the top likely <strong>string</strong>.</p><p>Create a new model by parsing and validating input data from keyword arguments.</p><p>Raises ValidationError if the input data cannot be parsed to form a valid model.</p><h2 id="demo">demo</h2><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">db = SQLDatabase.from_uri(uri)</span><br><span class="line"></span><br><span class="line">llm = Tongyi(model=<span class="string">&#x27;qwen-max-1201&#x27;</span>, temperature=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义回答问题的模板，把前面的问题、查询和结果传给LLM，然后解析输出</span></span><br><span class="line">answer_prompt = PromptTemplate.from_template(</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    根据以下用户问题、对应的SQL查询以及SQL查询结果，回答用户的问题。</span></span><br><span class="line"><span class="string">    问题: &#123;question&#125;</span></span><br><span class="line"><span class="string">    SQL 查询: &#123;query&#125;</span></span><br><span class="line"><span class="string">    SQL 查询结果: &#123;result&#125;</span></span><br><span class="line"><span class="string">    答案:</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="comment"># 创建SQL查询链</span></span><br><span class="line">write_query = create_sql_query_chain(llm, db)</span><br><span class="line"><span class="comment"># 创建SQL查询工具</span></span><br><span class="line">execute_query = QuerySQLDataBaseTool(db=db)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义链再传给LLM，然后使用StrOutputParser解析输出</span></span><br><span class="line">answer = answer_prompt | llm | StrOutputParser()</span><br><span class="line">chain = (</span><br><span class="line">        RunnablePassthrough.assign(query=write_query).assign(</span><br><span class="line">            result=itemgetter(<span class="string">&quot;query&quot;</span>) | execute_query</span><br><span class="line">        )</span><br><span class="line">        | answer</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">res = chain.invoke(&#123;<span class="string">&quot;question&quot;</span>: <span class="string">&quot;一共有多少仓库？有多少trending？&quot;</span>&#125;)</span><br><span class="line"><span class="built_in">print</span>(res)</span><br></pre></td></tr></table></figure></div><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">There are 703 repositories.</span><br></pre></td></tr></table></figure></div><p>Cool，验证下</p><img lazyload src="/images/loading.svg" data-src="/posts/%E5%AE%9E%E8%B7%B5%E8%AE%B0%E5%BD%95/2024-Spring-%E8%BD%AF%E5%B7%A5%E4%B8%89/%E5%9F%BA%E4%BA%8Elangchain%E7%9A%84sql%E4%BA%A4%E4%BA%92agent/image-20240609215501808.png" class title="image-20240609215501808"><p>想看下用了多少token的，结果好像数据没刷新</p><h2 id="NextSteps">NextSteps</h2><p>只试了下few shot</p><h3 id="Prompting-strategies">Prompting strategies</h3><p><a class="link" href="https://python.langchain.com/v0.1/docs/use_cases/sql/prompting/">https://python.langchain.com/v0.1/docs/use_cases/sql/prompting/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p><p>看了下可以把表结构也一起传下，增强一下，加点描述之类的</p><h3 id="Few-shot-examples">Few-shot examples</h3><p><a class="link" href="https://python.langchain.com/v0.1/docs/use_cases/sql/prompting/#few-shot-examples">https://python.langchain.com/v0.1/docs/use_cases/sql/prompting/#few-shot-examples <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p><p>还可以搞点few shot</p><h2 id="补充：StreamForHttps">补充：StreamForHttps</h2><p>部署接口在服务器上的时候发现</p><p><a class="link" href="http://ip:8000/dbchat/stream%E8%83%BD%E6%AD%A3%E5%B8%B8%E6%B5%81%E5%BC%8F%E5%93%8D%E5%BA%94">http://ip:8000/dbchat/stream能正常流式响应 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p><p>但是经过nginx反向代理的https的<a class="link" href="https://ip:8001/dbchat/stream%E6%B2%A1%E6%B3%95%E6%AD%A3%E5%B8%B8%E6%B5%81%E5%BC%8F%E5%93%8D%E5%BA%94%EF%BC%8C%E7%9B%B4%E6%8E%A5~~%E4%BE%9D%E5%A4%A7%E6%89%98~~%E5%87%BA%E6%9D%A5">https://ip:8001/dbchat/stream没法正常流式响应，直接~~依大托~~出来 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p><p>之前的nginx配置如下</p><div class="highlight-container" data-rel="Nginx"><figure class="iseeu highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">8001</span> ssl;</span><br><span class="line">    <span class="attribute">server_name</span> &lt;ip&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">ssl_certificate</span> /etc/nginx/ssl/certificate.crt;</span><br><span class="line">    <span class="attribute">ssl_certificate_key</span> /etc/nginx/ssl/private.key;</span><br><span class="line">    <span class="attribute">ssl_trusted_certificate</span> /etc/nginx/ssl/ca_bundle.crt;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">ssl_protocols</span> TLSv1.<span class="number">2</span> TLSv1.<span class="number">3</span>;</span><br><span class="line">    <span class="attribute">ssl_prefer_server_ciphers</span> <span class="literal">on</span>;</span><br><span class="line">    <span class="attribute">ssl_ciphers</span> <span class="string">&quot;EECDH+AESGCM:EDH+AESGCM:AES256+EECDH:AES256+EDH&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="section">location</span> / &#123;</span><br><span class="line">        <span class="attribute">proxy_pass</span> http://localhost:8000;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> Host <span class="variable">$host</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> X-Real-IP <span class="variable">$remote_addr</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> X-Forwarded-For <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> X-Forwarded-Proto <span class="variable">$scheme</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>关闭缓存后修改如下</p><div class="highlight-container" data-rel="Nginx"><figure class="iseeu highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">8001</span> ssl;</span><br><span class="line">    <span class="attribute">server_name</span> &lt;ip&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">ssl_certificate</span> /etc/nginx/ssl/certificate.crt;</span><br><span class="line">    <span class="attribute">ssl_certificate_key</span> /etc/nginx/ssl/private.key;</span><br><span class="line">    <span class="attribute">ssl_trusted_certificate</span> /etc/nginx/ssl/ca_bundle.crt;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">ssl_protocols</span> TLSv1.<span class="number">2</span> TLSv1.<span class="number">3</span>;</span><br><span class="line">    <span class="attribute">ssl_prefer_server_ciphers</span> <span class="literal">on</span>;</span><br><span class="line">    <span class="attribute">ssl_ciphers</span> <span class="string">&quot;EECDH+AESGCM:EDH+AESGCM:AES256+EECDH:AES256+EDH&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="section">location</span> /stream &#123;</span><br><span class="line">        <span class="attribute">proxy_pass</span> http://localhost:8000/stream;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> Host <span class="variable">$host</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> X-Real-IP <span class="variable">$remote_addr</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> X-Forwarded-For <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> X-Forwarded-Proto <span class="variable">$scheme</span>;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">proxy_buffering</span> <span class="literal">off</span>;  <span class="comment"># 关键配置，确保禁用代理缓冲</span></span><br><span class="line">        <span class="attribute">proxy_http_version</span> <span class="number">1</span>.<span class="number">1</span>;</span><br><span class="line">        <span class="attribute">chunked_transfer_encoding</span> <span class="literal">on</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>发现解决了问题</p><h2 id="致谢">致谢</h2><p>Paying tribute to the legendary software engineering warrior ——<a href="https://github.com/SEBugMaker"><strong>SEBugMaker</strong></a>！</p><p>And <a href="https://github.com/SYuan03"><strong>SYuan03</strong></a> as well. (Ahem, paying tribute to oneself might seem a bit odd)</p>]]></content>
      
      
      <categories>
          
          <category> 实践记录 </category>
          
          <category> 2024-Spring-软工三 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Langchain </tag>
            
            <tag> 急急国王系列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GitlabRunner流水线之DockerHub重配置</title>
      <link href="/posts/%E6%9D%82%E8%AE%B0/gitlabrunner%E6%B5%81%E6%B0%B4%E7%BA%BF%E4%B9%8Bdockerhub%E9%87%8D%E9%85%8D%E7%BD%AE.html"/>
      <url>/posts/%E6%9D%82%E8%AE%B0/gitlabrunner%E6%B5%81%E6%B0%B4%E7%BA%BF%E4%B9%8Bdockerhub%E9%87%8D%E9%85%8D%E7%BD%AE.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>突然发现最近后端流水线连续几次都没成功，于是看了下果然又是Docker服务在国外的原因，咳咳</p><p><img lazyload src="/images/loading.svg" data-src="Docker%E9%85%8D%E7%BD%AE%E5%92%B3%E5%92%B3/image-20240609001313763.png" alt="image-20240609001313763"></p><p>于是搜索了一番，换了一个还能用的地址</p><p><img lazyload src="/images/loading.svg" data-src="Docker%E9%85%8D%E7%BD%AE%E5%92%B3%E5%92%B3/image-20240609001429312.png" alt="image-20240609001429312"></p><p>命令如下</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/docker/daemon.json</span><br></pre></td></tr></table></figure></div><div class="highlight-container" data-rel="Json"><figure class="iseeu highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;registry-mirrors&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="string">&quot;https://docker.m.daocloud.io&quot;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></div><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure></div><p>PS：如果出现</p><p>Job for docker.service failed because the control process exited with error code.<br>See “systemctl status docker.service” and “journalctl -xeu docker.service” for details.</p><p>那说明daemon.json写错力</p><h2 id="结果">结果</h2><p>等了12分钟终于好了</p><p><img lazyload src="/images/loading.svg" data-src="Docker%E9%85%8D%E7%BD%AE%E5%92%B3%E5%92%B3/image-20240609001959554.png" alt="image-20240609001959554"></p><h2 id="补充">补充</h2><p>感觉这个很快就要不能用了</p>]]></content>
      
      
      <categories>
          
          <category> 杂记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GitlabRunner </tag>
            
            <tag> Proxy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>非遗珍宝：ChrisDing早期国画作品展（一）</title>
      <link href="/posts/%E6%9D%82%E8%AE%B0/%E9%9D%9E%E9%81%97%E7%8F%8D%E5%AE%9D%EF%BC%9Achrisding%E6%97%A9%E6%9C%9F%E5%9B%BD%E7%94%BB%E4%BD%9C%E5%93%81%E5%B1%95%EF%BC%88%E4%B8%80%EF%BC%89.html"/>
      <url>/posts/%E6%9D%82%E8%AE%B0/%E9%9D%9E%E9%81%97%E7%8F%8D%E5%AE%9D%EF%BC%9Achrisding%E6%97%A9%E6%9C%9F%E5%9B%BD%E7%94%BB%E4%BD%9C%E5%93%81%E5%B1%95%EF%BC%88%E4%B8%80%EF%BC%89.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>起因如下</p><p><img lazyload src="/images/loading.svg" data-src="%E9%9D%9E%E9%81%97%E7%8F%8D%E5%AE%9Ddsy%E6%97%A9%E6%9C%9F%E4%BD%9C%E5%93%81%E5%B1%951/image-20240430115144759.png" alt="image-20240430115144759"></p><p>遂找老妈拍了点，并受到锐评</p><p><img lazyload src="/images/loading.svg" data-src="%E9%9D%9E%E9%81%97%E7%8F%8D%E5%AE%9Ddsy%E6%97%A9%E6%9C%9F%E4%BD%9C%E5%93%81%E5%B1%951/image-20240430115255797.png" alt="image-20240430115255797"></p><h2 id="展示">展示</h2><h3 id="《小跳蛙》">《小跳蛙》</h3><p><img lazyload src="/images/loading.svg" data-src="%E9%9D%9E%E9%81%97%E7%8F%8D%E5%AE%9Ddsy%E6%97%A9%E6%9C%9F%E4%BD%9C%E5%93%81%E5%B1%951/62cc2a8ff1fecc9f09b927b087aad40.jpg" alt="62cc2a8ff1fecc9f09b927b087aad40"></p><h3 id="《科目三》">《科目三》</h3><p><img lazyload src="/images/loading.svg" data-src="%E9%9D%9E%E9%81%97%E7%8F%8D%E5%AE%9Ddsy%E6%97%A9%E6%9C%9F%E4%BD%9C%E5%93%81%E5%B1%951/c567ef877c6fb2026f95b91fbf89dfd.jpg" alt="c567ef877c6fb2026f95b91fbf89dfd"></p><h3 id="《石榴熟了》">《石榴熟了》</h3><p><img lazyload src="/images/loading.svg" data-src="%E9%9D%9E%E9%81%97%E7%8F%8D%E5%AE%9Ddsy%E6%97%A9%E6%9C%9F%E4%BD%9C%E5%93%81%E5%B1%951/41876e376ccdd4818247eb2b2746f71.jpg" alt="41876e376ccdd4818247eb2b2746f71"></p><h3 id="《石榴更熟了》">《石榴更熟了》</h3><p><img lazyload src="/images/loading.svg" data-src="%E9%9D%9E%E9%81%97%E7%8F%8D%E5%AE%9Ddsy%E6%97%A9%E6%9C%9F%E4%BD%9C%E5%93%81%E5%B1%951/4c599f1597405de076905853b5d270e.jpg" alt="4c599f1597405de076905853b5d270e"></p><h3 id="《画蟹》">《画蟹》</h3><blockquote><p>科普：宜兴话螃蟹叫“毛哈”</p></blockquote><p><img lazyload src="/images/loading.svg" data-src="%E9%9D%9E%E9%81%97%E7%8F%8D%E5%AE%9Ddsy%E6%97%A9%E6%9C%9F%E4%BD%9C%E5%93%81%E5%B1%951/da4b381c0ec6755769bcefcd53b0589.jpg" alt="da4b381c0ec6755769bcefcd53b0589"></p>]]></content>
      
      
      <categories>
          
          <category> 杂记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 国画作品 </tag>
            
            <tag> 艺术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>不知道花了多久但我就要说很快速的docker部署前后端项目</title>
      <link href="/posts/%E5%AE%9E%E8%B7%B5%E8%AE%B0%E5%BD%95/%E4%B8%8D%E7%9F%A5%E9%81%93%E8%8A%B1%E4%BA%86%E5%A4%9A%E4%B9%85%E4%BD%86%E6%88%91%E5%B0%B1%E8%A6%81%E8%AF%B4%E5%BE%88%E5%BF%AB%E9%80%9F%E7%9A%84docker%E9%83%A8%E7%BD%B2%E5%89%8D%E5%90%8E%E7%AB%AF%E9%A1%B9%E7%9B%AE.html"/>
      <url>/posts/%E5%AE%9E%E8%B7%B5%E8%AE%B0%E5%BD%95/%E4%B8%8D%E7%9F%A5%E9%81%93%E8%8A%B1%E4%BA%86%E5%A4%9A%E4%B9%85%E4%BD%86%E6%88%91%E5%B0%B1%E8%A6%81%E8%AF%B4%E5%BE%88%E5%BF%AB%E9%80%9F%E7%9A%84docker%E9%83%A8%E7%BD%B2%E5%89%8D%E5%90%8E%E7%AB%AF%E9%A1%B9%E7%9B%AE.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>首先感谢LLM4SE小组的所有成员的付出！</p></blockquote><h2 id="前端">前端</h2><h3 id="扔到github仓库">扔到github仓库</h3><p>主要是原先不在github上</p><p><img lazyload src="/images/loading.svg" data-src="%E4%B8%8D%E7%9F%A5%E9%81%93%E5%A4%9A%E4%B9%85%E4%BD%86%E6%88%91%E5%B0%B1%E8%A6%81%E8%AF%B4%E5%BE%88%E5%BF%AB%E9%80%9F%E7%9A%84docker%E9%83%A8%E7%BD%B2%E5%89%8D%E5%90%8E%E7%AB%AF%E9%A1%B9%E7%9B%AE/image-20240416234307784.png" alt="image-20240416234307784"></p><h3 id="前端该点东西you-know-what">前端该点东西you know what</h3><p>诸如api_url之类的</p><blockquote><p>Tips</p><p>其实可以用nginx反代把后端api隐藏</p><p>但这里懒得搞了，可以参考我软工3的CI/CD</p><p><a class="link" href="https://git.nju.edu.cn/2024seiii-19-ineedoffer/frontend-nju2">frontend-nju2 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p></blockquote><h3 id="邀请gpt4撰写一份前端的Dockerfile">邀请gpt4撰写一份前端的Dockerfile</h3><p>本地跑了下18能跑</p><div class="highlight-container" data-rel="Dockerfile"><figure class="iseeu highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用官方的 Node.js 18 镜像作为基础镜像</span></span><br><span class="line"><span class="keyword">FROM</span> node:<span class="number">18</span> AS build</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置工作目录</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /usr/src/app</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 复制 package.json 和 package-lock.json 到工作目录</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> package*.json ./</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装项目依赖</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> npm install</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 复制项目文件到工作目录</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> . .</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 构建项目</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> npm run build</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 nginx 镜像作为基础镜像</span></span><br><span class="line"><span class="keyword">FROM</span> nginx:stable-alpine</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装 vim</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apk add vim</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将构建产物复制到 nginx 的网页目录</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> --from=build /usr/src/app/dist /usr/share/nginx/html</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 对外暴露 80 端口</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">80</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动 nginx</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;nginx&quot;</span>, <span class="string">&quot;-g&quot;</span>, <span class="string">&quot;daemon off;&quot;</span>]</span></span><br></pre></td></tr></table></figure></div><h3 id="（可选）自定义nginx-conf">（可选）自定义nginx.conf</h3><p>可以把自己的nginx.conf复制到容器内运行</p><h3 id="打包运行">打包运行</h3><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker build -t llm4se_frontend:1.0 .</span><br><span class="line">docker run -p 7001:80 -d llm4se_frontend:1.0</span><br></pre></td></tr></table></figure></div><p><img lazyload src="/images/loading.svg" data-src="%E4%B8%8D%E7%9F%A5%E9%81%93%E5%A4%9A%E4%B9%85%E4%BD%86%E6%88%91%E5%B0%B1%E8%A6%81%E8%AF%B4%E5%BE%88%E5%BF%AB%E9%80%9F%E7%9A%84docker%E9%83%A8%E7%BD%B2%E5%89%8D%E5%90%8E%E7%AB%AF%E9%A1%B9%E7%9B%AE/image-20240417003432802.png" alt="image-20240417003432802"></p><p>打包打了117.3秒</p><h3 id="（必选）域名配置">（<s>必选</s>）域名配置</h3><p>改下服务器上的nginx配置就行（注意不是容器内部的那个）</p><p>ip+端口先测下成功没**（似乎比我本地npm run dev之后第一次访问快多了**</p><p>配域名A记录</p>]]></content>
      
      
      <categories>
          
          <category> 实践记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>平板远程控制win本</title>
      <link href="/posts/%E6%9D%82%E8%AE%B0/%E5%B9%B3%E6%9D%BF%E8%BF%9C%E7%A8%8B%E6%8E%A7%E5%88%B6win%E6%9C%AC.html"/>
      <url>/posts/%E6%9D%82%E8%AE%B0/%E5%B9%B3%E6%9D%BF%E8%BF%9C%E7%A8%8B%E6%8E%A7%E5%88%B6win%E6%9C%AC.html</url>
      
        <content type="html"><![CDATA[<h2 id="最easy的方式">最easy的方式</h2><p>直接下载软件比如ToDesk之类的</p><p>在两台设备上都安装了就能远程控制了，不过高帧和高画质啥的需要付费（指ToDesk，其他的也没试）</p><h2 id="TailScale-RDP">TailScale+RDP</h2><p>RDP，即Remote Desktop Protocol</p><p>win本自带的远程桌面连接</p><h3 id="win本启用远程桌面">win本启用远程桌面</h3><p>家庭版只能作为控制端，不能作为受控端</p><p>因此需要先升级到专业版~~（可以某宝上几块钱买一个~~</p><p><img lazyload src="/images/loading.svg" data-src="%E5%B9%B3%E6%9D%BF%E8%BF%9C%E7%A8%8B%E6%8E%A7%E5%88%B6win%E6%9C%AC/image-20240402212149127.png" alt="image-20240402212149127"></p><p>然后就能进行设置了</p><p><img lazyload src="/images/loading.svg" data-src="%E5%B9%B3%E6%9D%BF%E8%BF%9C%E7%A8%8B%E6%8E%A7%E5%88%B6win%E6%9C%AC/image-20240402204138015.png" alt="image-20240402204138015"></p><p>找到对应的地方启用下即可</p><h3 id="在其他终端设备上安装Remote-Desktop">在其他终端设备上安装Remote Desktop</h3><p><img lazyload src="/images/loading.svg" data-src="%E5%B9%B3%E6%9D%BF%E8%BF%9C%E7%A8%8B%E6%8E%A7%E5%88%B6win%E6%9C%AC/image-20240402204407039.png" alt="image-20240402204407039"></p><blockquote><p>我的平板是从谷歌商店里下载的，别的（比如ios商店）里面可能不叫这个名字，反正认准正版下载即可</p></blockquote><p>基本使用：添加电脑ip按设置连接即可使用</p><h3 id="TailScale的安装">TailScale的安装</h3><p>如果是在相同的局域网下，完成上述的步骤之后即可使用局域网ip进行连接。但是如果不在同一个局域网呢？</p><p>理论上，如果你有个固定的公网IP地址，那么上面用在局域网的办法也能用在公网上。但绝大部分人电脑上的IP地址都是局域网地址，在公网上无法使用，所以必须使用一些办法，将局域网地址转为公网地址（地址转换/端口映射），或者在两个相互独立的局域网间建设一个虚拟网络，用虚拟网络的地址互联互通（内网穿透）。Tailscale就提供了后一种解决方案。</p><p>Tailscale是一款基于WireGuard技术的虚拟组网工具，能帮助我们把安装了Tailscale服务的机器都放到同一个局域网。在安全性上，它是个去中心化、点对点连接加密的组网工具，而且开放了源代码。如果愿意甚至可以自己架设一个服务端，无须担心泄密问题。这里是下载地址<a class="link" href="https://tailscale.com/">Tailscale <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p><p>在两台设备（受控端和控制端）上<strong>都需要</strong>安装。</p><h3 id="使用">使用</h3><p>两边都完成后（或者安装完成注册时）</p><p>应该在浏览器会自动弹出这么一个控制台，显示你账户下所有连接到这个虚拟局域网的设备</p><p>所以要记得用同一个账户</p><p><img lazyload src="/images/loading.svg" data-src="%E5%B9%B3%E6%9D%BF%E8%BF%9C%E7%A8%8B%E6%8E%A7%E5%88%B6win%E6%9C%AC/image-20240402204948937.png" alt="image-20240402204948937"></p><p>之后在这里看到两台设备都连接上了，有ip了就可以用了，平板上的话右上角有个vpn按钮得打开下再输入ip进行连接</p><h2 id="致谢">致谢</h2><p>感谢<a class="link" href="https://space.bilibili.com/502809046">haosN_ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>的推荐和帮助</p>]]></content>
      
      
      <categories>
          
          <category> 杂记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 远程控制 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>工厂模式内容补充理解</title>
      <link href="/posts/%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E5%86%85%E5%AE%B9%E8%A1%A5%E5%85%85%E7%90%86%E8%A7%A3.html"/>
      <url>/posts/%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E5%86%85%E5%AE%B9%E8%A1%A5%E5%85%85%E7%90%86%E8%A7%A3.html</url>
      
        <content type="html"><![CDATA[<h2 id="简单工厂模式的扩展">简单工厂模式的扩展</h2><p><strong>Q</strong></p><ol><li>简单工厂模式的简化：在有些情况下工厂类可以由抽象产品角色扮演，一个抽象产品类同时也是子类的工厂，也就是说把静态工厂方法写到抽象产品类中。</li><li>有些情况下，产品本身只提供一两个方法，此时抽象产品可以和简单工厂进行角色合并。啥意思？举个例子，没理解</li></ol><p>这两段话描述的是简单工厂模式的一种变体，也就是说在一些特定的情况下，简单工厂模式的结构可以进一步简化。具体来说，就是将工厂方法放入抽象产品类中，让抽象产品类既扮演产品角色，也扮演工厂角色。这种做法通常适用于产品类结构简单，功能相对单一的场景。下面通过一个例子来解释这个概念。</p><p><strong>A</strong></p><h3 id="示例：图形绘制">示例：图形绘制</h3><p>假设我们有一个绘图应用，需要绘制不同类型的图形，如圆形、正方形等。每种图形都有自己特定的绘制方法。这里，图形（Shape）是一个抽象概念，具体的圆形（Circle）和正方形（Square）是具体的实现。</p><h4 id="不使用简化的简单工厂模式">不使用简化的简单工厂模式</h4><p>首先看传统的简单工厂模式实现：</p><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抽象产品类</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体产品类：圆形</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> <span class="keyword">extends</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Drawing a circle&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体产品类：正方形</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Square</span> <span class="keyword">extends</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Drawing a square&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 简单工厂类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ShapeFactory</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> Shape <span class="title function_">getShape</span><span class="params">(String type)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (type == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (type.equalsIgnoreCase(<span class="string">&quot;CIRCLE&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Circle</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type.equalsIgnoreCase(<span class="string">&quot;SQUARE&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Square</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="使用简化的简单工厂模式">使用简化的简单工厂模式</h4><p>现在，按照你提到的简化，我们将工厂方法直接放入抽象产品类中：</p><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抽象产品类同时扮演工厂角色</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 静态工厂方法</span></span><br><span class="line">    <span class="keyword">static</span> Shape <span class="title function_">getShape</span><span class="params">(String type)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (type == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (type.equalsIgnoreCase(<span class="string">&quot;CIRCLE&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Circle</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type.equalsIgnoreCase(<span class="string">&quot;SQUARE&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Square</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体产品类：圆形</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> <span class="keyword">extends</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Drawing a circle&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体产品类：正方形</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Square</span> <span class="keyword">extends</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Drawing a square&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>在这个简化后的模式中，<code>Shape</code> 类既定义了产品的接口（<code>draw</code> 方法），也提供了一个静态的工厂方法（<code>getShape</code> 方法）来根据类型创建具体的产品实例。这种做法简化了结构，减少了类的数量，特别适合那些产品类比较简单、数量不多的场景。这样，客户端只需要与<code>Shape</code>类交互即可获取具体的图形实例并调用其绘制方法，无需直接与具体的图形类或单独的工厂类交互，从而简化了客户端的使用复杂度。</p><p><strong>Q</strong></p><p>我有两个问题，那Square也会有getShape这个方法吗？那不是乱了吗？另外实体类可以调用静态方法吗？Shape是抽象类可以被实例化吗？</p><p><strong>A</strong></p><p>你提出的问题非常好，让我们逐一解答：</p><ol><li><strong><code>Square</code>类会有<code>getShape</code>这个方法吗？</strong></li></ol><p>在Java中（以及很多其他面向对象的编程语言中），静态方法属于类级别的方法，而不是实例级别的方法。当我们在抽象类中定义一个静态方法时，这个方法可以被类直接调用，而不是由类的实例调用。因此，虽然<code>Square</code>继承自<code>Shape</code>，它继承的是<code>Shape</code>的非静态行为和属性。静态方法<code>getShape</code>可以通过类名直接调用，如<code>Shape.getShape(&quot;CIRCLE&quot;)</code>，而不是通过一个<code>Shape</code>或<code>Square</code>的实例来调用。</p><p>所以，从概念上讲，<code>Square</code>类并不会“拥有”<code>getShape</code>方法。<code>getShape</code>是属于<code>Shape</code>类的，尽管<code>Square</code>是<code>Shape</code>的一个子类。这并不会导致混乱，因为静态方法的调用总是明确指向它们所属的类。</p><ol><li><strong>实体类可以调用静态方法吗？</strong></li></ol><p>实体类（或者说任何类）可以调用静态方法，但调用方式与实例方法不同。静态方法通过类本身来调用，而不是通过类的实例。这意味着，即使你有一个<code>Shape</code>类的实例，你也应该使用类名来调用静态方法，比如<code>Shape.getShape(&quot;CIRCLE&quot;)</code>，而不是使用实例来调用。这是因为静态方法不依赖于类的任何特定实例。</p><ol><li><strong><code>Shape</code>是抽象类可以被实例化吗？</strong></li></ol><p>抽象类不能被直接实例化。抽象类的目的是为其他类提供一个共同的、被继承的类型框架，定义一些可以在多个子类中共享的方法和属性。你不能创建一个抽象类<code>Shape</code>的实例，但你可以创建它的子类（如<code>Circle</code>和<code>Square</code>）的实例，这些子类提供了抽象方法的具体实现。静态方法<code>getShape</code>提供了一种机制，允许你根据输入的参数类型创建并返回具体子类的实例，而无需直接实例化抽象类。</p><p>简而言之，虽然<code>Shape</code>是一个抽象类且不能被实例化，但<code>Shape</code>类中的静态方法<code>getShape</code>提供了一种创建和返回<code>Shape</code>子类实例的方式，而这一切并不需要直接实例化抽象类<code>Shape</code>本身。</p>]]></content>
      
      
      <categories>
          
          <category> 软件系统设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> 工厂模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>服务器配置ssl&amp;域名解析</title>
      <link href="/posts/%E6%9D%82%E8%AE%B0/%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AEssl-%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90.html"/>
      <url>/posts/%E6%9D%82%E8%AE%B0/%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AEssl-%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90.html</url>
      
        <content type="html"><![CDATA[<h2 id="证书下载">证书下载</h2><p><img lazyload src="/images/loading.svg" data-src="%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AEssl/image-20240320115803325.png" alt="image-20240320115803325"></p><h2 id="启动一个nginx">启动一个nginx</h2><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 80:80 -p 443:443 --name my-nginx nginx:alpine</span><br></pre></td></tr></table></figure></div><p>然而我的服务器上不知道啥时候装了一个nginx，选择先停掉</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl stop nginx</span><br></pre></td></tr></table></figure></div><h2 id="上传pem和key">上传pem和key</h2><p>我选择放在了容器的/etc/nginx/cert/</p><p>然后配置nginx.config，注意里面的ip（我的nginx和app在两个docker里，所以通过docker网络来访问的，一开始填了个localhost能访问个鬼</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">user  nginx;</span><br><span class="line">worker_processes  auto;</span><br><span class="line"></span><br><span class="line">error_log  /var/log/nginx/error.log notice;</span><br><span class="line">pid        /var/run/nginx.pid;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">events &#123;</span><br><span class="line">    worker_connections  1024;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line">    include       /etc/nginx/mime.types;</span><br><span class="line">    default_type  application/octet-stream;</span><br><span class="line"></span><br><span class="line">    log_format  main  &#x27;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#x27;</span><br><span class="line">                      &#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27;</span><br><span class="line">                      &#x27;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#x27;;</span><br><span class="line"></span><br><span class="line">    access_log  /var/log/nginx/access.log  main;</span><br><span class="line"></span><br><span class="line">    sendfile        on;</span><br><span class="line">    #tcp_nopush     on;</span><br><span class="line"></span><br><span class="line">    keepalive_timeout  65;</span><br><span class="line"></span><br><span class="line">    #gzip  on;</span><br><span class="line"></span><br><span class="line">    include /etc/nginx/conf.d/*.conf;</span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line">        listen 443 ssl;</span><br><span class="line">        server_name chat2.xdingdang.eu.org;</span><br><span class="line"></span><br><span class="line">        ssl_certificate cert/chat2.xdingdang.eu.org.pem;</span><br><span class="line">        ssl_certificate_key cert/chat2.xdingdang.eu.org.key;</span><br><span class="line"></span><br><span class="line">        location / &#123;</span><br><span class="line">            proxy_pass http://&lt;容器IP&gt;:&lt;Port&gt;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="原先的workers">原先的workers</h2><div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">addEventListener</span>(<span class="string">&#x27;fetch&#x27;</span>, <span class="function"><span class="params">event</span> =&gt;</span> &#123;</span><br><span class="line">  event.<span class="title function_">respondWith</span>(<span class="title function_">handleRequest</span>(event.<span class="property">request</span>))</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">handleRequest</span>(<span class="params">request</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> url = <span class="keyword">new</span> <span class="title function_">URL</span>(request.<span class="property">url</span>);</span><br><span class="line">  url.<span class="property">port</span> = <span class="number">3000</span>; <span class="comment">// 你的服务端口</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> newRequest = <span class="keyword">new</span> <span class="title class_">Request</span>(url, &#123;</span><br><span class="line">    <span class="attr">method</span>: request.<span class="property">method</span>,</span><br><span class="line">    <span class="attr">headers</span>: request.<span class="property">headers</span>,</span><br><span class="line">    <span class="attr">body</span>: request.<span class="property">body</span>,</span><br><span class="line">    <span class="attr">redirect</span>: request.<span class="property">redirect</span></span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">fetch</span>(newRequest);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="现在要改成转发到443">现在要改成转发到443</h2><p>就这个地方卡了半天，无语了</p><div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">addEventListener</span>(<span class="string">&#x27;fetch&#x27;</span>, <span class="function"><span class="params">event</span> =&gt;</span> &#123;</span><br><span class="line">  event.<span class="title function_">respondWith</span>(<span class="title function_">handleRequest</span>(event.<span class="property">request</span>))</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">handleRequest</span>(<span class="params">request</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> url = <span class="keyword">new</span> <span class="title function_">URL</span>(request.<span class="property">url</span>);</span><br><span class="line">  url.<span class="property">protocol</span> = <span class="string">&#x27;https:&#x27;</span>; <span class="comment">// 使用HTTPS协议</span></span><br><span class="line">  url.<span class="property">port</span> = <span class="number">443</span>; <span class="comment">// 使用443端口</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> newRequest = <span class="keyword">new</span> <span class="title class_">Request</span>(url, &#123;</span><br><span class="line">    <span class="attr">method</span>: request.<span class="property">method</span>,</span><br><span class="line">    <span class="attr">headers</span>: request.<span class="property">headers</span>,</span><br><span class="line">    <span class="attr">body</span>: request.<span class="property">body</span>,</span><br><span class="line">    <span class="attr">redirect</span>: request.<span class="property">redirect</span></span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">fetch</span>(newRequest);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><img lazyload src="/images/loading.svg" data-src="https://imgss.s3.bitiful.net/2024/03/20/image-20240320135834492.png" alt="image-20240320135834492"></p><p>现在开严格模式也能访问到了，更安全了🤣</p><h2 id="后记">后记</h2><p>似乎cf本身也会提供免费的TLS，以后可以试试</p><h2 id="正常的域名解析">正常的域名解析</h2><p>比如a.b.c解析到ip:8700</p><p>起一个nginx当然是可以的，另外还可以用cloudflare</p><p>未备案的域名正常来说没法直接解析到国内服务器</p><p><img lazyload src="/images/loading.svg" data-src="%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AEssl/image-20240327220451618.png" alt="image-20240327220451618"></p><h3 id="写一个workers">写一个workers</h3><p>内容同上，但是里面不要有DirectIP</p><h3 id="配置workers路由">配置workers路由</h3><p>就是什么样的url会触发这个worker</p><h3 id="配置A解析记录">配置A解析记录</h3><p>让请求知道去哪</p>]]></content>
      
      
      <categories>
          
          <category> 杂记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ssl </tag>
            
            <tag> cloudflare </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java反射机制</title>
      <link href="/posts/%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/java%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6.html"/>
      <url>/posts/%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/java%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6.html</url>
      
        <content type="html"><![CDATA[<h2 id="参考">参考</h2><p><a class="link" href="https://sunweiguo.github.io/2019/02/04/java-basic/%E5%BD%BB%E5%BA%95%E7%90%86%E8%A7%A3java%E5%8F%8D%E5%B0%84/">https://sunweiguo.github.io/2019/02/04/java-basic/彻底理解java反射/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p><h2 id="演示使用">演示使用</h2><p>如何能利用反射机制来实现OCP</p><p><img lazyload src="/images/loading.svg" data-src="https://imgss.s3.bitiful.net/2024/03/19/20240319214021.png" alt></p><p><img lazyload src="/images/loading.svg" data-src="https://imgss.s3.bitiful.net/2024/03/19/20240319214108.png" alt></p><blockquote><p>generated by GPT</p></blockquote><p>这里给出一个简化的例子以演示如何使用<code>config.xml</code>文件和反射来动态创建对象。假设我们有一个<code>Button</code>接口和两个实现了该接口的类：<code>RoundButton</code>和<code>SquareButton</code>。我们还有一个<code>ButtonHandler</code>接口和一个实现了该接口的类：<code>MyButtonHandler</code>。</p><p>首先，我们定义<code>Button</code>接口和<code>ButtonHandler</code>接口：</p><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Button</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">click</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ButtonHandler</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">handle</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>然后，我们定义<code>RoundButton</code>、<code>SquareButton</code>和<code>MyButtonHandler</code>：</p><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RoundButton</span> <span class="keyword">implements</span> <span class="title class_">Button</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> ButtonHandler handler;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RoundButton</span><span class="params">(ButtonHandler handler)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.handler = handler;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">click</span><span class="params">()</span> &#123;</span><br><span class="line">        handler.handle();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SquareButton</span> <span class="keyword">implements</span> <span class="title class_">Button</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> ButtonHandler handler;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SquareButton</span><span class="params">(ButtonHandler handler)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.handler = handler;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">click</span><span class="params">()</span> &#123;</span><br><span class="line">        handler.handle();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyButtonHandler</span> <span class="keyword">implements</span> <span class="title class_">ButtonHandler</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handle</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Button clicked!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>接下来，我们创建<code>config.xml</code>文件：</p><div class="highlight-container" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">type</span>&gt;</span>com.example.RoundButton<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">handler</span>&gt;</span>com.example.MyButtonHandler<span class="tag">&lt;/<span class="name">handler</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure></div><p>最后，我们使用Java的反射机制来读取<code>config.xml</code>文件并创建对象：</p><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 解析XML文件（这里为了简化，我们假设已经获取到了type和handler）</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">type</span> <span class="operator">=</span> <span class="string">&quot;com.example.RoundButton&quot;</span>;</span><br><span class="line">            <span class="type">String</span> <span class="variable">handler</span> <span class="operator">=</span> <span class="string">&quot;com.example.MyButtonHandler&quot;</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 使用反射创建ButtonHandler对象</span></span><br><span class="line">            Class&lt;?&gt; handlerClass = Class.forName(handler);</span><br><span class="line">            <span class="type">ButtonHandler</span> <span class="variable">buttonHandler</span> <span class="operator">=</span> (ButtonHandler) handlerClass.getDeclaredConstructor().newInstance();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 使用反射创建Button对象</span></span><br><span class="line">            Class&lt;?&gt; buttonClass = Class.forName(type);</span><br><span class="line">            <span class="type">Button</span> <span class="variable">button</span> <span class="operator">=</span> (Button) buttonClass.getDeclaredConstructor(ButtonHandler.class).newInstance(buttonHandler);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 点击按钮</span></span><br><span class="line">            button.click();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>当你运行这个程序时，它会输出：“Button clicked!”。这就是我们通过读取<code>config.xml</code>文件和使用反射来动态创建<code>Button</code>和<code>ButtonHandler</code>对象的例子。</p><p>注意：这个例子非常简化，实际的XML解析和错误处理会更复杂。此外，确保你的类路径（classpath）正确设置，以便Java可以找到你的类。</p>]]></content>
      
      
      <categories>
          
          <category> 软件系统设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计原则 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Droplet购买记录</title>
      <link href="/posts/%E6%9D%82%E8%AE%B0/droplet%E8%B4%AD%E4%B9%B0%E8%AE%B0%E5%BD%95.html"/>
      <url>/posts/%E6%9D%82%E8%AE%B0/droplet%E8%B4%AD%E4%B9%B0%E8%AE%B0%E5%BD%95.html</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="fa9a1c9a159cbd3dad2fea8c327f6b3d20bf7e5e2cf2bd8f363229f91c496599">859c29499e97b37e25280a7293bbe187e746c5c12be59feb896b58848ba249e03d07ce5726e31b8fb2e8de3dd5b95222f09aadd9869aeadc4477380601920e318db2f2cde0477dd0a07b6de7108c9786fb92d648392efa02544036a09693a3e022628aaa1e9ddb9f6484e60aeb81d1398ea30d956b6aa113f186b7208b0eac3f98606471e5c70c6863579a8c9dcf98af13de4f3ad3a28f280dfcaf079d06e18a1ee8ba960f85d7954e721d2879fa6d17c4add25d39f1915c1a57041e06a28afaf1a9999ed9073cc82872b2da27b8a58719f0e819410b2d1a07dcc3295d4a63bb6d8245c6dfeaa4d949a844672f45a0bec30b0bacbdce1b73013f2cb44eafc259cccb9761607458115ef8ecbb6d5ade0b38fbcea43dc74a9ad964063987646537e370ece57c35e2840e71472c31867e317f4947f72a0c2e4f4eec0b34942243fe45a659b081c71680a864f9376922ab8fab96d1d3f8dbd50cfbf27ba5e48e3ef6bee152fc4b8fcccdae4c9b85dfec40ae7ad01e0dd2c5f252a08b48b1f2feacfa9c6e61cc8d5101404af1582743ac7bab45431856397e70e5fa8c264c0938ad5251ddb59bf3cb950cd72aa63c24fe3d85d96c7e099c8b3713cc6fee64db5fa6a0419a8b2cfe3660b68df666536f6e01e31064d23a4a612fafbe701c74eaa67db749c610cdfe2c3368cd8882f8447b74ee23e868f65350e1afa3c581b7db6b7a5406b3ea5bf58b61f2b20617b811f6b7b733f15c19b3d9c22c43294220f811311a84593233e184f79a8258bb2518528a92e082f9fecdbe02fb790385fae1d09ba9875f496ddfe0d15a0ad2e42e2246e9876e645976466740fa70f229f472ced3d89e357237ca0e9e9b395dcc7f5b795861cde21ac3d86512bb99a82d3c50ea7d5abe49c34b623ea704fc5acac8b761a4a92a2c14bef9115a83084eff740d0b1958c613b636e151266c6b06cc4b42bed4a2081b0d5086b2c6a0a77b31e664c39cccfca4ba4dff4bda07db32d02561079dd604db15cd9a56d2fe8364a884a0fa9b638d97ac9ef0dd2f9fc82251c2ab605f92d331f1851085940e1c2cbfd915485c0ffc6f66703899f908ea6745110406066b4f6f2210462516a44b9689e3e12b97047200a32c85a43fa1ce738b71913161fc228b387841d285a4c39c15d8476f0e8bfd04b634d70a881d9232db2e403b4711798dc5bebe071e4224e2de3edbf80de0ef64bb15b80f71fa811342d1a5aa08ad58074cae6cc36e5215fbeea5710bb141e551fecd933764942461a78b6494acfe5597674396958247c5b15f88f9b399f2bbd2facf74480d393bfbc7c0445a95dc7bd3e492cfb9eb58e903241ecdeb61363e8cb3f93f480a82c8cc85342399d14999ee5dcd325b1fa9232556a56dceb7e427f78c1ee21020200efe74e63cd5b7ccd7f384585c2bfab50d3f1a349986f6ec8d9ba6ea314c9ad270f627702aa71a36b5d6dca2d2ac4e904c6c41ba0562d871c9af0baa43bfced8aaa7d4ba1495afe5e83065b6a452a658e757fe1ec375f31373e8e9e62cacb5bf7f3f082930482cbd3fe06ba5036f73182b2c32a8a3c91838796000639e584f3d77f928b6ed53bba0a8d2cf925060aa5fc9e5d81c64cc9205d566ab15a4581b14c905972874bd9231b9cde593f2cef324ce51da8b81cbde96d170a92d6b059b07f35e57fe0045ce247ba5bd3f98e0b8487f0c573c9877c49c771a21e42a55efc43d5cb1f03862c052ab9f7e61d56b32424ab84048acd84890fb1dc5951719d1e186cadaee8bf31941a0e7bc43e123f60d42ae199a734558865174d0f525011afe15a2d938088c6b28bbb712ffdbb98607a809541aca0e576c</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-swup-reload-script src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 杂记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 服务器 </tag>
            
            <tag> Visa卡 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>copilot个人使用记录</title>
      <link href="/posts/%E5%AE%9E%E8%B7%B5%E8%AE%B0%E5%BD%95/copilot%E4%B8%AA%E4%BA%BA%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95.html"/>
      <url>/posts/%E5%AE%9E%E8%B7%B5%E8%AE%B0%E5%BD%95/copilot%E4%B8%AA%E4%BA%BA%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95.html</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="bc06de997b300b6917b76282b42b653659f9edb8ecdbbd825b187a56f3323110">859c29499e97b37e25280a7293bbe1870fb0069f4e3c381cf2cff805e582fe313c84aef027249cd80e8f6086822fcfc8a9c1686d684b0fa9b6f74d85f2c829b7a92ea42b9523d15f0e64c23883799babd73caaeea52345cd69341fc2b641bb18fdeff16211dab42962a43e8b2cac908bbe5837d3e8295dc5da050e0ffb7e9233cf78d28d3005778ae4c6778032d7890e285afb72145a6bf1837a65c269e1ff49a627167b24367fac4f68fb2a6f2df2836653d85fde4c99d35138d6570ed2de035584c781e014bf9b7cc8a5106648e20fd63dcda5c5bf157eb83b9f384009a726590ce4fa30e90bf7baaed28c1fe785585b24ccf83031955401b648956d316763296f5327fc343936085303a6bf9864dc459cfc5b7491e42f719ba18096f691c0727979329419d7eae213d9ae22b0eba942b6f3f0cb90fb28403b6c0320b1f68dd5715d1bb65c106a2bd3ebaf91e24b8da68bd717dc1641191bac45c6df7eac88be1e1a670dfbcc4187a9f66fcd30c891cc79a7229376a1402aa68b0e05f63cc42c9d2071c86a76f417b086c97f76e047f3aa28df63eb63762af7f27e3336740d901e263ca168efd3f4e32ca2f0b1c51cd970ce26a6ef09475487f41ca5067001bc306190a165cc88b9c68a792c44024446c665c75c84196e6d3dd3d2037acc5472dbb0309d38f5912c837caea28897c08256bc3c8f2d596196f61661b2b4a28d53b0d2c895028764de4316e09499d55176f5f7c4337891bd91c153690e43ee2bfa0d3bef000c2eff999e6a268b2e99d554d637be319a73e7b5e78caaae5f9ed7fc599f37eb5027d5118a1b4f57c0e1e74c8858fa2f32d55712f25cb41dd3de76976feadefda4ceb6aa26e120b25b9972e39c2a6ad323368f7107a9189af3d22197207ec0547536a723418c6c677a2cbb7b4d7f0a5e9b82000e2d01799b16c2d84e3600f2e53923a0a1356cb58afb5f9180298782d31ed3136f2d9e38696c9c816f649c9da95c9f307421b8bba7a0cf9e0a07fbfb585fdd4db1ff8d9f804e7e8e05ec685c409df6a6710fda7f1412f9f1d049e38f4a8a89dfa9e318ec5f4861a9caee64f0f61a6b86261d30697904f3b2668039cdf1d74a9059e4d81dcca89e71d8fcfdf5e8c4da27f44f1a4f2c8f3c99b41827ac526c9b0cc3d56287fcec21db3e2d61ecaefe90d66818aa10d34ad178e2de50106edffa1d62264d847a016ea88339e1559ce262a5359b09f536f68acec381b10021db9b3d467ceb6c8ee9b96ad726e7345b23cb4feab844595d15021bf9e03a593107f860879a4ce7abe3f5f0f04400dd30e1aa49f9204308661ab123dc5b19abcc03ad45a12d0cb99941d323340905e05362fe40b696bdd8edcfec6c8ae93f3284b14bf8c3fa1763ce0aa9f00a80aaefb75f479c863d4494d8c407150514ea8090dac86ef7ad81fc78f15f5f53f75cbde8d7093f657ca522acfc6ba8dae11d37e100f79c44c3194b2e8389956e6568bdc8acdb93c6daa7249c948e540eee6158bc3f13dd04ef0707473cf449c871514e16b117bd6c119b9ecb8fcc6d4148bba9b8edfbb1c0d51e03042b453349662cd71ae7e9b2ff8ed1db9d006c079bde050375cd54ca33ab097892f6f633c91974135093a01ac11581a6a5e60df965ddfbedac92daebfe4a261c0142ecd0af5289cc43f7fa6eb8aeb715c7a536e0bf4eca8a7515dfdbbb645810449af04c71558c942f22e18d4356dfe4be53d584eef27207cb2372b69a0fd2901ab308e899105bd09c22f021ca4449ba52e4d0e33ebe9da147c4df75651fcec26c023593154d77869d172a11eccac83f8ec28d05771b4c5001e38526f9432e557ff14f95f4420664bc06d952a599a80ef5bff0b09012b4f0a9905367fa36adb9258130f2147e35ba142aec1c2270ce247c15809c8dbf0c8154d9e01fe4fd8aac24778537a4b85e64f17ec4ca6a91dced0b3ab26a3f6c7df21b399e2fb554672ec4e92f685d29d2491dd23a7d29158ed5f513d669c530ffc65c3b0cecef1da889e904d01de4ddab900c8be28d2e165e4ee0c5b1cb1837a2ad361a9207e05cb6e265e785926eead72b92a1fed6e356b1b40b08d4a76ec21409e4fd2618144a2b2483f5c35cc137595c80aa0d64dd1c5fd06aba609b43dbd11cde6f21c636ccd4acd94782f6ec117a21b195382f1bfd9274446196e87ca46db03de30f09ed92182e2b46ae572ecb8958f2f4e804b712bc5e8abc7c5f14252515295b2cf219f1dd61c24ff92614b671c65236b92aeddc08f67ba00878</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-swup-reload-script src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 实践记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 摸鱼 </tag>
            
            <tag> 猎奇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3月14日心情日记</title>
      <link href="/posts/%E6%99%B4%E9%9B%A8%E5%BD%95/3%E6%9C%8814%E6%97%A5%E5%BF%83%E6%83%85%E6%97%A5%E8%AE%B0.html"/>
      <url>/posts/%E6%99%B4%E9%9B%A8%E5%BD%95/3%E6%9C%8814%E6%97%A5%E5%BF%83%E6%83%85%E6%97%A5%E8%AE%B0.html</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="21b8ae784a7112e815050a6e1e48520a76fac4195a8659c33ff504b0eea48b96">859c29499e97b37e25280a7293bbe1870fb0069f4e3c381cf2cff805e582fe31a0b62b3f02bb86c1a82861f72eb7dc2ed89104e1cf0aa877f9416af05521b5146cddb9e14368ebcb6c11646cd28146a33e5535d13ae150f795f4801bc1811ed78166304caf101bb9482cb0f6a60d2a5574967c2138f1ac1bd0a50866b818a1b00eca28dbebd2e8b2e735ab1b3fdbf247fa437f686a4c5534f286336e284112d8f30127614db58f0f296524c82a9cfe167d4e35f79e42ccf9f16c474c97337dba32ead3386a00bb03bdb7847474878b9ffb6295241cfa7a907ce4f03229115eab6dc1fd7c15391d07c9d7ba32c0f58b781dd2c2626a05670f4be3c59f370aab3909ec975dea332ea1a46a00e1722bdfecea812f737370b0f5426a2bc262acbccf35cf2e2ce32a44f179cb10ca5f0c5f234e548990e6d3b7944cd9fb2020669408cfc62e82c8f3e1011c04b6b1ed0525ec74eb660210c66f164ee3e04cea320ff092e707e288a2f4a6d834fbc01e4ab47ca82ff1ea2c8d470610320c926f0dd8fd7a5693380a2c4ae53622a8d31f1f767f2ab127d3e15c9c8ff03bcd6af7279a0ef02f59ab7bf625a236442efa4271db170a2cf9591ceae581737158f0a7a562afb633ad9cd4782d9d2c57868db3096ae89473febcd2cb90ec32e027a5c52a88ffb47a1a4a77c762cacf9279aedb00eaef1eb704d7c91d84a86c22b177bcb4881c75863e3f10f639fd864a1325fd351e9af741a512168b8e2aae64325f4cd3bfbbd346fef74f0189fd1fa8ddf61a51c699c31c0a089d75ee01ea806cf6e37f0f8c3f36f9baa6913e2de6644639659afc70259d9321078cf5e955710bcccafffefa2379f5d4ae31939f380ad97e0fc82b976093601f57478d4b0c32f6af890a404f965fc888ee9d3541bddc674b4f6a0f76317678991106022c548c99b28f7ec689a40ad4b88524bad1252f99107b0deac217c3763de602de54704a736844daa2d53e156341965caaf1cd6987701d6a3af484ea808558b190670064943f98ea0aabfae0fc0192186be7f8d0e120ebe82b1eac484871480918eb8cee9c21258806e611b810178a050e45070308e4ac311bfed387520f89621ef9e0220e6ced5a490ae80d2af3443c7add22948428df9b87330a0457d6d5e904ede9ad06062dc128d8d4708bd1cdcaa22ff9dc56f46f313a4b4a92eb4803ab20b41e63e63fe6feb063</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-swup-reload-script src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 晴雨录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日记 </tag>
            
            <tag> 多云 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Commit规范学习记录</title>
      <link href="/posts/%E5%B7%A5%E5%85%B7%E5%AD%A6%E4%B9%A0/commit%E8%A7%84%E8%8C%83%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95.html"/>
      <url>/posts/%E5%B7%A5%E5%85%B7%E5%AD%A6%E4%B9%A0/commit%E8%A7%84%E8%8C%83%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95.html</url>
      
        <content type="html"><![CDATA[<h2 id="参考">参考</h2><p><a class="link" href="https://www.conventionalcommits.org/zh-hans/v1.0.0/#%e7%ba%a6%e5%ae%9a%e5%bc%8f%e6%8f%90%e4%ba%a4%e8%a7%84%e8%8c%83">https://www.conventionalcommits.org/zh-hans/v1.0.0/#约定式提交规范 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p><p><a class="link" href="https://cheatsheets.zip/conventional-commits">https://cheatsheets.zip/conventional-commits <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p><h2 id="自己的例子">自己的例子</h2><h3 id="docs">docs</h3><p>用于修改文档，例如修改 README 文件、API 文档等</p><p>Changes in documentation only</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docs: update setup section of README</span><br></pre></td></tr></table></figure></div><h3 id="style">style</h3><p>用于修改代码的样式，例如调整缩进、空格、空行等</p><p>Code changes that do not impact the functionality</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">style(login): correct indentation <span class="keyword">in</span> login component</span><br></pre></td></tr></table></figure></div>]]></content>
      
      
      <categories>
          
          <category> 工具学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 规范学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LLM相关术语理解</title>
      <link href="/posts/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/llm%E7%9B%B8%E5%85%B3%E6%9C%AF%E8%AF%AD%E7%90%86%E8%A7%A3.html"/>
      <url>/posts/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/llm%E7%9B%B8%E5%85%B3%E6%9C%AF%E8%AF%AD%E7%90%86%E8%A7%A3.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>读论文时有好多模型或者专业名词不理解，有时候问了GPT又记不住，故此记录</p></blockquote><h1>BiLSTM &amp; MLP</h1><p>是的，抱歉之前的回答可能有些混淆。在这个上下文中，&quot;a continuous sequence of numbers&quot;指的是通过Prompt Encoder中的BiLSTM生成的隐藏状态序列，而&quot;the embedding layer&quot;指的是MLP（多层感知机）。</p><p>具体来说：</p><ol><li><p><strong>BiLSTM（双向长短时记忆网络）</strong>：Prompt Encoder中的BiLSTM负责将伪提示( p )转换为一个连续的数值序列，即隐藏状态序列。这个序列是通过在两个方向（前向和后向）处理输入来捕获上下文信息和令牌之间的关系。</p></li><li><p><strong>MLP（多层感知机）</strong>：隐藏状态序列（a continuous sequence of numbers）通过ReLU激活的MLP作为最后一个步骤进行处理。MLP将隐藏状态序列作为输入，并进一步转换为最终的提示嵌入（( e_P )）。MLP可以看作是一个神经网络层，它通过一系列非线性变换来提取和组合隐藏状态中的高级特征，并生成用于指导语言模型生成代码摘要的最终嵌入向量。</p></li></ol><p>因此，BiLSTM和MLP分别对应了生成连续数值序列和最终嵌入向量的过程。BiLSTM通过处理输入生成连续数值序列，然后这个序列通过MLP进行进一步处理，生成最终的提示嵌入向量，用于指导语言模型生成代码摘要。</p><h1>Early stopping</h1><p>在机器学习中，早停策略（early stopping）是一种防止过拟合的技术。它的工作方式是在训练时监视模型在验证集上的表现。如果在连续的若干轮次（epochs）中，模型在验证集上的表现没有改善，那么训练就会提前停止。这种策略可以帮助我们避免在训练数据上过度训练模型，从而导致在未知数据（如测试集）上表现不佳。</p><p>&quot;Early stopping patience&quot;是早停策略中的一个参数，表示我们愿意容忍模型在验证集上的表现在多少轮次内没有改善。在你提到的这个例子中，早停耐心被设置为4，这意味着如果模型在连续的4个轮次中，验证集上的BLEU得分没有改善，那么训练将提前结束。</p><p>BLEU（Bilingual Evaluation Understudy）得分是一种常用于评估机器翻译或文本生成任务的度量标准，它比较了机器生成的文本和人工编写的参考文本之间的相似性。在这个情况下，它被用来衡量代码摘要生成的质量。</p><h1>LLM Agent</h1><p>&quot;Agent&quot;这个词在计算机科学和人工智能领域中通常被用来表示一个自主的、可以执行某种任务的实体。这个实体可以是一个软件程序，也可以是一个硬件设备，它具有一定的智能，可以根据环境的变化调整自己的行为。</p><p>在你提供的这段文本中，“RepairAgent”是一个基于机器学习的自主代理，用于自动修复程序。这意味着它是一个可以自主运行的软件实体，能够学习如何修复编程错误，并在检测到这些错误时自动进行修复。这个代理的&quot;智能&quot;来自于机器学习模型，该模型可以从大量的数据中学习到如何有效地进行程序修复。</p><p>总的来说，&quot;Agent&quot;在这种上下文中的含义是一个具有一定智能，能够执行特定任务的实体。</p><blockquote><p>generateed by gpt-4</p></blockquote><p>A promising way of using these abilities are LLM-based agents that autonomously plan and execute actions to achieve a goal. The basic idea is to query the LLM with a prompt that contains the current state of the world, the goal to be achieved, and a set of actions that could be performed next. The model than decides which action to perform, and the feedback from performing the action is integrated into the next prompt. One way to represent “actions” is through tools that the model can invoke to interact with the world [26], [27]</p><p>利用这些能力的一种有前途的方法是基于 LLM 的代理，它可以自主规划和执行行动以实现目标。其基本思路是向 LLM 询问一个提示，其中包含当前世界的状态、要实现的目标以及下一步可以执行的一系列行动。然后由模型决定执行哪项操作，并将执行操作的反馈整合到下一个提示中。表示 &quot;行动 &quot;的一种方法是通过模型可以调用的工具与世界进行交互[26]，[27]。</p><blockquote><p>摘自某篇论文</p></blockquote><p>个人感觉有点类似于强化学习中提到的智能体Agent这个概念？</p>]]></content>
      
      
      <categories>
          
          <category> 论文阅读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LLM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>周处除三害</title>
      <link href="/posts/%E8%A7%82%E5%BD%B1%E8%AE%B0%E5%BD%95/%E5%91%A8%E5%A4%84%E9%99%A4%E4%B8%89%E5%AE%B3.html"/>
      <url>/posts/%E8%A7%82%E5%BD%B1%E8%AE%B0%E5%BD%95/%E5%91%A8%E5%A4%84%E9%99%A4%E4%B8%89%E5%AE%B3.html</url>
      
        <content type="html"><![CDATA[<h2 id="观看之前">观看之前</h2><p>难得花钱看流媒体上有的电影，在Netflix观感还是不错的（除了字幕大的有点哈人</p><p>6块钱一个月还算值，可惜我只看了一部ww</p><h2 id="电影内容">电影内容</h2><p>一开始看到电影名都震惊我了，因为我以为这故事仅限于在宜兴流传hh</p>]]></content>
      
      
      <categories>
          
          <category> 观影记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 电影 </tag>
            
            <tag> 生活 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端康复训练</title>
      <link href="/posts/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/%E5%89%8D%E7%AB%AF%E5%BA%B7%E5%A4%8D%E8%AE%AD%E7%BB%83.html"/>
      <url>/posts/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/%E5%89%8D%E7%AB%AF%E5%BA%B7%E5%A4%8D%E8%AE%AD%E7%BB%83.html</url>
      
        <content type="html"><![CDATA[<h2 id="上传并修改图片（适用于头像">上传并修改图片（适用于头像</h2><p><a class="link" href="https://github.com/dai-siki/vue-image-crop-upload?tab=readme-ov-file">https://github.com/dai-siki/vue-image-crop-upload?tab=readme-ov-file <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p><p>修改头像，效果如下</p><img lazyload src="/images/loading.svg" data-src="/posts/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/%E5%89%8D%E7%AB%AF%E5%BA%B7%E5%A4%8D%E8%AE%AD%E7%BB%83/image-20231218205829320.png" class title="image-20231218205829320"><h2 id="商品上传界面">商品上传界面</h2><h2 id="计算属性和ref">计算属性和ref</h2><p>ref是页面和数据绑定的那种意思</p><p>computed则是某个数据可以根据依赖的ref数据进行改变</p><h2 id="ref和reactive">ref和reactive</h2><p>在 Vue 3 的 Composition API 中，<code>reactive</code> 创建的响应式对象的属性可以直接访问，不需要 <code>.value</code>。</p><p>例如，如果你有一个 <code>reactive</code> 创建的响应式对象 <code>submitGoodsForm</code>：</p><div class="highlight-container" data-rel="Ts"><figure class="iseeu highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> submitGoodsForm = <span class="title function_">reactive</span>(&#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">  <span class="attr">price</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">  <span class="attr">goodsLevel</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">  <span class="attr">dscrip</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">  <span class="attr">userId</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">  <span class="attr">goodsId</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></div><p>你可以直接访问它的 <code>name</code> 属性，如 <code>submitGoodsForm.name</code>，不需要使用 <code>submitGoodsForm.name.value</code>。</p><p>然而，如果你使用 <code>ref</code> 创建响应式引用，那么你需要使用 <code>.value</code> 来访问或修改它的值。例如：</p><div class="highlight-container" data-rel="Ts"><figure class="iseeu highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> count = <span class="title function_">ref</span>(<span class="number">0</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(count.<span class="property">value</span>)  <span class="comment">// 输出 0</span></span><br><span class="line">count.<span class="property">value</span> = <span class="number">1</span>  <span class="comment">// 修改 count 的值为 1</span></span><br></pre></td></tr></table></figure></div><p>所以，是否需要使用 <code>.value</code> 取决于你是使用 <code>reactive</code> 还是 <code>ref</code> 创建的响应式数据。</p><h2 id="安装模块">安装模块</h2><p><code>npm i --save-dev @types/vuelidate</code>和之前的<code>npm install vuelidate --save</code>命令是有区别的。</p><ol><li><code>npm install vuelidate --save</code>：这个命令是用来安装vuelidate库的，这是一个Vue.js的表单验证库。<code>--save</code>选项会将vuelidate添加到你的项目的<code>package.json</code>文件的<code>dependencies</code>中。</li><li><code>npm i --save-dev @types/vuelidate</code>：这个命令是用来安装@types/vuelidate的，这是一个为vuelidate库提供TypeScript类型定义的第三方库。<code>--save-dev</code>选项会将@types/vuelidate添加到你的项目的<code>package.json</code>文件的<code>devDependencies</code>中，这意味着这个库只在开发环境中需要，而在生产环境中不需要。</li></ol><p>然而，我需要指出的是，@types/vuelidate可能并不存在。@types库是由社区提供的，用于为没有提供TypeScript类型定义的JavaScript库提供类型定义。并不是所有的JavaScript库都有对应的@types库。如果@types/vuelidate不存在，你可能需要自己为vuelidate库编写类型定义，或者在你的代码中使用JavaScript而不是TypeScript。</p><p>后者有用，不知道为啥，可能是因为用的ts?</p><h2 id="表单验证">表单验证</h2><p><a class="link" href="https://github.com/vuelidate/vuelidate/tree/next">https://github.com/vuelidate/vuelidate/tree/next <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p><h2 id="异步函数">异步函数</h2><p>在 TypeScript（以及现代 JavaScript）中，<code>let</code> 和 <code>const</code> 是用于声明变量的关键字，它们都提供了块级作用域（block scope），这是与传统的 <code>var</code> 关键字（提供函数级作用域或全局作用域）的主要区别。以下是 <code>let</code> 和 <code>const</code> 的区别：</p><ol><li><strong>let</strong>: 使用 <code>let</code> 声明的变量可以在声明之后重新赋值。这意味着变量的值是可以改变的。</li><li><strong>const</strong>: 使用 <code>const</code> 声明的是常量，一旦赋值后就不能再改变。尝试重新赋值 <code>const</code> 声明的变量将导致一个错误。注意，对于对象或数组，<code>const</code> 确保变量标识符不能重新赋值指向另一个引用，但对象或数组的内容仍然可以被修改。</li></ol><p>关于异步函数，如果 <code>uploadPhoto</code> 函数是 <code>async</code> 的，这意味着它会返回一个 <code>Promise</code>。当你调用这个函数时，你可以使用 <code>await</code> 关键字来等待 <code>Promise</code> 完成，或者使用 <code>.then()</code> 和 <code>.catch()</code> 方法来处理完成（或拒绝）的 <code>Promise</code>。</p><p>这里有一个例子：</p><div class="highlight-container" data-rel="Typescript"><figure class="iseeu highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">uploadPhoto</span>(<span class="params">file: File</span>): <span class="title class_">Promise</span>&lt;<span class="built_in">any</span>&gt; &#123;</span><br><span class="line">  <span class="comment">// 异步操作，例如上传文件</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 await</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">handleUpload</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> result = <span class="keyword">await</span> <span class="title function_">uploadPhoto</span>(someFile);</span><br><span class="line">    <span class="comment">// 在这里处理 result</span></span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    <span class="comment">// 处理错误</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者使用 .then() 和 .catch()</span></span><br><span class="line"><span class="title function_">uploadPhoto</span>(someFile)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 在这里处理 result</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 处理错误</span></span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure></div><p>如果函数是 <code>async</code> 的，你必须理解其返回值将总是一个 <code>Promise</code>，并且你需要相应地处理这个 <code>Promise</code>。例如，如果你在一个非异步函数中调用 <code>uploadPhoto</code> 并尝试直接访问返回值，你将得到一个 <code>Promise</code> 对象，而不是 <code>uploadPhoto</code> 操作完成后的结果。这就是为什么通常在调用 <code>async</code> 函数时使用 <code>await</code> 关键字，或者使用 <code>.then()</code> 和 <code>.catch()</code> 方法来处理异步结果。</p>]]></content>
      
      
      <categories>
          
          <category> 前端开发记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>强化学习记录</title>
      <link href="/posts/23-Fall-Courses-MachineLearning/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95.html"/>
      <url>/posts/23-Fall-Courses-MachineLearning/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>参考链接</p><p><a class="link" href="https://blog.csdn.net/weixin_51545953/article/details/127466280">https://blog.csdn.net/weixin_51545953/article/details/127466280 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p></blockquote><h1>Transition与ReplayMemory</h1><ol><li><strong>Transition</strong>（过渡）：Transition 是一个命名元组（named tuple），用来表示在环境中发生的一个单一的过渡。这个过渡包括了代理（智能体）观察到的情境（state）和采取的动作（action），以及随后的情境（next_state）和奖励（reward）结果。这个概念用来记录代理在环境中的互动和反馈，有助于后续的学习和决策。</li><li><strong>ReplayMemory</strong>（经验回放记忆）：ReplayMemory 是一个有限大小的循环缓冲区，用来存储代理观察到的过渡。它的目的是为了重复使用这些数据。通过从中随机采样，可以获得一批不相关的过渡数据，用于训练深度强化学习模型，特别是DQN。经验回放记忆的存在对于稳定和改进DQN的训练过程非常重要，因为它有助于减少训练中的数据相关性问题，提高模型的效率和性能。</li></ol><p>总之，这段文字描述了在深度强化学习中使用经验回放记忆的概念，以及它的两个组成部分：Transition 用于记录单个情境转换，ReplayMemory 用于存储这些过渡数据并支持随机采样以进行训练。这一技术有助于提高深度强化学习模型的训练效果。</p><h2 id="举例">举例</h2><p>当我们训练一个深度强化学习模型（比如一个控制机器人玩游戏的模型），这个模型需要不断地学习如何在特定情境下采取正确的行动。经验回放记忆就像是这个模型的记忆系统。</p><p><strong>Transition</strong>（过渡）是一种方式来记录代理在环境中的经历。假设我们正在训练一个智能机器人玩一个视频游戏。每个Transition可以看作是一条记录，记录了机器人在游戏中的一次互动。这个记录包括了机器人看到的游戏画面（情境），机器人采取的行动（比如移动、跳跃），以及之后获得的奖励（分数增加或减少）以及下一个情境。这些记录可以帮助机器人学习如何在不同情境下做出正确的决策。</p><p><strong>ReplayMemory</strong>（经验回放记忆）就像是机器人的记忆库。它保存了很多过去的互动记录，而且它不仅仅是保存，还会不断更新。这个记忆库的好处在于，当我们要教机器人如何玩游戏的时候，我们可以随机挑选一些过去的记录，而不是只用最新的记录。这就好像是在学习一门新技能时，我们不仅仅会记住最近的练习，还会反复回顾过去的练习，这样我们的学习更加稳定。</p><p>举个例子，如果机器人曾经在游戏中遇到过一个特殊的敌人，但是很长时间没有再遇到，如果我们只用最新的记录来训练它，它可能会忘记如何应对这个敌人。但是如果我们从ReplayMemory中随机挑选过去的记录，就可以让机器人不断回顾之前的经验，从而更好地应对各种情况。</p><p>总之，经验回放记忆是一种方法，让深度强化学习模型能够从过去的经验中学习，而不仅仅依赖于最新的互动数据，从而提高模型的稳定性和性能。</p><h1>DQN</h1><p>DQN（Deep Q-Network）是一种深度强化学习模型，旨在解决强化学习问题，特别是在离散动作空间中的问题。它是由DeepMind开发的，最初被广泛应用于训练智能代理来玩视频游戏，如Atari 2600游戏。DQN以其在处理高维度状态空间和复杂任务中的出色表现而著名。</p><p>DQN的核心原理包括以下要点：</p><ol><li><strong>Q-Value Function</strong>（Q-值函数）：DQN的目标是学习一个称为Q-值函数的函数，通常用Q(s, a)表示。这个函数估计在给定状态s下采取动作a所获得的累积奖励的期望值。换句话说，它告诉代理在不同状态下采取不同动作的好坏程度。</li><li><strong>深度神经网络</strong>：DQN使用深度神经网络来估计Q-值函数。这个神经网络通常是卷积神经网络（CNN），因为它能够有效地处理高维度的图像输入。神经网络的输入是环境状态的表示，输出是每个可能动作的Q-值。</li><li><strong>经验回放</strong>：DQN引入了经验回放记忆（Experience Replay）的概念。经验回放是一种数据存储和随机采样方法，它允许代理存储和重用过去的经验，以减少数据的相关性，从而提高训练的稳定性。代理会在每个时间步将经验（状态、动作、奖励、下一个状态）存储在一个经验回放缓冲区中，并从中随机抽样小批量数据来进行训练。</li><li><strong>目标网络</strong>：为了提高稳定性，DQN还使用了两个神经网络：一个是用来选择动作的主网络，另一个是用来估计目标Q值的目标网络。目标网络的参数是固定的一段时间，然后逐渐更新以逼近主网络的估计值。这有助于减轻训练中的不稳定性问题。</li></ol><p><strong>DQN的训练目标是最小化Q-值函数的均方误差，以使其逼近真实的Q值。通过与环境互动并不断优化神经网络参数，DQN可以学习在不同情境下采取什么动作来最大化长期奖励。</strong></p><p>总之，DQN是深度强化学习的一种方法，它使用深度神经网络来学习代理在不同情境下如何做出最佳决策。它在处理高维状态空间和离散动作空间的问题中表现出色，使得智能代理能够在各种环境中表现出色。</p><h1>ReplayMemory</h1><div class="highlight-container" data-rel="Py"><figure class="iseeu highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Transition = namedtuple(<span class="string">&#x27;Transition&#x27;</span>,</span><br><span class="line">                        (<span class="string">&#x27;state&#x27;</span>, <span class="string">&#x27;action&#x27;</span>, <span class="string">&#x27;next_state&#x27;</span>, <span class="string">&#x27;reward&#x27;</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ReplayMemory</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, capacity</span>):</span><br><span class="line">        self.memory = deque([], maxlen=capacity)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">push</span>(<span class="params">self, *args</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;Save a transition&quot;&quot;&quot;</span></span><br><span class="line">        self.memory.append(Transition(*args))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sample</span>(<span class="params">self, batch_size</span>):</span><br><span class="line">        <span class="keyword">return</span> random.sample(self.memory, batch_size)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__len__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(self.memory)</span><br></pre></td></tr></table></figure></div><p>这是一个Python类<code>ReplayMemory</code>，它似乎是为了实现经验回放记忆（Replay Memory）的功能而设计的。经验回放记忆是在深度强化学习中用于存储和随机采样代理与环境互动的记录的数据结构。以下是该类及其方法的简要解释：</p><ol><li><code>__init__(self, capacity)</code>：这是类的构造函数，它初始化ReplayMemory对象。它接受一个<code>capacity</code>参数，表示Replay Memory的最大容量，即可以存储多少条记录。</li><li><code>push(self, *args)</code>：这是一个方法，用于将代理与环境互动的记录（Transition）保存到Replay Memory中。它接受不定数量的参数<code>*args</code>，这些参数将被传递给Transition的构造函数以创建一个新的Transition对象，然后将其添加到Replay Memory中。</li><li><code>sample(self, batch_size)</code>：这是一个方法，用于从Replay Memory中随机采样一批记录。它接受一个<code>batch_size</code>参数，表示要采样的记录数量。它使用<code>random.sample</code>函数从Replay Memory中随机选择指定数量的记录，并以列表的形式返回这些记录。</li><li><code>__len__(self)</code>：这是一个特殊方法，用于获取Replay Memory中当前存储的记录数量。它可以通过内置的<code>len</code>函数来访问，以确定Replay Memory中的记录数。</li></ol><p>下面是一个使用示例：</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建ReplayMemory对象，容量为1000</span></span><br><span class="line">capacity = <span class="number">1000</span></span><br><span class="line">memory = ReplayMemory(capacity)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将一条记录添加到Replay Memory</span></span><br><span class="line">state = [<span class="number">0.1</span>, <span class="number">0.2</span>, <span class="number">0.3</span>]</span><br><span class="line">action = <span class="number">1</span></span><br><span class="line">next_state = [<span class="number">0.2</span>, <span class="number">0.3</span>, <span class="number">0.4</span>]</span><br><span class="line">reward = <span class="number">0.5</span></span><br><span class="line">memory.push(state, action, next_state, reward)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从Replay Memory中随机采样一批记录</span></span><br><span class="line">batch_size = <span class="number">32</span></span><br><span class="line">sampled_batch = memory.sample(batch_size)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取Replay Memory中记录的数量</span></span><br><span class="line">memory_length = <span class="built_in">len</span>(memory)</span><br></pre></td></tr></table></figure></div><p>在上述示例中，首先创建了一个<code>ReplayMemory</code>对象，然后将一条记录添加到Replay Memory中。接着，使用<code>sample</code>方法随机采样了一批记录，最后使用<code>__len__</code>方法获取了Replay Memory中记录的数量。这个类有助于管理和维护强化学习中所需的经验回放数据。</p><h1>select_action</h1><p><strong>select_action</strong> 函数：这个函数用于选择代理在给定状态下采取的动作，通常遵循 ε-贪心策略（epsilon-greedy policy）。 ε-贪心策略是一种平衡探索和利用的策略，其中有一个 ε（epsilon）的概率用于随机选择一个动作，以便代理可以探索新的动作，而 1-ε 的概率用于根据模型的Q值选择一个最优动作。初始时，ε 的值为 EPS_START，然后随着时间逐渐以指数方式衰减至 EPS_END。EPS_DECAY 控制衰减速率。</p><h1>plot_duration</h1><p><strong>plot_durations</strong> 函数：这个函数是用于绘制训练过程中每一轮（episode）的持续时间，并计算最近100轮的平均值。在强化学习中，通常使用“滚动平均”来评估模型性能，因为这可以平滑不稳定的训练过程。这个函数将在训练的主循环中调用，用于绘制和更新训练进展的图表。最后的评估通常基于最近100个episode的平均表现。</p><h1>折扣因子GAMMA</h1><p><code>GAMMA</code> 是折扣因子（discount factor），在强化学习中用于计算折扣回报（discounted return）。折扣回报是一个代理在一系列时间步内获得的奖励的折扣总和。</p><p>具体来说，折扣回报是通过以下方式计算的：</p><ol><li>代理在每个时间步 t 处获得奖励 r(t)。</li><li>这些奖励 r(t) 从当前时间步 t 开始向未来的时间步 t+1, t+2, … 进行折扣。</li><li>折扣的过程通过乘以折扣因子 <code>GAMMA</code> 来实现。</li></ol><p>折扣回报 G(t) 在时间步 t 处的计算方式是：</p><p>G(t) = r(t) + GAMMA * r(t+1) + GAMMA^2 * r(t+2) + GAMMA^3 * r(t+3) + …</p><p><code>GAMMA</code> 的值通常在 0 到 1 之间，控制了对未来奖励的重要性。具体来说：</p><ul><li>当 <code>GAMMA</code> 接近 1 时，未来奖励具有较高的重要性，代理更关注长期回报。</li><li>当 <code>GAMMA</code> 接近 0 时，未来奖励的影响几乎被忽略，代理更关注即时奖励。</li></ul><p>在实际的强化学习任务中，选择合适的 <code>GAMMA</code> 值取决于任务的性质，例如，如果任务需要代理长期规划和考虑未来奖励，那么较高的 <code>GAMMA</code> 值可能更合适。然而，它也可以根据任务的要求进行调整，以权衡长期和短期奖励的重要性。</p><h1>目标网络</h1><p>目标网络即target_net</p><p>policy_net是参数一直在变化的</p><p><code>policy_net</code> 和 <code>target_net</code> 是DQN算法中的两个神经网络，它们有不同的作用，并协同工作以稳定学习过程。让我更详细地解释它们的作用：</p><ol><li><p><strong><code>policy_net</code></strong>：这是DQN算法中的主要神经网络，它用于估计每个状态下采取每个动作的Q值。具体来说，对于给定的状态，<code>policy_net</code>会输出一个Q值向量，其中每个元素对应一个可能的动作，表示采取该动作时的Q值。智能体根据这些Q值来选择最佳的动作。<code>policy_net</code>的参数会在训练中不断更新，以使其能够更准确地估计Q值。</p></li><li><p><strong><code>target_net</code></strong>：这是一个目标神经网络，其主要作用是用于估计未来状态下的最大Q值。在Q-learning的更新公式中，需要估计下一个状态（s’）下的最大Q值，但由于在训练中不断变化的<code>policy_net</code>的参数，这可能导致目标值不稳定。因此，引入了<code>target_net</code>，它的参数是一个<code>policy_net</code>在某个时刻的快照，不会频繁更新。在训练中，可以使用<code>target_net</code>来计算目标Q值，以减小目标值的不稳定性，从而使学习过程更稳定。</p></li></ol><p>具体来说，<code>target_net</code>的参数不会像<code>policy_net</code>那样频繁更新，而是定期进行更新，例如每隔一定数量的步骤。这使得目标Q值更稳定，有助于减小训练中的振荡和不稳定性。</p><p>总之，<code>policy_net</code>用于估计当前状态下的Q值，而<code>target_net</code>用于估计未来状态下的最大Q值，通过这两个网络的协同工作，DQN算法能够更稳定地学习并提高智能体的性能。</p><h1>关于优化器</h1><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 优化模型，首先将梯度置为0，然后进行反向传播，最后进行梯度裁剪</span></span><br><span class="line">optimizer.zero_grad()</span><br><span class="line">loss.backward()</span><br><span class="line">torch.nn.utils.clip_grad_value_(policy_net.parameters(), <span class="number">100</span>)</span><br><span class="line"><span class="comment"># 使用优化器来更新模型参数，使得梯度下降</span></span><br><span class="line">optimizer.step()</span><br></pre></td></tr></table></figure></div><p>这段代码是深度学习模型训练的标准步骤，用于优化模型的权重以减小损失函数的值。以下是对每个步骤的解释：</p><ol><li><code>optimizer.zero_grad()</code>: 这一行代码的目的是将模型参数的梯度（gradients）清零。在反向传播算法中，梯度是损失函数相对于模型参数的导数，用来指示如何更新模型参数以减小损失。在每一次训练迭代之前，都需要清零梯度，以避免累积的梯度影响后续迭代。</li><li><code>loss.backward()</code>: 这是反向传播的步骤，用于计算模型参数相对于损失函数的梯度。它分析模型的预测和真实目标之间的差距，然后反向传播这个误差，以计算每个参数的梯度。这一步是为了计算出如何调整模型参数以减小损失。</li><li><code>torch.nn.utils.clip_grad_value_(policy_net.parameters(), 100)</code>: 这行代码进行了梯度裁剪（gradient clipping）。梯度裁剪是一种处理梯度爆炸问题的技巧，它限制了梯度的最大值，防止梯度变得过大，从而导致训练不稳定。在这里，梯度的值被裁剪到最大值为100，即如果任何梯度的绝对值大于100，它们将被截断为100。这有助于防止梯度爆炸问题。</li><li><code>optimizer.step()</code>: 最后，这一行代码使用优化器来更新模型参数。根据计算的梯度，优化器会根据指定的优化算法（如随机梯度下降或Adam）来微调模型的参数，以减小损失函数的值。这个步骤是用来实际更新模型权重，使模型更好地拟合训练数据。</li></ol><p>综上所述，这些步骤组成了深度学习模型的训练过程，其中包括了清零梯度、反向传播计算梯度、梯度裁剪以处理梯度爆炸问题，以及使用优化器来更新模型参数。这些步骤循环迭代，直到模型达到满意的性能或训练停止的条件被满足。</p>]]></content>
      
      
      <categories>
          
          <category> 23-Fall-Courses-MachineLearning </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>docker常用命令</title>
      <link href="/posts/%E5%B7%A5%E5%85%B7%E5%AD%A6%E4%B9%A0/docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.html"/>
      <url>/posts/%E5%B7%A5%E5%85%B7%E5%AD%A6%E4%B9%A0/docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.html</url>
      
        <content type="html"><![CDATA[<h1>docker run</h1><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --network mongo-net-1012 --<span class="built_in">rm</span> mongo mongosh --host my-mongo-1012</span><br></pre></td></tr></table></figure></div><ol><li><code>docker run</code>: 这是Docker的运行容器命令，用于创建和启动一个新的容器。</li><li><code>-it</code>: 这两个选项组合表示以交互式模式运行容器并分配一个伪终端（TTY）。这允许你在容器内部与终端进行交互。</li><li><code>--network mongo-net-1012</code>: 这个选项将容器连接到名为 <code>mongo-net-1012</code> 的Docker网络，以便容器之间可以相互通信。</li><li><code>--rm</code>: 这个选项指示Docker在容器退出时自动删除容器。这是为了确保容器不会留在系统中，以避免占用存储空间。</li><li><code>mongo</code>: 这是要运行的Docker镜像的名称，它表示你要使用MongoDB官方镜像来创建容器。（这里也可以用image:tag，不加的话默认latest)</li><li><code>mongosh --host my-mongo-1012</code>: 这是要在容器内运行的命令。<code>mongosh</code> 是MongoDB的官方命令行客户端，<code>--host my-mongo-1012</code> 指定了MongoDB服务器的主机名为 <code>my-mongo-1012</code>，以便连接到该服务器。</li></ol><h1>docker ps</h1><p>ps即Process Status</p><h1>启动/停止容器</h1><p>要启动和停止Docker容器，你可以使用以下两个常用的Docker命令：</p><ol><li><p><strong>启动容器</strong>：</p><p>使用 <code>docker start</code> 命令可以启动一个已经创建的但是已经停止的容器。你需要提供容器的名称或容器ID作为参数。例如：</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker start CONTAINER_NAME_OR_ID</span><br></pre></td></tr></table></figure></div><p>例如，如果你有一个名为 <code>my-container</code> 的容器，要启动它，可以运行：</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker start my-container</span><br></pre></td></tr></table></figure></div></li><li><p><strong>停止容器</strong>：</p><p>使用 <code>docker stop</code> 命令可以停止一个正在运行的容器。你同样需要提供容器的名称或容器ID作为参数。例如：</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stop CONTAINER_NAME_OR_ID</span><br></pre></td></tr></table></figure></div><p>例如，如果你有一个名为 <code>my-container</code> 的容器，要停止它，可以运行：</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stop my-container</span><br></pre></td></tr></table></figure></div></li></ol><p>这些命令允许你在需要时启动或停止容器，以便有效地管理你的Docker容器。</p><blockquote><p>使用names来停止也是可以的</p><p>比如docker stop my-mongo-1012</p></blockquote><p>停止所有容器</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stop $(docker ps -q)</span><br></pre></td></tr></table></figure></div><blockquote><ol><li><p><code>docker ps -q</code>:</p><ul><li>这个命令用于列出运行中的容器的容器ID，而不包括已经停止的容器。</li><li><code>-q</code> 选项代表 “quiet”，它仅返回容器的ID而不显示容器的详细信息。</li></ul><p>例如，执行 <code>docker ps -q</code> 将列出当前正在运行的容器的ID列表。</p></li><li><p><code>docker ps -a</code>:</p><ul><li>这个命令用于列出所有容器，包括正在运行和已经停止的容器。</li><li><code>-a</code> 选项代表 “all”，它显示所有容器的详细信息，包括容器ID、镜像、创建时间、状态等。</li></ul><p>例如，执行 <code>docker ps -a</code> 将列出所有容器的详细信息，无论它们是运行中的还是已经停止的。</p></li></ol></blockquote><h1>使用redis</h1><p>创建网络</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network create redis-net-1012</span><br></pre></td></tr></table></figure></div><p>启动server</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --name my-redis-1012 --network redis-net-1012 -p 6379:6379 -d redis:latest</span><br></pre></td></tr></table></figure></div><p>客户端访问</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --network redis-net-1012 --<span class="built_in">rm</span> redis redis-cli -h my-redis-1012</span><br></pre></td></tr></table></figure></div><p>启动成功</p><img lazyload src="/images/loading.svg" data-src="/posts/%E5%B7%A5%E5%85%B7%E5%AD%A6%E4%B9%A0/docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/image-20231012144424264.png" class title="image-20231012144424264"><p>测试</p><img lazyload src="/images/loading.svg" data-src="/posts/%E5%B7%A5%E5%85%B7%E5%AD%A6%E4%B9%A0/docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/image-20231012144958421.png" class title="image-20231012144958421"><h1>mysql</h1><p>为了区分，映射了一个51001端口，注意容器端口还得是3306，不然好像连接不上</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker pull mysql</span><br><span class="line"></span><br><span class="line">docker network create mysql-net-1026</span><br><span class="line"></span><br><span class="line">docker run --name my-mysql-1026 --network mysql-net-1026 -e MYSQL_ROOT_PASSWORD=root1234 -d -p 51001:3306 mysql:latest</span><br><span class="line"></span><br><span class="line">docker run -it --network mysql-net-1026 --<span class="built_in">rm</span> mysql:latest mysql -h my-mysql-1026 -u root -p</span><br></pre></td></tr></table></figure></div><ul><li><p><code>docker run</code>: 启动一个 Docker 容器。</p></li><li><p><code>-it</code>: 这是两个参数的组合，<code>-i</code> 表示交互式模式，允许您与容器交互，<code>-t</code> 分配一个终端。</p></li><li><p><code>--network mysql-net-1026</code>: 指定容器连接的网络。在这里，容器将连接到名为 <code>mysql-net-1026</code> 的 Docker 网络，这使得容器可以与该网络中的其他容器进行通信。</p></li><li><p><code>--rm</code>: 表示容器退出时自动删除容器。这有助于确保在容器退出后不会留下残留的容器。</p></li><li><p><code>mysql:latest</code>: 指定要运行的 Docker 镜像。在这里，使用了 MySQL 的最新版本。</p></li><li><p><code>mysql -h my-mysql-1026 -u root -p</code>:</p><p>这是在容器内运行的命令。它执行了以下操作：</p><ul><li><code>mysql</code>: 启动 MySQL 客户端。</li><li><code>-h my-mysql-1026</code>: 指定要连接的 MySQL 服务器的主机名。在这里，<code>my-mysql-1026</code> 是您 MySQL 容器的主机名，它连接到该容器的 MySQL 服务器。</li><li><code>-u root</code>: 指定 MySQL 用户名，这里是 root。</li><li><code>-p</code>: 要求输入密码，这样您可以输入 MySQL 的密码以连接到 MySQL 服务器。</li></ul></li></ul><h1>进入容器</h1><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it &lt;container_name_or_id&gt; bash</span><br></pre></td></tr></table></figure></div>]]></content>
      
      
      <categories>
          
          <category> 工具学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>凤凰项目人物关系</title>
      <link href="/posts/23-Fall-Courses-DevOps/%E5%87%A4%E5%87%B0%E9%A1%B9%E7%9B%AE%E4%BA%BA%E7%89%A9%E5%85%B3%E7%B3%BB.html"/>
      <url>/posts/23-Fall-Courses-DevOps/%E5%87%A4%E5%87%B0%E9%A1%B9%E7%9B%AE%E4%BA%BA%E7%89%A9%E5%85%B3%E7%B3%BB.html</url>
      
        <content type="html"><![CDATA[<p>看的时候老是忘记，所以找个地方放一下</p><p><img lazyload src="/images/loading.svg" data-src="FengHuangProject/image-20230911084052789.png" alt="image-20230911084052789"></p>]]></content>
      
      
      <categories>
          
          <category> 23-Fall-Courses-DevOps </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Books </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kotlin-learn</title>
      <link href="/posts/2023-Summer-Courses-%E7%99%BE%E5%BA%A6%E7%A7%BB%E5%8A%A8%E7%AB%AF/kotlin-learn.html"/>
      <url>/posts/2023-Summer-Courses-%E7%99%BE%E5%BA%A6%E7%A7%BB%E5%8A%A8%E7%AB%AF/kotlin-learn.html</url>
      
        <content type="html"><![CDATA[<p>菜鸟教程：<a class="link" href="https://www.runoob.com/kotlin/kotlin-tutorial.html">Kotlin 教程 | 菜鸟教程 (runoob.com) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p><p>官方文档：<a class="link" href="https://book.kotlincn.net/text/getting-started.html">入门 · Kotlin 官方文档 中文版 (kotlincn.net) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p><p>在线运行：<a class="link" href="https://play.kotlinlang.org/#eyJ2ZXJzaW9uIjoiMS45LjAiLCJwbGF0Zm9ybSI6ImphdmEiLCJhcmdzIjoiIiwibm9uZU1hcmtlcnMiOnRydWUsInRoZW1lIjoiaWRlYSIsImNvZGUiOiIvKipcbiAqIFlvdSBjYW4gZWRpdCwgcnVuLCBhbmQgc2hhcmUgdGhpcyBjb2RlLlxuICogcGxheS5rb3RsaW5sYW5nLm9yZ1xuICovXG5mdW4gbWFpbigpIHtcbiAgICBwcmludGxuKFwiSGVsbG8sIHdvcmxkISEhXCIpXG59In0=">Kotlin Playground: Edit, Run, Share Kotlin Code Online (kotlinlang.org) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> / <a class="link" href="https://try.kotlinlang.org">https://try.kotlinlang.org <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p><h1>简介</h1><p>Kotlin 是一种在 Java 虚拟机上运行的静态类型编程语言，被称之为 Android 世界的Swift，由 JetBrains 设计开发并开源。</p><p>Kotlin 可以编译成Java字节码，也可以编译成 JavaScript，方便在没有 JVM 的设备上运行。</p><p>在Google I/O 2017中，Google 宣布 Kotlin 成为 Android 官方开发语言。</p><h1>变量</h1><p>如果你学过Java并且足够细心的话，你可能发现了Kotlin中Int的首字母是大写的，而Java中int的首字母是小写的。不要小看这一个字母大小写的差距，这表示Kotlin<strong>完全抛弃了Java中的基本数据类型，全部使用了对象数据类型</strong>。在Java中int是关键字，而在Kotlin中Int变成了一个类，它拥有自己的方法和继承结构。</p><h2 id="为什么要设计val和var">为什么要设计val和var</h2><img lazyload src="/images/loading.svg" data-src="/posts/2023-Summer-Courses-%E7%99%BE%E5%BA%A6%E7%A7%BB%E5%8A%A8%E7%AB%AF/kotlin-learn/image-20230724181158627.png" class title="image-20230724181158627"><h1>函数</h1><p>一个语法糖：当一个函数中只有一行代码时，Kotlin允许我们不必编写函数体，可以直接将唯一的一行代码写在函数定义的尾部，中间用等号连接即可。</p><p>让kotlin自己作类型推导，所以返回类型都不用写</p><div class="highlight-container" data-rel="Kotlin"><figure class="iseeu highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> nju.dsy.helloworld</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> kotlin.math.max</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">largerNumber</span><span class="params">(num1:<span class="type">Int</span>, num2:<span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> max(num1, num2)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">largerNumber2</span><span class="params">(num1: <span class="type">Int</span>, num2: <span class="type">Int</span>)</span></span> = max(num1, num2)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> a: <span class="built_in">Int</span> = largerNumber2(<span class="number">2</span>, <span class="number">40</span>)</span><br><span class="line">    a = a * <span class="number">10</span></span><br><span class="line">    println(<span class="string">&quot;a = &quot;</span> + a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h1>if条件语句</h1><p>可以有返回值</p><p>Kotlin中的if语句相比于Java有一个额外的功能，它是可以有返回值的，返回值就是if语句每一个条件中最后一行代码的返回值。</p><div class="highlight-container" data-rel="Kotlin"><figure class="iseeu highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">largerNumber</span><span class="params">(num1: <span class="type">Int</span>, num2: <span class="type">Int</span>)</span></span> = <span class="keyword">if</span> (num1 &gt; num2) &#123;</span><br><span class="line">    num1</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    num2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h1>When条件语句</h1><p>值匹配</p><div class="highlight-container" data-rel="Kotlin"><figure class="iseeu highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getScore</span><span class="params">(name: <span class="type">String</span>)</span></span> = <span class="keyword">when</span> (name) &#123;</span><br><span class="line">    <span class="string">&quot;Tom&quot;</span> -&gt; <span class="number">86</span></span><br><span class="line">    <span class="string">&quot;Jim&quot;</span> -&gt; <span class="number">77</span></span><br><span class="line">    <span class="string">&quot;Jack&quot;</span> -&gt; <span class="number">95</span></span><br><span class="line">    <span class="string">&quot;Lily&quot;</span> -&gt; <span class="number">100</span></span><br><span class="line">    <span class="keyword">else</span> -&gt; <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getScore2</span><span class="params">(name: <span class="type">String</span>)</span></span> = <span class="keyword">when</span> &#123;</span><br><span class="line">    name.startsWith(<span class="string">&quot;Tom&quot;</span>) -&gt; <span class="number">86</span></span><br><span class="line">    name == <span class="string">&quot;Jim&quot;</span> -&gt; <span class="number">77</span></span><br><span class="line">    name == <span class="string">&quot;Jack&quot;</span> -&gt; <span class="number">95</span></span><br><span class="line">    name == <span class="string">&quot;Lily&quot;</span> -&gt; <span class="number">100</span></span><br><span class="line">    <span class="keyword">else</span> -&gt; <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>也支持类型匹配，使用is关键字</p><div class="highlight-container" data-rel="Kotlin"><figure class="iseeu highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">checkNumber</span><span class="params">(num: <span class="type">Number</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">when</span> (num) &#123;</span><br><span class="line">        <span class="keyword">is</span> <span class="built_in">Int</span> -&gt; println(<span class="string">&quot;number is Int&quot;</span>)</span><br><span class="line">        <span class="keyword">is</span> <span class="built_in">Double</span> -&gt; println(<span class="string">&quot;number is Double&quot;</span>)</span><br><span class="line">        <span class="keyword">else</span> -&gt; println(<span class="string">&quot;number not support&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h1>循环语句</h1><div class="highlight-container" data-rel="Kotlin"><figure class="iseeu highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> range1 = <span class="number">0.</span><span class="number">.9</span>       <span class="comment">// 闭区间</span></span><br><span class="line"><span class="keyword">val</span> range2 = <span class="number">0</span> until <span class="number">10</span> <span class="comment">// 左闭右开区间</span></span><br><span class="line"><span class="keyword">val</span> range3 = <span class="number">0</span> until <span class="number">10</span> step <span class="number">2</span> <span class="comment">// 左闭右开区间，步长为2</span></span><br><span class="line"><span class="keyword">val</span> range4 = <span class="number">9</span> downTo <span class="number">0</span> step <span class="number">2</span> <span class="comment">// 闭区间，倒序</span></span><br></pre></td></tr></table></figure></div><h1>面向对象编程</h1><p>对话框在默认情况下自动选中的是创建一个File，File通常是用于编写Kotlin顶层函数和扩展函数的</p><h2 id="继承">继承</h2><p>这就是Kotlin不同的地方，在Kotlin中任何一个非抽象类默认都是不可以被继承的，相当于Java中给类声明了final关键字。</p><p>之所以这么设计，其实和val关键字的原因是差不多的，因为类和变量一样，最好都是不可变的，而一个类允许被继承的话，它无法预知子类会如何实现，因此可能就会存在一些未知的风险。<em>Effective Java</em>这本书中明确提到，如果一个类不是专门为继承而设计的，那么就应该主动将它加上final声明，禁止它可以被继承。</p><h2 id="open关键字">open关键字</h2><p>主动告诉编译器这个类可以被继承（即使是非抽象类</p><h2 id="构造函数">构造函数</h2><p>任何一个面向对象的编程语言都会有构造函数的概念，Kotlin中也有，但是Kotlin将构造函数分成了两种：<strong>主构造函数</strong>和<strong>次构造函数</strong></p><p>你可能会问，主构造函数没有函数体，如果我想在主构造函数中编写一些逻辑，该怎么办呢？Kotlin给我们提供了一个init结构体，所有主构造函数中的逻辑都可以写在里面</p><p>父类的字段传参不用加var/val</p><img lazyload src="/images/loading.svg" data-src="/posts/2023-Summer-Courses-%E7%99%BE%E5%BA%A6%E7%A7%BB%E5%8A%A8%E7%AB%AF/kotlin-learn/image-20230725163527604.png" class title="image-20230725163527604"><blockquote><p>简单来说就是子类有主构造函数的话，也就是子类名后面有（）不管是否有参数，说明是有主构造函数的，那么就需要继承父类的构造函数</p><img lazyload src="/images/loading.svg" data-src="/posts/2023-Summer-Courses-%E7%99%BE%E5%BA%A6%E7%A7%BB%E5%8A%A8%E7%AB%AF/kotlin-learn/image-20230725202950881.png" class title="image-20230725202950881"><p>如果子类没有主构造函数而是有次构造函数，那么就不需要在初始化时调用父类的构造函数了</p></blockquote><div class="highlight-container" data-rel="Kotlin"><figure class="iseeu highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 很乱，就看懂这个得了</span></span><br><span class="line"><span class="comment">// Kotlin规定，当一个类既有主构造函数又有次构造函数时，所有的次构造函数都必须调用主构造函数（包括间接调用）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="keyword">val</span> sno: String, <span class="keyword">val</span> grade: <span class="built_in">Int</span>, name: String, age: <span class="built_in">Int</span>)</span><br><span class="line">:</span><br><span class="line"> Person(name, age) &#123;</span><br><span class="line"> <span class="keyword">constructor</span>(name: String, age: <span class="built_in">Int</span>) : <span class="keyword">this</span>(<span class="string">&quot;&quot;</span>, <span class="number">0</span>, name, age) &#123;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">constructor</span>() : <span class="keyword">this</span>(<span class="string">&quot;&quot;</span>, <span class="number">0</span>) &#123;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="接口">接口</h2><p>与java类似，单继承，多实现</p><h2 id="特性：默认实现">特性：默认实现</h2><img lazyload src="/images/loading.svg" data-src="/posts/2023-Summer-Courses-%E7%99%BE%E5%BA%A6%E7%A7%BB%E5%8A%A8%E7%AB%AF/kotlin-learn/image-20230725204122418.png" class title="image-20230725204122418"><h2 id="可见性修饰符">可见性修饰符</h2><img lazyload src="/images/loading.svg" data-src="/posts/2023-Summer-Courses-%E7%99%BE%E5%BA%A6%E7%A7%BB%E5%8A%A8%E7%AB%AF/kotlin-learn/image-20230725204706614.png" class title="image-20230725204706614"><h2 id="数据类：data关键字">数据类：data关键字</h2><p>自动重写hashCode()，toString()，equals()方法</p><blockquote><p>这三个方法在Java中是Object类的常用方法，它们在Java编程中非常重要，并且在很多场景下都是关键的。下面简要介绍它们的用途和重要性：</p><ol><li><code>hashCode()</code>方法：<ul><li>用途：<code>hashCode()</code>方法返回对象的哈希码值，它是一个32位整数，用于散列数据结构中，如哈希表。</li><li>重要性：在使用散列数据结构时，比如HashSet、HashMap等，哈希码值决定了对象在数据结构中的存储位置。确保正确实现<code>hashCode()</code>方法是保证散列数据结构正常运作的关键。在集合类中查找对象时，首先通过哈希码值定位可能存在的位置，然后再使用<code>equals()</code>方法比较对象是否真正相等。</li></ul></li><li><code>toString()</code>方法：<ul><li>用途：<code>toString()</code>方法返回对象的字符串表示形式，通常用于将对象转换为可读的字符串，方便调试和日志记录。</li><li>重要性：在调试和日志输出中，将对象转换为可读的字符串表示形式是很常见的需求。如果没有自定义<code>toString()</code>方法，通常会返回默认的类名和哈希码，这对于调试和日志记录来说是不够有用的。通过重写<code>toString()</code>方法，可以自定义对象的输出格式，使其更加有意义。</li></ul></li><li><code>equals()</code>方法：<ul><li>用途：<code>equals()</code>方法用于比较两个对象是否相等。在默认情况下，它比较的是对象的引用（即内存地址），但在很多情况下，我们希望比较对象的内容是否相等。</li><li>重要性：在集合类中查找对象时，通常需要通过<code>equals()</code>方法来确定对象是否与集合中的某个元素相等。如果不正确实现<code>equals()</code>方法，可能导致集合类无法正确识别对象的相等性，从而引发错误的结果。通常，重写<code>equals()</code>方法需要同时重写<code>hashCode()</code>方法，以保持对象相等时哈希码值一致的规则。</li></ul></li></ol><p>总结：这三个方法在Java中很关键，特别是在涉及集合类的使用时。确保正确实现<code>hashCode()</code>和<code>equals()</code>方法可以保证对象在散列数据结构中正确存储和查找，而重写<code>toString()</code>方法可以方便地查看对象的内容。同时，这些方法也是面向对象编程中的基本原则之一，可以帮助我们更好地设计和使用Java类。</p></blockquote><p>省流：hashCode()和equals()方法在集合类的使用中有较大的作用</p><h2 id="单例类-Object类">单例类:Object类</h2><p>kotlin隐藏了实现</p><img lazyload src="/images/loading.svg" data-src="/posts/2023-Summer-Courses-%E7%99%BE%E5%BA%A6%E7%A7%BB%E5%8A%A8%E7%AB%AF/kotlin-learn/image-20230725210813625.png" class title="image-20230725210813625"><h1>lambda编程</h1><h2 id="mutableListOf-函数">mutableListOf()函数</h2><div class="highlight-container" data-rel="Kotlin"><figure class="iseeu highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> list = mutableListOf(</span><br><span class="line">        <span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Banana&quot;</span>, <span class="string">&quot;Orange&quot;</span>, <span class="string">&quot;Pear&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Grape&quot;</span></span><br><span class="line">    )</span><br><span class="line">    list.add(<span class="string">&quot;Watermelon&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> (fruit <span class="keyword">in</span> list) &#123;</span><br><span class="line">        println(fruit)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="mutableSetOf-函数">mutableSetOf()函数</h2><h2 id="mutableMapOf-函数">mutableMapOf()函数</h2><img lazyload src="/images/loading.svg" data-src="/posts/2023-Summer-Courses-%E7%99%BE%E5%BA%A6%E7%A7%BB%E5%8A%A8%E7%AB%AF/kotlin-learn/image-20230725213016399.png" class title="image-20230725213016399"><h2 id="lambda表达式的语法结构">lambda表达式的语法结构</h2><img lazyload src="/images/loading.svg" data-src="/posts/2023-Summer-Courses-%E7%99%BE%E5%BA%A6%E7%A7%BB%E5%8A%A8%E7%AB%AF/kotlin-learn/image-20230725213743675.png" class title="image-20230725213743675"><h3 id="最原始">最原始</h3><div class="highlight-container" data-rel="Kotlin"><figure class="iseeu highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list = listOf(<span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Banana&quot;</span>, <span class="string">&quot;Orange&quot;</span>, <span class="string">&quot;Pear&quot;</span>, <span class="string">&quot;Grape&quot;</span>, <span class="string">&quot;Watermelon&quot;</span>)</span><br><span class="line"><span class="keyword">val</span> lambda = &#123; fruit: String -&gt; fruit.length &#125;</span><br><span class="line"><span class="keyword">val</span> maxLengthFruit = list.maxBy(lambda)</span><br><span class="line"><span class="comment">// -&gt; 后面是函数体，最后一行是lambda表达式的返回值，也就是说上例返回fruit.length</span></span><br><span class="line"><span class="comment">// 传入lambda表达式的参数是fruit:String</span></span><br></pre></td></tr></table></figure></div><p>可以看到，maxBy函数实质上就是接收了一个Lambda参数而已，并且这个Lambda参数是完全按照刚才学习的表达式的语法结构来定义的，因此这段代码应该算是比较好懂的。</p><blockquote><img lazyload src="/images/loading.svg" data-src="/posts/2023-Summer-Courses-%E7%99%BE%E5%BA%A6%E7%A7%BB%E5%8A%A8%E7%AB%AF/kotlin-learn/image-20230725214614356.png" class title="image-20230725214614356"></blockquote><h3 id="第一步简化">第一步简化</h3><img lazyload src="/images/loading.svg" data-src="/posts/2023-Summer-Courses-%E7%99%BE%E5%BA%A6%E7%A7%BB%E5%8A%A8%E7%AB%AF/kotlin-learn/image-20230725214217161.png" class title="image-20230725214217161"><h3 id="继续简化">继续简化</h3><img lazyload src="/images/loading.svg" data-src="/posts/2023-Summer-Courses-%E7%99%BE%E5%BA%A6%E7%A7%BB%E5%8A%A8%E7%AB%AF/kotlin-learn/image-20230725214716479.png" class title="image-20230725214716479"><h3 id="最终">最终</h3><img lazyload src="/images/loading.svg" data-src="/posts/2023-Summer-Courses-%E7%99%BE%E5%BA%A6%E7%A7%BB%E5%8A%A8%E7%AB%AF/kotlin-learn/image-20230725214653043.png" class title="image-20230725214653043"><blockquote><p>在这里，<code>it</code>关键字代表集合中的每个元素（在这种情况下，代表集合中的每个字符串），并且由于<code>length</code>是字符串的属性，编译器可以推断出<code>it</code>是String类型，因此无需显式指定参数类型。</p></blockquote><h3 id="集合的map函数">集合的map函数</h3><img lazyload src="/images/loading.svg" data-src="/posts/2023-Summer-Courses-%E7%99%BE%E5%BA%A6%E7%A7%BB%E5%8A%A8%E7%AB%AF/kotlin-learn/image-20230725214859050.png" class title="image-20230725214859050"><h3 id="filter函数">filter函数</h3><img lazyload src="/images/loading.svg" data-src="/posts/2023-Summer-Courses-%E7%99%BE%E5%BA%A6%E7%A7%BB%E5%8A%A8%E7%AB%AF/kotlin-learn/image-20230725214938865.png" class title="image-20230725214938865"><h3 id="any存在-all所有">any存在 all所有</h3><p>返回true, false</p><img lazyload src="/images/loading.svg" data-src="/posts/2023-Summer-Courses-%E7%99%BE%E5%BA%A6%E7%A7%BB%E5%8A%A8%E7%AB%AF/kotlin-learn/image-20230725215134406.png" class title="image-20230725215134406"><h3 id="Java函数式API的使用">Java函数式API的使用</h3><p>Thread类的构造方法中接收了一个Runnable参数，我们可以使用如下Java代码创建并执行一个子线程：</p><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"> System.out.println(<span class="string">&quot;Thread is running&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure></div><p>注意，这里使用了<strong>匿名类</strong>的写法，我们创建了一个Runnable接口的匿名类实例，并将它传给了Thread类的构造方法，最后调用Thread类的start()方法执行这个线程。</p><p>而如果直接将这段代码翻译成Kotlin版本，写法将如下所示：</p><div class="highlight-container" data-rel="Kotlin"><figure class="iseeu highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Thread(<span class="keyword">object</span> : Runnable &#123;</span><br><span class="line"> <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">run</span><span class="params">()</span></span> &#123;</span><br><span class="line"> println(<span class="string">&quot;Thread is running&quot;</span>)</span><br><span class="line"> &#125;</span><br><span class="line">&#125;).start()</span><br></pre></td></tr></table></figure></div><p>Kotlin中匿名类的写法和Java有一点区别，由于Kotlin完全舍弃了new关键字，因此创建匿名类实例的时候就不能再使用new了，而是改用了<strong>object</strong>关键字。这种写法虽然算不上复杂，但是相比于Java的匿名类写法，并没有什么简化之处。</p><p>但是别忘了，目前Thread类的构造方法是符合<strong>Java函数式API</strong>的使用条件的，下面我们就看看如何对代码进行精简，如下所示：</p><div class="highlight-container" data-rel="Kotlin"><figure class="iseeu highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Thread(Runnable &#123;</span><br><span class="line"> println(<span class="string">&quot;Thread is running&quot;</span>)</span><br><span class="line">&#125;).start()</span><br></pre></td></tr></table></figure></div><p>这段代码明显简化了很多，既可以实现同样的功能，又不会造成任何歧义。因为Runnable类中只有一个待实现方法，即使这里没有显式地重写run()方法，Kotlin也能自动明白Runnable后面的Lambda表达式就是要在run()方法中实现的内容。</p><p>另外，如果一个Java方法的参数列表中有且仅有一个Java单抽象方法接口参数，我们还可以将接口名进行省略，这样代码就变得更加精简了：</p><div class="highlight-container" data-rel="Kotlin"><figure class="iseeu highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Thread(&#123;</span><br><span class="line"> println(<span class="string">&quot;Thread is running&quot;</span>)</span><br><span class="line">&#125;).start()</span><br></pre></td></tr></table></figure></div><p>不过到这里还没有结束，和之前Kotlin中函数式API的用法类似，当Lambda表达式是方法的最后一个参数时，可以将Lambda表达式移到方法括号的外面。同时，如果Lambda表达式还是方法的唯一一个参数，还可以将方法的括号省略，最终简化结果如下：</p><div class="highlight-container" data-rel="Kotlin"><figure class="iseeu highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Thread &#123;</span><br><span class="line"> println(<span class="string">&quot;Thread is running&quot;</span>)</span><br><span class="line">&#125;.start()</span><br></pre></td></tr></table></figure></div><blockquote><p>总结就是只要没有歧义，随便怎么简化</p></blockquote><blockquote><p>挖坑：高阶函数</p><img lazyload src="/images/loading.svg" data-src="/posts/2023-Summer-Courses-%E7%99%BE%E5%BA%A6%E7%A7%BB%E5%8A%A8%E7%AB%AF/kotlin-learn/image-20230725220214837.png" class title="image-20230725220214837"></blockquote><h1>空指针检查</h1><h2 id="空指针异常检查提前">空指针异常检查提前</h2><img lazyload src="/images/loading.svg" data-src="/posts/2023-Summer-Courses-%E7%99%BE%E5%BA%A6%E7%A7%BB%E5%8A%A8%E7%AB%AF/kotlin-learn/image-20230725220523675.png" class title="image-20230725220523675"><h2 id="可为空的类型系统">可为空的类型系统</h2><p><code>?</code>操作符</p><img lazyload src="/images/loading.svg" data-src="/posts/2023-Summer-Courses-%E7%99%BE%E5%BA%A6%E7%A7%BB%E5%8A%A8%E7%AB%AF/kotlin-learn/image-20230725220710813.png" class title="image-20230725220710813"><p><code>?.</code>操作符</p><img lazyload src="/images/loading.svg" data-src="/posts/2023-Summer-Courses-%E7%99%BE%E5%BA%A6%E7%A7%BB%E5%8A%A8%E7%AB%AF/kotlin-learn/image-20230725220654674.png" class title="image-20230725220654674"><p><code>?:</code>左边空就返回右边</p><img lazyload src="/images/loading.svg" data-src="/posts/2023-Summer-Courses-%E7%99%BE%E5%BA%A6%E7%A7%BB%E5%8A%A8%E7%AB%AF/kotlin-learn/image-20230725220818466.png" class title="image-20230725220818466"><h2 id="let函数">let函数</h2><img lazyload src="/images/loading.svg" data-src="/posts/2023-Summer-Courses-%E7%99%BE%E5%BA%A6%E7%A7%BB%E5%8A%A8%E7%AB%AF/kotlin-learn/image-20230725221229409.png" class title="image-20230725221229409"><img lazyload src="/images/loading.svg" data-src="/posts/2023-Summer-Courses-%E7%99%BE%E5%BA%A6%E7%A7%BB%E5%8A%A8%E7%AB%AF/kotlin-learn/image-20230725221238609.png" class title="image-20230725221238609"><img lazyload src="/images/loading.svg" data-src="/posts/2023-Summer-Courses-%E7%99%BE%E5%BA%A6%E7%A7%BB%E5%8A%A8%E7%AB%AF/kotlin-learn/image-20230725221246138.png" class title="image-20230725221246138">]]></content>
      
      
      <categories>
          
          <category> 2023-Summer-Courses-百度移动端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 移动端开发 </tag>
            
            <tag> Kotlin学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2023BaiduAndroidlec5-lec6</title>
      <link href="/posts/2023-Summer-Courses-%E7%99%BE%E5%BA%A6%E7%A7%BB%E5%8A%A8%E7%AB%AF/2023baiduandroidlec5-lec6.html"/>
      <url>/posts/2023-Summer-Courses-%E7%99%BE%E5%BA%A6%E7%A7%BB%E5%8A%A8%E7%AB%AF/2023baiduandroidlec5-lec6.html</url>
      
        <content type="html"><![CDATA[<h1>lec5-Android四大组件</h1><p>大作业要求：</p><img lazyload src="/images/loading.svg" data-src="/posts/2023-Summer-Courses-%E7%99%BE%E5%BA%A6%E7%A7%BB%E5%8A%A8%E7%AB%AF/2023baiduandroidlec5-lec6/image-20230724102437748.png" class title="image-20230724102437748"><img lazyload src="/images/loading.svg" data-src="/posts/2023-Summer-Courses-%E7%99%BE%E5%BA%A6%E7%A7%BB%E5%8A%A8%E7%AB%AF/2023baiduandroidlec5-lec6/image-20230724102439177.png" class title="image-20230724102439177"><h2 id="Activity">Activity</h2><p>用户与应用程序交互的界面，<strong>每一个Activity都会代表一个屏幕</strong>，负责展示屏幕并处理用户的操作。每个Activity都是独立的，<strong>它们之间可以进行跳转、数据传递等互动</strong></p><ul><li><p>实现xml布局</p></li><li><p>实现Activity类文件</p><div class="highlight-container" data-rel="Kotlin"><figure class="iseeu highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MainActivity</span>: <span class="type">Activity</span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_main) <span class="comment">// 给Activity设置布局</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li><li><p>给Activity设置布局</p></li><li><p>在manifest中声明Activity</p><div class="highlight-container" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">activity</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:name</span>=<span class="string">&quot;.MainActivity&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:exported</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.action.MAIN&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.category.LAUNCHER&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">application</span>&gt;</span></span><br></pre></td></tr></table></figure></div><p><strong>Intent-filter</strong> 中的配置代表这个Activity是<strong>应用程序入口</strong>，点击桌面图标可进入</p><p>exported 属性代表Activity是否应用外开放</p></li></ul><h3 id="Activity的生命周期">Activity的生命周期</h3><ul><li><p>onCreate()</p><p>必须实现，首次创建Activity触发</p></li><li><p>onStart()</p><p>当 Activity 进入&quot;已开始&quot;状态时，系统会调用此回调</p></li><li><p>onStop()</p><p><strong>Activity 不再对用户可见，说明其已进入&quot;已停止&quot;状态</strong></p></li><li><p>onRestart()</p><p>当用户回到Activity(非首次)</p></li><li><p>onResume()</p><p>当Activity 可见并进入可交互状态</p></li><li><p>onPause() ：比如应用程序切换到后台就是pause+stop</p><p><strong>当Activity 可见并进入不可交互状态</strong></p></li><li><p>onDestory()</p><p>当Activity 销毁之前回调</p></li></ul><h3 id="Activity-显示调用">Activity 显示调用</h3><p>从一个Activity 启动另一个 Activity</p><p>startActivity 无返回值</p><div class="highlight-container" data-rel="Kotlin"><figure class="iseeu highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> intent = Intent(<span class="keyword">this</span>, SecondActivity::<span class="keyword">class</span>.java)</span><br><span class="line">startActivity(intent)</span><br></pre></td></tr></table></figure></div><p>startActivityForResult 有返回值回调</p><div class="highlight-container" data-rel="Kotlin"><figure class="iseeu highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">startActivityForResult(Intent(<span class="keyword">this</span>, SecondActivity::<span class="keyword">class</span>.java), <span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onActivityResult</span><span class="params">(requestCode: <span class="type">Int</span>, resultCode: <span class="type">Int</span>, intent: <span class="type">Intent</span>?)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">1000</span> == requestCode) &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><blockquote><p>RequestCode的含义</p><p>第三个参数 <code>1000</code> 是请求代码（Request Code），用于标识此次启动 Activity 的请求。它是一个整数值，用于标记这个请求，以便在返回结果时可以识别是从哪个请求返回的结果。</p></blockquote><h3 id="Activity-隐式调用">Activity 隐式调用</h3><p>隐式调用是指应用程序中<strong>不需要明确指定</strong>Activity 名称的调用方式，需要<strong>使用Intent对象来指定</strong>要启动的Activity 的类型和动作。Intent 对象包含了要启动的Activity的category 和action 信息，当调用startActivity() 方法时， Android 系统会<strong>根据Intent 对象</strong>中的信息来<strong>查找匹配的Activity，并启动该Activity</strong>。隐式调用可能存在一些安全问题，<strong>需要增加校验，防止Activity 劫持</strong></p><img lazyload src="/images/loading.svg" data-src="/posts/2023-Summer-Courses-%E7%99%BE%E5%BA%A6%E7%A7%BB%E5%8A%A8%E7%AB%AF/2023baiduandroidlec5-lec6/image-20230728143219363.png" class title="image-20230728143219363"><h3 id="Activity-跳转时生命周期">Activity 跳转时生命周期</h3><h4 id="ActivityA-跳转-ActivityB，-A与B均不透明，生命周期变化">ActivityA 跳转 ActivityB， A与B均不透明，生命周期变化</h4><p>A:onPause</p><p>B:onCreate -&gt; onStart -&gt; onResume</p><p>A:onStop</p><h4 id="ActivityB-回到-ActivityA，生命周期变化">ActivityB 回到 ActivityA，生命周期变化</h4><p>B:onPause</p><p>A:onRestart -&gt; onStart -&gt; onResume</p><p>B:onStop -&gt; onDestory</p><h3 id="演示">演示</h3><img lazyload src="/images/loading.svg" data-src="/posts/2023-Summer-Courses-%E7%99%BE%E5%BA%A6%E7%A7%BB%E5%8A%A8%E7%AB%AF/2023baiduandroidlec5-lec6/image-20230728144156311.png" class title="image-20230728144156311"><p>启动第一个activity</p><p>依次是Create Start Resume</p><h3 id="Activity的任务栈">Activity的任务栈</h3><p>遵守先进后出罢了</p><h3 id="Activity-的四种启动模式">Activity 的四种启动模式</h3><ul><li><p><mark>Standard(标准模式)</mark></p><p>标准模式是默认的启动模式。<br><strong>每次启动Activity时都会创建一个新的实例 ，并放置在任务栈的顶部。</strong></p></li><li><p><mark>SingleTop(单顶模式)</mark></p><p>当Activity<strong>位于任务栈的顶部时</strong>，再次启动该Activity时<strong>不会创建新的实例</strong>，而是会<strong>调用已存在实例的onNewIntent()方法</strong>。如果<strong>不在顶部</strong>，则会<strong>创建新的实例</strong>。</p></li><li><p><mark>SingleTask(单任务模式)</mark></p><p>单任务模式下，<strong>每个任务栈只能包含一个该Activity的实例</strong>。如果要启动的Activity<strong>已经存在于任务栈中</strong>，则会<strong>将该任务栈调到前台</strong>，触发该Activity的onNewlntent()方法，并将<strong>该Activity之上的Activity全部出栈</strong>。如果要启动的Activity<strong>不存在于任何任务栈中</strong>，则会<strong>创建新的任务栈并将该Activity放入其中</strong>。</p></li><li><p><mark>SingleInstance(单实例模式)</mark></p><p>单实例模式是最为独特的一种启动模式。在单实例模式下，该Activity会<strong>独占一个任务栈</strong>，并且该任务栈中<strong>只能有一个实例</strong>。无论从哪个应用程序中启动该Activity，都会<strong>共享同一个实例</strong>。如果要启动的Activity不存在于任何任务栈中，则会创建新的任务栈并将该Activity放入其中。</p></li></ul><p>这些启动模式可以通过在<strong>AndroidManifest.xml</strong>文件中为Activityi<strong>设置android:launchMode属性</strong>来指定。</p><p><strong>单实例使用场景例子</strong> 调用微信支付—&gt;回退返回到自己的程序</p><h2 id="Fragment（注意并非四大组件之一">Fragment（注意并非四大组件之一</h2><p>Fragment，在Activity 中负责用户界面部分，<strong>可以将多个Fragment 组合在一个Activity 中来创建多窗口UI，或者在Activity 中重复使用某个Fragment。</strong></p><ul><li>Fragment 是依赖于Activity的，<strong>不能独立存在</strong>的。</li><li>一个Activity 里可以有<strong>多个</strong>Fragment。</li><li>一个Fragment 可以被多个Activity <strong>重用</strong>。</li><li>Fragment 有自己的<strong>生命周期</strong>，并能接收输入事件。</li><li>我们能在Activity 运行时<strong>动态地添加或删除</strong>Fragment。</li></ul><h3 id="Fragment-的生命周期">Fragment 的生命周期</h3><ul><li>onAttach():当Fragment 与Activity 关联时调用。在这个阶段可以获取到与Fragment 关联的Activity 实例。</li><li>onCreateView():创建Fragment 的视图。在这个阶段，可以定义Fragment 的布局，并返回布局的根视图。</li><li>onActivityCreated():当与Fragment 关联的Activity 的onCreate()方法返回时调用。</li><li>onDestroyView():销毁Fragment 的视图。在这个阶段，应该清理与视图相关的资源。</li><li>onDetach(): 当Fragment 与Activity 解除关联时调用。</li></ul><h3 id="Fragment-的实现">Fragment 的实现</h3><ol><li><p>创建一个新的类，这个类需要继承自Fragment 类</p><div class="highlight-container" data-rel="Kotlin"><figure class="iseeu highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyFragment</span>: <span class="type">Fragment</span>() &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li><li><p>重写onCreateView方法。这个方法是Fragment 创建它的用户界面时调用的。在这个方法中，返回一个包含Fragment 布局的View。</p><div class="highlight-container" data-rel="Kotlin"><figure class="iseeu highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> View <span class="title">onCreateView</span><span class="params">(inflater: <span class="type">LayoutInflater</span>?, container: <span class="type">ViewGroup</span>?, savedInstanceState: <span class="type">Bundle</span>?)</span></span>:View? &#123;</span><br><span class="line">    <span class="keyword">return</span> inflater.inflate(R.layout.fragment_my, container, <span class="literal">false</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li></ol><h3 id="Activity-添加Fragment">Activity 添加Fragment</h3><p>Fragment可以通过两种方式被添加到Activity 中</p><p><strong>静态添加</strong>：在Activity 的布局中使用&lt;fragment&gt; 标签来声明Fragment。</p><p><strong>动态添加</strong>：在<strong>运行时</strong>通过FragmentManager 和FragmentTransaction 来<strong>添加、替换或者移除Fragment</strong></p><div class="highlight-container" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:orientation</span>=<span class="string">&quot;vertical&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 静态添加fragment --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">fragment</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:name</span>=<span class="string">&quot;com.baidu.androidlearn.lesson5.MyFragment&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/myfragment&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 动态添加fragment --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">FrameLayout</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/fragment_container&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure></div><div class="highlight-container" data-rel="Kotlin"><figure class="iseeu highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> myFragment: Fragment = MyFragment()</span><br><span class="line"><span class="keyword">val</span> fragmentManager: FragmentManager = supportFragmentManager</span><br><span class="line"><span class="keyword">val</span> fragmentTransaction: FragmentTransaction = fragmentManager.beginTransaction()</span><br><span class="line">fragmentTransaction.add(R.id.fragment_container, myFragment)</span><br><span class="line">fragmentTransaction.commit()</span><br></pre></td></tr></table></figure></div><p>R.id.fragment_container 是要添加Fragment的布局的id</p><h3 id="FragmentTransaction">FragmentTransaction</h3><ul><li>add()：添加Fragment 到 Activity 界面中</li><li>remove()：移除 Activity 中的指定 Fragment</li><li>replace()系列：通过内部调用 remove() 和add() 完成 Fragment 的修改</li><li>hide() 和show()：隐藏和显示 Activity 中的 Fragment</li><li>commit()：提交事务，对 Fragment 的<strong>改动都必须通过调用 commit() 方法完成提交</strong></li><li>commitAllowingStateLoss()：和commit()类似，但是<strong>允许在Activity状态保存后执行commit</strong></li><li>addToBackStack()：该方法用于将<strong>当前的事务添加到回退栈中</strong> ，当用户<strong>点击后退键</strong>时，将会<strong>导航到上一个Fragment状态。</strong></li></ul><h3 id="Activity-与-Fragment-通讯：使用Bundle">Activity 与 Fragment 通讯：使用Bundle</h3><ol><li><p>在Activity 中创建Bundle 并设置到Fragment 中</p><div class="highlight-container" data-rel="Kotlin"><figure class="iseeu highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> bundle = Bundle()</span><br><span class="line">bundle.putString(<span class="string">&quot;key&quot;</span>, <span class="string">&quot;value&quot;</span>)</span><br><span class="line"><span class="keyword">val</span> fragment = MyFragment()</span><br><span class="line">fragment.setArguments(bundle)</span><br></pre></td></tr></table></figure></div></li><li><p>在Fragment 中获取参数</p><div class="highlight-container" data-rel="Kotlin"><figure class="iseeu highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(getArguments() != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">val</span> value = getArguments().getString(<span class="string">&quot;key&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li></ol><h3 id="Fragment-与Activity-通讯">Fragment 与Activity 通讯</h3><ol><li><p>定义接口</p><div class="highlight-container" data-rel="Kotlin"><figure class="iseeu highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">FragmentListener</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li><li><p>Activity实现接口</p><div class="highlight-container" data-rel="Kotlin"><figure class="iseeu highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyFragmentActivity</span>: <span class="type">FragmentActivity</span>(), FragmentListener &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li><li><p>Fragment调用接口</p><div class="highlight-container" data-rel="Kotlin"><figure class="iseeu highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (activity <span class="keyword">is</span> FragmentListener) &#123;</span><br><span class="line">    (activity <span class="keyword">as</span> FragmentListener).test()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li></ol><blockquote><p>比如同一个activity下有多个fragment，那么两个fragment之间想要通信就可以通过都与activity通信来实现</p></blockquote><h2 id="BroadCast">BroadCast</h2><p>没怎么仔细听</p><h3 id="广播介绍">广播介绍</h3><p>广播是一种跨应用程序的消息传递机制，允许应用程序<strong>发送和接收系统级或应用级的事件</strong>。广播的目的是为了<strong>实现不同组件之间的解耦和通信</strong>。</p><blockquote><p>符合设计模式中的 观察者模式，</p><p>也符合 发布订阅模式？</p></blockquote><h4 id="标准广播">标准广播</h4><p>一种<strong>异步进行</strong>的广播，当广播发出后，所有的接收器几乎<strong>同时接收到这个消息</strong>，这种广播的执行<strong>效率比较高，但是无法被截断</strong>。标准广播主要用于对<strong>性能要求较高</strong>的场景。</p><h4 id="有序广播">有序广播</h4><p>是一种<strong>同步进行</strong>的广播，当广播发出后，系统会<strong>按照优先级顺序逐个传递给接收器</strong>。接收器在处理完广播后可以决定是否继续传递给下一个接收器，这样就<strong>实现了对广播的截断</strong>。有序广播主要用于<strong>对数据安全性和顺序要求较高的场景。</strong></p><h3 id="广播的类型（根据来源和作用范围划分">广播的类型（根据来源和作用范围划分</h3><ol><li><mark>系统广播 ( System Broadcast )</mark><br>系统广播是由<strong>Android系统发出的广播</strong>，用于<strong>通知应用程序系统状态的变化</strong>，例如电池电量变化、网络状态变化、屏幕关闭等。应用程序可以通过<strong>注册广播接收器</strong>( BroadcastReceiver）来<strong>监听和处理这些系统广播</strong>。</li><li><mark>自定义广播( Custom Broadcast )</mark><br>自定义广播是由<strong>应用程序自己发出的广播</strong>，用于<strong>向其他应用程序或应用程序内的不同组件传递消息</strong>。自定义广播可以是标准广播也可以是有序广播，开发者可以根据实际需求选择合适的广播类型。</li><li><mark>本地广播( Local Broadcast )</mark><br>本地广播是一种<strong>仅限于应用程序内部使用的广播</strong>，它使用Android Support Library中的LocalBroadcastManager 进行管理。本地广播相比于全局广播更加安全，因为它<strong>不会泄露应用程序内部的信息给其他应用程序</strong>。</li></ol><p>应用内部尽量使用本地广播，更安全</p><h3 id="常见系统广播">常见系统广播</h3><img lazyload src="/images/loading.svg" data-src="/posts/2023-Summer-Courses-%E7%99%BE%E5%BA%A6%E7%A7%BB%E5%8A%A8%E7%AB%AF/2023baiduandroidlec5-lec6/image-20230728182503037.png" class title="image-20230728182503037"><h3 id="自定义广播：自定义receiver继承BroadcastReceiver">自定义广播：自定义receiver继承BroadcastReceiver()</h3><p>直接看demo6的NetStateChangeReceiver</p><div class="highlight-container" data-rel="Kotlin"><figure class="iseeu highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NetStateChangeReceiver</span> : <span class="type">BroadcastReceiver</span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onReceive</span><span class="params">(context: <span class="type">Context</span>?, intent: <span class="type">Intent</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> ((ConnectivityManager.CONNECTIVITY_ACTION == intent?.action)) &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">registerReceiver</span><span class="params">(context: <span class="type">Context</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> intentFilter: IntentFilter = IntentFilter(ConnectivityManager.CONNECTIVITY_ACTION)</span><br><span class="line">        context?.registerReceiver(<span class="keyword">this</span>, intentFilter)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">unRegisterReceiver</span><span class="params">(context: <span class="type">Context</span>?)</span></span> &#123;</span><br><span class="line">        context?.unregisterReceiver(<span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="静态广播和动态广播">静态广播和动态广播</h3><img lazyload src="/images/loading.svg" data-src="/posts/2023-Summer-Courses-%E7%99%BE%E5%BA%A6%E7%A7%BB%E5%8A%A8%E7%AB%AF/2023baiduandroidlec5-lec6/image-20230728191005546.png" class title="image-20230728191005546"><h2 id="Service">Service</h2><p>Service是Android中的一个核心组件，<strong>它是一个在后台运行的组件，用于在不与用户交互的情况下执行一些长时间运行的操作</strong>。Service中的操作<strong>可以在用户不使用应用程序时运行</strong>，从而使我们可以在后台执行任务，如下载文件、播放音乐等。Service不具备用户界面，因此它不会对用户界面产生影响。</p><p>Service是在主线程运行的</p><p>适合service的场景：</p><ul><li>音乐播放器</li><li>后台定位服务</li><li>网络同步</li><li>长时间运行的后台任务</li><li>跨进程通信 (IPC）</li></ul><h3 id="Service的类型">Service的类型</h3><img lazyload src="/images/loading.svg" data-src="/posts/2023-Summer-Courses-%E7%99%BE%E5%BA%A6%E7%A7%BB%E5%8A%A8%E7%AB%AF/2023baiduandroidlec5-lec6/image-20230728192216588.png" class title="image-20230728192216588"><h3 id="Service-的生命周期：有两种">Service 的生命周期：有两种</h3><img lazyload src="/images/loading.svg" data-src="/posts/2023-Summer-Courses-%E7%99%BE%E5%BA%A6%E7%A7%BB%E5%8A%A8%E7%AB%AF/2023baiduandroidlec5-lec6/image-20230728192419571.png" class title="image-20230728192419571"><h4 id="启动服务">启动服务</h4><p>当使用startService() 方法启动服务时，服务会在后台无限期运行，直到它自行停止或被其他组件（如Activity）调用stopService() 方法停止</p><h4 id="绑定服务">绑定服务</h4><p>当使用bindService() 方法鄉定服务时，服务与调用它的应用组件（如Activity）建立了一个持续的连接。组件可以与服务进行双向通信</p><h3 id="创建service">创建service</h3><div class="highlight-container" data-rel="Kotlin"><figure class="iseeu highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyService</span> : <span class="type">Service</span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onStartCommand</span><span class="params">(intent: <span class="type">Intent</span>?, flags: <span class="type">Int</span>, startId: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="comment">// 在此处处理服务的任务，例如启动一个线程来执行长时间运行的操作</span></span><br><span class="line">        Log.i(TAG, <span class="string">&quot;onStartCommand&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.onStartCommand(intent, flags, startId)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onBind</span><span class="params">(intent: <span class="type">Intent</span>?)</span></span>: IBinder? &#123;</span><br><span class="line">        <span class="comment">// 如果不允许绑定服务，可以返回null</span></span><br><span class="line">        Log.i(TAG, <span class="string">&quot;onBind&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> myBinder</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onDestroy</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// 当服务被停止时，可以在这里执行一些清理工作</span></span><br><span class="line">        Log.i(TAG, <span class="string">&quot;onDestroy&quot;</span>)</span><br><span class="line">        <span class="keyword">super</span>.onDestroy()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>注意service也需要在manifest中注册</p><p>另外还需要再Manifest 中注册&lt;service android:name=“.MyService”&gt;</p><h3 id="启动service">启动service</h3><h4 id="启动服务-startService-：">启动服务(startService)：</h4><p>val intent = Intent(this, MyService::class.java)<br>startService(intent)</p><h4 id="停止服务-stopService）：">停止服务(stopService）：</h4><p>val intent = Intent(this, MyService::class.java)<br>stopService(intent)</p><h4 id="绑定服务-bindService-：">绑定服务 (bindService)：</h4><p>val intent = Intent(this, MyService::class.java)<br>bindService(intent, serviceConnection, Context. BIND_AUTO_CREATE)</p><h4 id="取消绑定服务-unbindService-：">取消绑定服务 (unbindService)：</h4><p>unbindService(serviceConnection)</p><h2 id="ContentProvider">ContentProvider</h2><h3 id="简介">简介</h3><img lazyload src="/images/loading.svg" data-src="/posts/2023-Summer-Courses-%E7%99%BE%E5%BA%A6%E7%A7%BB%E5%8A%A8%E7%AB%AF/2023baiduandroidlec5-lec6/image-20230728193702997.png" class title="image-20230728193702997"><h3 id="ContentProvider-URI">ContentProvider URI</h3><p>ContentProvider使用URI ( Uniform Resource Identifier，统一资源标识符）来<strong>唯一标识和访问不同的数据资源</strong>。ContentProvider URI通常具有以下结构：</p><ul><li>content:// :这是一个固定的前级，表示这是一个ContentProvider的URI。</li><li>content://authority/path/id</li><li>authority：用于标识ContentProvider的唯一字符串，通常采用应用的包名加上一个自定义的字符串。在AndroidManifest.xml文件中注册ContentProvider时 ，需要指定它的aandroid:authorities属性。</li><li>path：表示数据资源的类型或类别，可以通过在URI中指定表名作为路径来访问特定表的数据</li><li>id：这是一个可选部分，用于表示特定数据项的ID。在URI中加入ID可以让您访问特定记录的数据。</li></ul><h3 id="定义ContentProvider">定义ContentProvider</h3><div class="highlight-container" data-rel="Kotlin"><figure class="iseeu highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyContentProvider</span> : <span class="type">ContentProvider</span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">()</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="comment">// 初始化ContentProvider，例如创建数据库等</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">query</span><span class="params">(uri: <span class="type">Uri</span>, projection: <span class="type">Array</span>&lt;<span class="type">out</span> <span class="type">String</span>&gt;?, selection: <span class="type">String</span>?,</span></span></span><br><span class="line"><span class="params"><span class="function">        selectionArgs: <span class="type">Array</span>&lt;<span class="type">out</span> <span class="type">String</span>&gt;?, sortOrder: <span class="type">String</span>?)</span></span>: Cursor? &#123;</span><br><span class="line">        <span class="comment">// 根据URI查询数据</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getType</span><span class="params">(uri: <span class="type">Uri</span>)</span></span>: String? &#123;</span><br><span class="line">        <span class="comment">// 返回当前URI对应的数据的MIME类型</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">insert</span><span class="params">(uri: <span class="type">Uri</span>, values: <span class="type">ContentValues</span>?)</span></span>: Uri? &#123;</span><br><span class="line">        <span class="comment">// 根据URI插入数据</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">delete</span><span class="params">(uri: <span class="type">Uri</span>, selection: <span class="type">String</span>?, selectionArgs: <span class="type">Array</span>&lt;<span class="type">out</span> <span class="type">String</span>&gt;?)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="comment">// 根据URI删除数据</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">update</span><span class="params">(uri: <span class="type">Uri</span>, values: <span class="type">ContentValues</span>?, selection: <span class="type">String</span>?,</span></span></span><br><span class="line"><span class="params"><span class="function">                        selectionArgs: <span class="type">Array</span>&lt;<span class="type">out</span> <span class="type">String</span>&gt;?)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="comment">// 根据URI更新数据</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>在manifest中定义contentprovider</p><div class="highlight-container" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">provider</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:name</span>=<span class="string">&quot;.lesson5.MyContentProvider&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:authorities</span>=<span class="string">&quot;com.baidu.myapp.provider&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:exported</span>=<span class="string">&quot;false&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure></div><p>在需要访问数据的地方，通过ContentResolver与ContentProvider进行交互</p><div class="highlight-container" data-rel="Kotlin"><figure class="iseeu highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取ContentResolver对象</span></span><br><span class="line"><span class="keyword">val</span> contentResolver: ContentResolver = getContentResolver()</span><br><span class="line"><span class="comment">// 构造ContentProvider的URI</span></span><br><span class="line"><span class="keyword">val</span> uri: Uri = Uri.parse(<span class="string">&quot;content://com.baidu.myapp.provider/your_table_name&quot;</span>)</span><br><span class="line"><span class="comment">// 使用ContentResolver进行数据查询</span></span><br><span class="line"><span class="keyword">val</span> cursor: Cursor? = contentResolver.query(uri, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>)</span><br></pre></td></tr></table></figure></div><h3 id="FileProvider">FileProvider</h3><img lazyload src="/images/loading.svg" data-src="/posts/2023-Summer-Courses-%E7%99%BE%E5%BA%A6%E7%A7%BB%E5%8A%A8%E7%AB%AF/2023baiduandroidlec5-lec6/image-20230728195943025.png" class title="image-20230728195943025"><img lazyload src="/images/loading.svg" data-src="/posts/2023-Summer-Courses-%E7%99%BE%E5%BA%A6%E7%A7%BB%E5%8A%A8%E7%AB%AF/2023baiduandroidlec5-lec6/image-20230728200648772.png" class title="image-20230728200648772"><p>name是对外的</p><p>path是自己的真实路径</p><h2 id="作业">作业</h2><img lazyload src="/images/loading.svg" data-src="/posts/2023-Summer-Courses-%E7%99%BE%E5%BA%A6%E7%A7%BB%E5%8A%A8%E7%AB%AF/2023baiduandroidlec5-lec6/image-20230728200916933.png" class title="image-20230728200916933"><p>视频的页面可以先留空</p><p>实现能选就行了，存到哪以后再说</p><p>点击首页的加号进入新闻发布页</p><h1>lec6-Android图形图像和多媒体实现</h1><h2 id="图片">图片</h2><h3 id="图片格式介绍">图片格式介绍</h3><img lazyload src="/images/loading.svg" data-src="/posts/2023-Summer-Courses-%E7%99%BE%E5%BA%A6%E7%A7%BB%E5%8A%A8%E7%AB%AF/2023baiduandroidlec5-lec6/image-20230729104508442.png" class title="image-20230729104508442"><h3 id="图片内存大小">图片内存大小</h3><p>对于Bitmap对象，有几种常见<strong>色彩格式</strong></p><ul><li>Bitmap.Config.ALPHA_8：每个像素占1个字节</li><li>Bitmap.Config.RGB_565：每个像素占2个字节</li><li>Bitmap.Config.ARGB_4444：每个像素占2个字节</li><li>Bitmap.Config.ARGB_8888：每个像素占2个字节</li></ul><img lazyload src="/images/loading.svg" data-src="/posts/2023-Summer-Courses-%E7%99%BE%E5%BA%A6%E7%A7%BB%E5%8A%A8%E7%AB%AF/2023baiduandroidlec5-lec6/image-20230729104658045.png" class title="image-20230729104658045"><h3 id="1-使用ImageView加载图片">1.使用ImageView加载图片</h3><img lazyload src="/images/loading.svg" data-src="/posts/2023-Summer-Courses-%E7%99%BE%E5%BA%A6%E7%A7%BB%E5%8A%A8%E7%AB%AF/2023baiduandroidlec5-lec6/image-20230729145830263.png" class title="image-20230729145830263"><p>如Kotlin API</p><div class="highlight-container" data-rel="Kotlin"><figure class="iseeu highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 找到ImageView控件</span></span><br><span class="line">ImageView imageView = findViewById(R.id.imageView);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置图像资源</span></span><br><span class="line">imageView.setImageResource(R.drawable.sample_image);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置透明度（0为完全透明，1为完全不透明）</span></span><br><span class="line">imageView.setAlpha(<span class="number">0.5f</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置缩放类型</span></span><br><span class="line">imageView.setScaleType(ImageView.ScaleType.CENTER_CROP);</span><br></pre></td></tr></table></figure></div><p>ImageView组件:xml</p><div class="highlight-container" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ImageView</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:src</span>=<span class="string">&quot;@drawable/plane&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:scaleType</span>=<span class="string">&quot;center&quot;</span></span></span><br><span class="line"><span class="tag">    /&gt;</span></span><br></pre></td></tr></table></figure></div><p>scaleType的值可以修改为上图所列</p><h3 id="dp与sp">dp与sp</h3><img lazyload src="/images/loading.svg" data-src="/posts/2023-Summer-Courses-%E7%99%BE%E5%BA%A6%E7%A7%BB%E5%8A%A8%E7%AB%AF/2023baiduandroidlec5-lec6/image-20230729150152468.png" class title="image-20230729150152468"><p>sp做单位会受缩放影响</p><h3 id="2-使用android内置API加载图片">2.使用android内置API加载图片</h3><div class="highlight-container" data-rel="Kotlin"><figure class="iseeu highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> bitmap: BitMap = BitmapFactory.decodeResource(getResources(), R.drawable.example_image)</span><br><span class="line">imageView.setImageBitmap(bitmap)</span><br></pre></td></tr></table></figure></div><p>基本不怎么用了，网络图片加载还要先异步请求</p><h3 id="3-第三方图片加载库">3.第三方图片加载库</h3><img lazyload src="/images/loading.svg" data-src="/posts/2023-Summer-Courses-%E7%99%BE%E5%BA%A6%E7%A7%BB%E5%8A%A8%E7%AB%AF/2023baiduandroidlec5-lec6/image-20230729150808919.png" class title="image-20230729150808919"><p>推荐使用Glide或者Fresco</p><div class="highlight-container" data-rel="Kotlin"><figure class="iseeu highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Glide.with(<span class="keyword">this</span>)</span><br><span class="line"> .load(imageUrl)</span><br><span class="line"> .placeholder(R.drawable.placeholder) <span class="comment">// 设置占位图</span></span><br><span class="line"> .error(R.drawable.error) <span class="comment">// 设置加载错误时显示的图片</span></span><br><span class="line"> .thumbnail(<span class="number">0.5f</span>) <span class="comment">//设置缩略图（加载原图的一部分）</span></span><br><span class="line"> .into(imageView);<span class="comment">// 放入imageView中</span></span><br></pre></td></tr></table></figure></div><h2 id="图片缓存">图片缓存</h2><p>三级缓存策略</p><p>三级缓存减少不必要的网络请求和内存占用</p><ul><li>内存缓存</li><li>本地缓存</li><li>网络缓存</li></ul><h2 id="图片处理">图片处理</h2><p>压缩、裁剪、缩放、滤镜、拼接、合成、旋转</p><img lazyload src="/images/loading.svg" data-src="/posts/2023-Summer-Courses-%E7%99%BE%E5%BA%A6%E7%A7%BB%E5%8A%A8%E7%AB%AF/2023baiduandroidlec5-lec6/image-20230729152242645.png" class title="image-20230729152242645"><h2 id="音频">音频</h2><img lazyload src="/images/loading.svg" data-src="/posts/2023-Summer-Courses-%E7%99%BE%E5%BA%A6%E7%A7%BB%E5%8A%A8%E7%AB%AF/2023baiduandroidlec5-lec6/image-20230729152325818.png" class title="image-20230729152325818"><h3 id="MediaPlayer的使用方式">MediaPlayer的使用方式</h3><ol><li><p>创建MediaPlayer实例</p><div class="highlight-container" data-rel="Kotlin"><figure class="iseeu highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> mediaPlayer: MediaPlayer = MediaPlayer()</span><br></pre></td></tr></table></figure></div></li><li><p>设置音频数据源</p><div class="highlight-container" data-rel="Kotlin"><figure class="iseeu highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置本地音频数据源</span></span><br><span class="line">mediaPlayer.setDataSource(<span class="string">&quot;/path/to/your/audio/file&quot;</span>)</span><br><span class="line"><span class="comment">// 设置网络音频数据源</span></span><br><span class="line">mediaPlayer.setDataSource(<span class="string">&quot;http://example.com/your/audio/file.mp3&quot;</span>)</span><br></pre></td></tr></table></figure></div></li><li><p>准备播放</p><div class="highlight-container" data-rel="Kotlin"><figure class="iseeu highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 同步准备</span></span><br><span class="line">mediaPlayer.prepare()</span><br><span class="line"><span class="comment">// 异步准备</span></span><br><span class="line">mediaPlayer.prepareAsync()</span><br></pre></td></tr></table></figure></div></li><li><p>设置监听器</p><div class="highlight-container" data-rel="Kotlin"><figure class="iseeu highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置准备完成监听器：</span></span><br><span class="line">mediaPlayer.setOnPreparedListener(<span class="keyword">object</span>: MediPlayer.OnPreparedListener&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onPrepared</span><span class="params">(mp: <span class="type">MediaPlayer</span>?)</span></span> &#123;</span><br><span class="line">        <span class="comment">// 异步准备完成回调</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 设置播放完成监听器：</span></span><br><span class="line">mediaPlayer.setOnCompletionListener(<span class="keyword">object</span>: MediaPlayer.OnCompletionListener&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onConpletion</span><span class="params">(mp: <span class="type">MediaPlayer</span>?)</span></span> &#123;</span><br><span class="line">        <span class="comment">// 播放完成后，可以进行相应的操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></div></li><li><p>控制播放</p><div class="highlight-container" data-rel="Kotlin"><figure class="iseeu highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 播放</span></span><br><span class="line">mediaPlayer.start()</span><br><span class="line"><span class="comment">// 暂停</span></span><br><span class="line">mediaPlayer.pause()</span><br><span class="line"><span class="comment">// 停止</span></span><br><span class="line">mediaPlayer.stop()</span><br><span class="line"><span class="comment">// 释放资源</span></span><br><span class="line">mediaPlayer.release()</span><br></pre></td></tr></table></figure></div></li></ol><blockquote><p><code>prepare()</code>的调用可能需要很长时间，所以<strong>切勿从应用的界面线程中调用它</strong>，界面中任何响应时间超过十分之一秒的操作都会导致明显的暂停，并让用户觉得应用运行缓慢。</p><p>推荐使用<code>prepareAsync()</code> 在后台准备媒体，准备就绪后系统会调用通过 <code>setOnPreparedListener()</code> 配置的 <code>MediaPlayer.OnPreparedListener</code> 的 <code>onPrepared()</code> 方法。</p><p>参考：<a class="link" href="https://developer.android.com/guide/topics/media/mediaplayer?hl=zh-cn">MediaPlayer官方手册 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p></blockquote><h4 id="在Service中使用MediaPlayer">在Service中使用MediaPlayer</h4><img lazyload src="/images/loading.svg" data-src="/posts/2023-Summer-Courses-%E7%99%BE%E5%BA%A6%E7%A7%BB%E5%8A%A8%E7%AB%AF/2023baiduandroidlec5-lec6/image-20230729153041209.png" class title="image-20230729153041209"><h4 id="SoundPool的使用">SoundPool的使用</h4><img lazyload src="/images/loading.svg" data-src="/posts/2023-Summer-Courses-%E7%99%BE%E5%BA%A6%E7%A7%BB%E5%8A%A8%E7%AB%AF/2023baiduandroidlec5-lec6/image-20230729162410383.png" class title="image-20230729162410383"><img lazyload src="/images/loading.svg" data-src="/posts/2023-Summer-Courses-%E7%99%BE%E5%BA%A6%E7%A7%BB%E5%8A%A8%E7%AB%AF/2023baiduandroidlec5-lec6/image-20230729162420586.png" class title="image-20230729162420586"><h4 id="AudioManager控制音频焦点">AudioManager控制音频焦点</h4><img lazyload src="/images/loading.svg" data-src="/posts/2023-Summer-Courses-%E7%99%BE%E5%BA%A6%E7%A7%BB%E5%8A%A8%E7%AB%AF/2023baiduandroidlec5-lec6/image-20230729162814965.png" class title="image-20230729162814965"><h2 id="视频">视频</h2><h3 id="播放视频的方式">播放视频的方式</h3><img lazyload src="/images/loading.svg" data-src="/posts/2023-Summer-Courses-%E7%99%BE%E5%BA%A6%E7%A7%BB%E5%8A%A8%E7%AB%AF/2023baiduandroidlec5-lec6/image-20230729163108887.png" class title="image-20230729163108887"><h3 id="VideoView">VideoView</h3><div class="highlight-container" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">VideoView</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">&quot;@+id/video_view&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">    /&gt;</span></span><br></pre></td></tr></table></figure></div><div class="highlight-container" data-rel="Kotlin"><figure class="iseeu highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 加载视频并播放</span></span><br><span class="line"><span class="keyword">val</span> videoView = findViewById&lt;VideoView&gt;(R.id.video_view).apply &#123;</span><br><span class="line">    setVideoURI(Uri.parse(<span class="string">&quot;https://globalimg.sucai999.com/uploadfile/20211210/267440/132836000096069452.mp4&quot;</span>))</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MediaController提供播放、暂停、快进、后退等按钮</span></span><br><span class="line">videoView.setMediaController(MediaController(<span class="keyword">this</span>).apply&#123;</span><br><span class="line">    <span class="comment">// 锚点视图，点击依附视图可以显示或隐藏控制按钮</span></span><br><span class="line">    setAnchorView(videoView)</span><br><span class="line">    <span class="comment">// 播放视频</span></span><br><span class="line">    start()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></div><h3 id="SurfaceView介绍">SurfaceView介绍</h3><img lazyload src="/images/loading.svg" data-src="/posts/2023-Summer-Courses-%E7%99%BE%E5%BA%A6%E7%A7%BB%E5%8A%A8%E7%AB%AF/2023baiduandroidlec5-lec6/image-20230729164234830.png" class title="image-20230729164234830"><h3 id="TextureView介绍">TextureView介绍</h3><img lazyload src="/images/loading.svg" data-src="/posts/2023-Summer-Courses-%E7%99%BE%E5%BA%A6%E7%A7%BB%E5%8A%A8%E7%AB%AF/2023baiduandroidlec5-lec6/image-20230729164328290.png" class title="image-20230729164328290"><blockquote><p><code>SurfaceView</code>和<code>TextureView</code>都是Android中用于显示图像、视频或动画的视图组件，但它们在实现和使用上有一些区别。</p><ol><li>SurfaceView: <code>SurfaceView</code>是一个特殊的视图，它允许你在一个独立的绘图表面上绘制内容。<code>SurfaceView</code>适用于需要频繁更新的图像、视频播放、动画等场景，因为它允许在后台线程中进行绘制，避免了在主线程中的UI阻塞。主要特点和用途包括：<ul><li>可以在后台线程（非UI线程）中绘制内容，避免主线程阻塞。</li><li>使用双缓冲技术，提高绘制性能，避免闪烁现象。</li><li>适合实现实时视频播放、相机预览等需要频繁刷新的场景。</li><li>对于自定义绘图、动画或游戏等复杂场景，更为灵活和强大。</li></ul></li><li>TextureView: <code>TextureView</code>是一个可以显示视频或动画的视图组件。它与<code>SurfaceView</code>不同之处在于，它在视图层级中是一个普通的<code>View</code>，可以与其他视图组件一起进行布局，并在Android的硬件加速支持下提供更高的灵活性。主要特点和用途包括：<ul><li>可以在布局中与其他视图组件一起使用，更容易实现复杂的布局。</li><li>支持硬件加速，提供更高的绘制性能。</li><li>适用于视频播放、动画等场景，可以通过<code>MediaPlayer</code>或<code>SurfaceTexture</code>来实现视频的播放。</li><li>可以与动画效果、透明度等属性结合使用，实现更丰富的视觉效果。</li></ul></li></ol><p>选择使用<code>SurfaceView</code>还是<code>TextureView</code>取决于你的应用需求。如果你需要频繁更新、复杂的绘图逻辑或更好的性能，那么<code>SurfaceView</code>可能是更好的选择。如果你希望在布局中更灵活地使用，或者需要与其他视图组件结合使用，那么<code>TextureView</code>可能更适合你。</p></blockquote><h3 id="MeidaPlayer-SurfaceView播放视频">MeidaPlayer+SurfaceView播放视频</h3><img lazyload src="/images/loading.svg" data-src="/posts/2023-Summer-Courses-%E7%99%BE%E5%BA%A6%E7%A7%BB%E5%8A%A8%E7%AB%AF/2023baiduandroidlec5-lec6/image-20230729164812888.png" class title="image-20230729164812888"><h3 id="MeidaPlayer-TextureView播放视频">MeidaPlayer+TextureView播放视频</h3><img lazyload src="/images/loading.svg" data-src="/posts/2023-Summer-Courses-%E7%99%BE%E5%BA%A6%E7%A7%BB%E5%8A%A8%E7%AB%AF/2023baiduandroidlec5-lec6/image-20230729164953080.png" class title="image-20230729164953080"><img lazyload src="/images/loading.svg" data-src="/posts/2023-Summer-Courses-%E7%99%BE%E5%BA%A6%E7%A7%BB%E5%8A%A8%E7%AB%AF/2023baiduandroidlec5-lec6/image-20230729165014013.png" class title="image-20230729165014013"><h3 id="ExoPlayer">ExoPlayer</h3><p>更加灵活，可拓展性比MediaPlayer强</p><p>基本教程：<a class="link" href="https://developer.android.com/guide/topics/media/exoplayer/hello-world">Hello World <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p><p>ExoPlayer is deprecated，原有的ExoPlayer已经被Media3 ExoPlayer取代</p><p><code>build.gradle</code>中不使用<code>com.google.android.exoplayer:exoplayer-core:2.12.0</code>了，新增如下内容</p><div class="highlight-container" data-rel="Gradle"><figure class="iseeu highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">implementation <span class="string">&quot;androidx.media3:media3-exoplayer:1.1.0&quot;</span></span><br><span class="line">implementation <span class="string">&quot;androidx.media3:media3-exoplayer-dash:1.1.0&quot;</span></span><br><span class="line">implementation <span class="string">&quot;androidx.media3:media3-ui:1.1.0&quot;</span></span><br></pre></td></tr></table></figure></div><blockquote><p>这一段不知道是啥，别人的笔记</p></blockquote><h4 id="如何使用MediaPlayer访问本地文件，并请求权限">如何使用MediaPlayer访问本地文件，并请求权限</h4><p>我们在<code>/storage/emulated/0/Music</code>目录上传了<code>guitar.mp3</code>音乐文件，并希望播放此音乐</p><p>错误做法：直接设置<code>mediaPlayer.setDataSource(/storage/emulated/0/Music/guitar.mp3)</code>或<code>mediaPlayer.setDataSource(Environment.getExternalStorageDirectory().path + &quot;/Music/guitar.mp3&quot;)</code>都会报错<code>java.io.FileNotFoundException: /storage/emulated/0/Music/guitar.mp3: open failed: EACCES (Permission denied)</code>，意思没有访问的权限。</p><p>探索过程：</p><ol><li>无效：设置<a href="https://github.com/captain-miao/AndroidException/issues/7"><code>android:requestLegacyExternalStorage=&quot;true&quot;</code></a>。This solution is temporary and won’t work on Android 11</li><li>有效：<a class="link" href="https://stackoverflow.com/a/37819897/17627011">实现运行时权限获取 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>，顺便参考<a class="link" href="https://sujeetkumargpt06.medium.com/storage-access-in-android-11-and-above-scoped-storage-8dc439e87441">storage access in android 11 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>，个人感觉<code>allowPermissionForFile()</code>那个函数不能直接同步请求，应该放在异步任务中完成</li></ol><p>解决方法：</p><ol><li><p>在settings-&gt;Apps-&gt;Your_app-&gt;Permissions手动打开存储权限，不过这只适用于我们本地开发这么做，实际情况下需要引导用户打开权限</p></li><li><p>请求用户打开权限</p></li></ol><ul><li><code>ActivityManifest.xml</code> 适用于API&lt;=32的情景，若API&gt;32，会提醒<code>you should instead use one or more new storage permissions: READ_MEDIA_IMAGES, READ_MEDIA_VIDEO or READ_MEDIA_AUDIO</code></li></ul><div class="highlight-container" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">&quot;android.permission.READ_EXTERNAL_STORAGE&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure></div><ul><li><code>MediaPlayerActivity.kt</code></li></ul><p>假如在用户界面同步请求权限，会导致应用程序卡主、长时间无响应甚至crash，所以我们应当在后台线程或异步任务重进行权限请求，避免阻塞主线程。这里借助</p><div class="highlight-container" data-rel="Kotlin"><figure class="iseeu highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generated by chatgpt</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** 要执行的任务 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">playMusic</span><span class="params">()</span></span> &#123;</span><br><span class="line">    mediaPlayer.setDataSource(Environment.getExternalStorageDirectory().path + <span class="string">&quot;/Music/guitar.mp3&quot;</span>)</span><br><span class="line">    mediaPlayer.setAudioAttributes(</span><br><span class="line">        AudioAttributes.Builder()</span><br><span class="line">            .setUsage(AudioAttributes.USAGE_MEDIA)</span><br><span class="line">            .setContentType(AudioAttributes.CONTENT_TYPE_MUSIC)</span><br><span class="line">            .build()</span><br><span class="line">    )</span><br><span class="line">    mediaPlayer.prepareAsync()</span><br><span class="line">    <span class="comment">// 准备好即播放</span></span><br><span class="line">    mediaPlayer.setOnPreparedListener &#123; mp -&gt; mp?.start() &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> PERMISSION_REQUEST_CODE = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查是否取得权限，若没有对应权限则在coroutine环境下请求权限</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">checkAndRequestPermissionsAsync</span><span class="params">()</span></span> &#123;</span><br><span class="line">    GlobalScope.launch(Dispatchers.Main) &#123;</span><br><span class="line">        <span class="keyword">val</span> permissionGranted = checkPermissions()</span><br><span class="line">        <span class="keyword">if</span> (!permissionGranted) &#123;</span><br><span class="line">            <span class="comment">// 请求权限</span></span><br><span class="line">            requestPermissionsAsync()</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 拥有权限，可以读取文件</span></span><br><span class="line">            playMusic()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">checkPermissions</span><span class="params">()</span></span>: <span class="built_in">Boolean</span> = withContext(Dispatchers.IO) &#123;</span><br><span class="line">    ContextCompat.checkSelfPermission(</span><br><span class="line">        <span class="keyword">this</span><span class="symbol">@MediaPlayerDemoActivity</span>,</span><br><span class="line">        Manifest.permission.READ_EXTERNAL_STORAGE</span><br><span class="line">    ) == PERMISSION_GRANTED</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">requestPermissionsAsync</span><span class="params">()</span></span> = withContext(Dispatchers.Main) &#123;</span><br><span class="line">    <span class="comment">// 要求mini api &gt;= 23，这个可以在build.gradle(Module:app)里改</span></span><br><span class="line">    requestPermissions(</span><br><span class="line">        arrayOf(Manifest.permission.READ_EXTERNAL_STORAGE),</span><br><span class="line">        PERMISSION_REQUEST_CODE</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onRequestPermissionsResult</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    requestCode: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    permissions: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;,</span></span></span><br><span class="line"><span class="params"><span class="function">    grantResults: <span class="type">IntArray</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.onRequestPermissionsResult(requestCode, permissions, grantResults)</span><br><span class="line">    <span class="keyword">if</span> (requestCode == PERMISSION_REQUEST_CODE) &#123;</span><br><span class="line">        <span class="keyword">if</span> (grantResults.isNotEmpty() &amp;&amp; grantResults[<span class="number">0</span>] == PackageManager.PERMISSION_GRANTED) &#123;</span><br><span class="line">            playMusic()</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 用户拒绝了权限，根据需要处理权限未授予的情况</span></span><br><span class="line">            Toast.makeText(<span class="keyword">this</span>, <span class="string">&quot;You need to allow reading audio permission&quot;</span>, Toast.LENGTH_SHORT).show()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><p>上述方法是获取本地存储的资源，简单起见可以将文件放在raw文件夹下，然后通过<code>setDataResource</code>的方法获取（上述已给出实例）</p><p>如果要实现后台播放音乐，就需要用到Service的知识，暂不详述（其实不会x</p><h2 id="随堂作业">随堂作业</h2><img lazyload src="/images/loading.svg" data-src="/posts/2023-Summer-Courses-%E7%99%BE%E5%BA%A6%E7%A7%BB%E5%8A%A8%E7%AB%AF/2023baiduandroidlec5-lec6/image-20230729165114622.png" class title="image-20230729165114622"><blockquote><p>不用能上下滑动，右边没有收藏分享啥的也可以</p></blockquote><h1>lec7-Android持久化</h1><img lazyload src="/images/loading.svg" data-src="/posts/2023-Summer-Courses-%E7%99%BE%E5%BA%A6%E7%A7%BB%E5%8A%A8%E7%AB%AF/2023baiduandroidlec5-lec6/image-20230729165637375.png" class title="image-20230729165637375"><h2 id="什么是持久化">什么是持久化</h2><p>持久化是将数据保存到可永久保存的存储设备中的过程。</p><img lazyload src="/images/loading.svg" data-src="/posts/2023-Summer-Courses-%E7%99%BE%E5%BA%A6%E7%A7%BB%E5%8A%A8%E7%AB%AF/2023baiduandroidlec5-lec6/image-20230729200322716.png" class title="image-20230729200322716"><p>持久化是将程序数据在 <strong>持久状态</strong> 和 <strong>瞬间状态</strong> 见转换的机制</p><p><strong>三种数据持久化方式</strong></p><img lazyload src="/images/loading.svg" data-src="/posts/2023-Summer-Courses-%E7%99%BE%E5%BA%A6%E7%A7%BB%E5%8A%A8%E7%AB%AF/2023baiduandroidlec5-lec6/image-20230729200426136.png" class title="image-20230729200426136"><h2 id="Shared-Preferences">Shared Preferences</h2><ul><li><p>是 <strong>Android系统</strong> 提供的一种<strong>轻量级</strong>的存储方式。</p></li><li><p>常用于存储简单的 应用设置、配置数据 或 状态信息。</p></li><li><p>使用 <strong>键值对</strong> 的方式来存储数据。</p></li><li><p>支持 <strong>多种不同数据类型</strong> (如字符串、整数、浮点数、布尔值和长整型)</p></li><li><p>相关数据存放在 xml 中。 xml文件的存放路径为：</p><p>/data/data/packageName/shared_prefs/目录下</p></li></ul><h3 id="获取方式">获取方式</h3><ol><li><p>通过Context对象获取： Context 的 getSharedPreferences() 方法，需要传入2个参数： <strong>文件名</strong> 和 <strong>模式</strong> ( 目前只有<strong>MODE_PRIVATE</strong>, 表示只有当前应用可以访问这个Shared Preferences)</p><div class="highlight-container" data-rel="Kotlin"><figure class="iseeu highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码示例</span></span><br><span class="line"><span class="keyword">val</span> sharedPreferences = context.getSharedPreferences(<span class="string">&quot;my_prefs&quot;</span>, Context.MODE_PRIVATE)</span><br></pre></td></tr></table></figure></div></li><li><p>通过Activity对象获取：<strong>Activity</strong> 中的 <strong>getPreferences()</strong> 方法， 它默认将<strong>当前活动的类名</strong>作为文件名，只需要传入<strong>操作模式</strong>作为参数</p><div class="highlight-container" data-rel="Kotlin"><figure class="iseeu highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> sharedPreferences = getPreferences(MODE_PRIVATE);</span><br></pre></td></tr></table></figure></div></li><li><p>通过PreferenceManager类获取：<strong>PreferenceManager</strong>的<strong>getDefaultSharedPreferences()</strong>, 它接收一个 <strong>Context参数</strong></p><div class="highlight-container" data-rel="Kotlin"><figure class="iseeu highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> sharedPreferences = PreferenceManager.getDefaultSharedPreferences(context)</span><br></pre></td></tr></table></figure></div></li></ol><h3 id="如何写入数据">如何写入数据</h3><p>使用Editor对象来写入数据。Editor对象可以通过SharedPreferences.edit()方法获取</p><div class="highlight-container" data-rel="Kotlin"><figure class="iseeu highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 创建一个SharedPreferences对象</span></span><br><span class="line"><span class="keyword">val</span> sharedPreferences = getPreferences(Context.MODE_PRIVATE)</span><br><span class="line"><span class="comment">// 2. 实例化SharedPreferences.Editor对象</span></span><br><span class="line"><span class="keyword">val</span> editor =sharedPreferences.edit()</span><br><span class="line"><span class="comment">// 3. 将获取过来的值放入文件</span></span><br><span class="line">editor.putString(<span class="string">&quot;userName&quot;</span>, <span class="string">&quot;野比&quot;</span>)</span><br><span class="line">editor.putInt(<span class="string">&quot;age&quot;</span>, <span class="number">17</span>)</span><br><span class="line"><span class="comment">// 4. 提交(异步提交)</span></span><br><span class="line">editor.apply()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 提交(同步写入)</span></span><br><span class="line">editor.commit()</span><br></pre></td></tr></table></figure></div><p>同步写入会阻塞当前线程，直到数据写入完成。如果写入数据较多，会导致界面卡顿。因此建议写入大量数据时使用apply()方法异步写入（<strong>意思就是不会立即生效</strong></p><h3 id="其他操作">其他操作</h3><div class="highlight-container" data-rel="Kotlin"><figure class="iseeu highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建（获取）一个SharedPreferences对象</span></span><br><span class="line"><span class="keyword">val</span> sharedPreferences = getPreferences(Context.MODE_PRIVATE)</span><br><span class="line"><span class="comment">// 读取数据</span></span><br><span class="line"><span class="keyword">val</span> name = sharedPreferences.getString(<span class="string">&quot;userName&quot;</span>, <span class="string">&quot;&quot;</span>); <span class="comment">// &quot;&quot;是默认值，当键&quot;userName&quot;不存在或者没有对应的值时，getString()方法会返回这个默认值</span></span><br><span class="line"><span class="keyword">val</span> age = sharedPreferences.getInt(<span class="string">&quot;age&quot;</span>, <span class="number">0</span>)</span><br><span class="line"><span class="comment">// 删除数据</span></span><br><span class="line"><span class="keyword">val</span> editor = sharedPreferences.edit()</span><br><span class="line">editor.remove(<span class="string">&quot;userName&quot;</span>)</span><br><span class="line">editor.apply()</span><br><span class="line"><span class="comment">// 清空数据，一般不建议使用</span></span><br><span class="line">editor.clear()</span><br><span class="line">editor.apply()</span><br></pre></td></tr></table></figure></div><blockquote><p>感觉可以用在某个activity的临时数据上，但要注意每个activity要有其独立的sp，名字要区分开，否则会导致写到相同的，清除了同一个文件，当然这也需要从代码上进行物理空间的解耦</p></blockquote><h3 id="优点">优点</h3><img lazyload src="/images/loading.svg" data-src="/posts/2023-Summer-Courses-%E7%99%BE%E5%BA%A6%E7%A7%BB%E5%8A%A8%E7%AB%AF/2023baiduandroidlec5-lec6/image-20230729201331372.png" class title="image-20230729201331372"><h3 id="缺点">缺点</h3><p>容量有限、不支持复杂的数据结构、难以维护、安全性较低</p><img lazyload src="/images/loading.svg" data-src="/posts/2023-Summer-Courses-%E7%99%BE%E5%BA%A6%E7%A7%BB%E5%8A%A8%E7%AB%AF/2023baiduandroidlec5-lec6/image-20230729202433788.png" class title="image-20230729202433788"><p>跨进程不安全、全量写入、加载缓慢</p><img lazyload src="/images/loading.svg" data-src="/posts/2023-Summer-Courses-%E7%99%BE%E5%BA%A6%E7%A7%BB%E5%8A%A8%E7%AB%AF/2023baiduandroidlec5-lec6/image-20230729204057281.png" class title="image-20230729204057281"><p>卡顿</p><img lazyload src="/images/loading.svg" data-src="/posts/2023-Summer-Courses-%E7%99%BE%E5%BA%A6%E7%A7%BB%E5%8A%A8%E7%AB%AF/2023baiduandroidlec5-lec6/image-20230729204201456.png" class title="image-20230729204201456"><h2 id="KV存储（简单了解，不是android原生的，SP的衍生">KV存储（简单了解，不是android原生的，SP的衍生</h2><p>常用的有MMKV，Booster，PreferceDataStore， UniKV， 代理方式优化写入性能</p><img lazyload src="/images/loading.svg" data-src="/posts/2023-Summer-Courses-%E7%99%BE%E5%BA%A6%E7%A7%BB%E5%8A%A8%E7%AB%AF/2023baiduandroidlec5-lec6/image-20230729205815102.png" class title="image-20230729205815102"><blockquote><p>UniKV：百度在用的</p><p>代理方式：字节在用</p></blockquote><ul><li>MMKV<ul><li>内存准备</li><li>数据组织</li><li>写入优化</li></ul></li></ul><h2 id="文件存储">文件存储</h2><p>Android的文件存储方式，适用于存储本地的二进制数据。可以通过读写FileInputStream 和 FileOutputStream来操作文件</p><p>区别于SharedPreference，<strong>更适合用来存储html数据、下载文件、日志打印、照片、视频等。</strong></p><h3 id="存储空间">存储空间</h3><img lazyload src="/images/loading.svg" data-src="/posts/2023-Summer-Courses-%E7%99%BE%E5%BA%A6%E7%A7%BB%E5%8A%A8%E7%AB%AF/2023baiduandroidlec5-lec6/image-20230729221942448.png" class title="image-20230729221942448"><ul><li>/data/data<ul><li><strong>用户应用</strong> 的安装目录，如百度地图的安装路径是 /data/data/com.baidu.com, 该目录需要root权限</li></ul></li><li>/system<ul><li><strong>系统应用</strong> 的安装目录</li></ul></li><li>/storage<ul><li><strong>内置存储卡</strong> 和 <strong>外置SD卡</strong> 的挂载点</li><li>外置SD卡挂载节点：/storage/sdcard1</li><li>内置存储卡挂载节点：/storage/emulated/0</li><li>不同的设备挂载节点不同，有的可能在 /mnt下</li></ul></li></ul><h3 id="内部存储空间">内部存储空间</h3><img lazyload src="/images/loading.svg" data-src="/posts/2023-Summer-Courses-%E7%99%BE%E5%BA%A6%E7%A7%BB%E5%8A%A8%E7%AB%AF/2023baiduandroidlec5-lec6/image-20230729222446994.png" class title="image-20230729222446994"><ul><li>应用专属空间：创建其他应用不需要访问或不应访问的文件。<ul><li><strong>getFilesDir()</strong>, data/data/包名/files/，用于持久文件</li><li><strong>getCacheDir()</strong>, data/data/包名/cache/，用于暂存文件</li></ul></li></ul><h3 id="外部存储空间">外部存储空间</h3><img lazyload src="/images/loading.svg" data-src="/posts/2023-Summer-Courses-%E7%99%BE%E5%BA%A6%E7%A7%BB%E5%8A%A8%E7%AB%AF/2023baiduandroidlec5-lec6/image-20230729222434819.png" class title="image-20230729222434819"><ul><li><strong>getExternalFilesDir()</strong>, /mnt/sdcard/Android/data/包名/files/，用于持久文件</li><li>getExternalCacheDir(), /mnt/sdcard/Android/data/包名/cache/，用于暂存文件</li></ul><h3 id="具体代码应用">具体代码应用</h3><p>Context提供两种方法来打开数据文件里的文件IO流</p><ul><li>openFileInput(String name), 读文件</li><li>openFileOutput(String name, int mode), 写文件，其中第二个参数指定打开文件的模式<ul><li><strong>MODE_PRIVATE, 默认操作模式，当指定同样文件名的时候会覆盖原有文件内容。</strong></li><li>MODE_APPEND, 如果文件不存在就创建文件，如果存在就往后追加。</li></ul></li></ul><h4 id="读取文件">读取文件</h4><div class="highlight-container" data-rel="Kotlin"><figure class="iseeu highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用openFileinput() 以信息流的形式读取文件</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 创建一个FileInputstream 对象</span></span><br><span class="line">    <span class="keyword">val</span> fis: FileInputStream = openFileInput(<span class="string">&quot;filename.txt&quot;</span>)</span><br><span class="line">    <span class="comment">// 读取文件内容</span></span><br><span class="line">    <span class="keyword">val</span> isr = InputStreamReader(fis)</span><br><span class="line">    <span class="keyword">val</span> bufferedReader = BufferedReader(isr)</span><br><span class="line">    <span class="keyword">var</span> line: String?</span><br><span class="line">    <span class="keyword">while</span> (bufferedReader.readLine().also &#123;line = it &#125; != <span class="literal">null</span>) &#123; Log.d(TAG, line!!) &#125;</span><br><span class="line">    <span class="comment">// 关闭文件流</span></span><br><span class="line">    bufferedReader.close()</span><br><span class="line">    isr.close() </span><br><span class="line">    fis.close()</span><br><span class="line">&#125; <span class="keyword">catch</span> (e: IOException) &#123;</span><br><span class="line">    e.printStackTrace)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="写入文件">写入文件</h4><div class="highlight-container" data-rel="Kotlin"><figure class="iseeu highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 openFileOutput()写入文件</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 创建一个FileOutputStream 对象</span></span><br><span class="line">    <span class="keyword">val</span> fos: FileOutputStream = openFileOutput(<span class="string">&quot;filename. txt&quot;</span>, MODE_PRIVATE)</span><br><span class="line">    <span class="comment">// 写入文件内容</span></span><br><span class="line">    <span class="keyword">val</span> <span class="keyword">data</span> = <span class="string">&quot;Hello, world!&quot;</span></span><br><span class="line">    <span class="keyword">val</span> bytes = <span class="keyword">data</span>.toByteArray()</span><br><span class="line">    fos.write(bytes)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭文件流</span></span><br><span class="line">    fos.close()</span><br><span class="line">&#125; <span class="keyword">catch</span> (e: IOException) &#123;</span><br><span class="line">e.printStackTrace)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="外部存储空间-2">外部存储空间</h4><p>读取外部存储中的文件之前，需要在AndroidManifest.xml文件中添加相应的权限声明</p><div class="highlight-container" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">user-permission</span> <span class="attr">adnroid:name</span>=<span class="string">&quot;android.permission.READ_EXTERNAL_STORAGE&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure></div><p>之后跟内部存储方式的区别只是获取file的路径不同</p><div class="highlight-container" data-rel="Kotlin"><figure class="iseeu highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 指定外部存储的路径和文件名</span></span><br><span class="line"><span class="keyword">val</span> file = File(Environment.getExternalStorageDirectory(), <span class="string">&quot;filename.txt&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建文件输入流</span></span><br><span class="line"><span class="keyword">val</span> fis = FileInputStream(file)</span><br></pre></td></tr></table></figure></div><h2 id="数据库存储">数据库存储</h2><h3 id="SQLite数据库">SQLite数据库</h3><ul><li><strong>SQLite</strong>是一款<strong>轻量级</strong>的<strong>关系型数据库</strong>，它的运行<strong>速度快</strong>，<strong>占用资源少</strong>，通常只需要几百k的内存即可。</li><li>因而<strong>特别适合</strong>在<strong>移动设备</strong>上使用</li><li>SQLite不仅支持<strong>标准的SQL语法</strong>，还遵循数据库<strong>事务管理</strong></li><li>只要以前用过其他<strong>关系型数据库</strong>就可以很快上手</li></ul><h4 id="创建数据库">创建数据库</h4><ul><li>为了更方便地<strong>管理数据库</strong>，提供了一个帮助类 <strong>SQLiteOpenHelper</strong></li><li>新建一个类MyDatabaseHelper，<strong>继承SQLiteOpenHelper</strong>，实现三个方法：构造函数，onCreate，onUpgrade</li></ul><div class="highlight-container" data-rel="Kotlin"><figure class="iseeu highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyDBHelper</span>(context: Context): SQLiteOpenHelper(context, DATABASE_NAME, <span class="literal">null</span>, DATABASE_VERSION) &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(db: <span class="type">SQLiteDatabase</span>)</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onUpgrade</span><span class="params">(db: <span class="type">SQLiteDatabase</span>, oldVersion: <span class="type">Int</span>, nerVersion: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">val</span> DATABASE_VERSION = <span class="number">1</span></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">val</span> DATABASE_NAME = <span class="string">&quot;Book.db&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="highlight-container" data-rel="Kotlin"><figure class="iseeu highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(db: <span class="type">SQLiteDatabase</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// Book表的加标语句， id是整型主键自增长</span></span><br><span class="line">    <span class="comment">// text表示文本类型</span></span><br><span class="line">    <span class="keyword">val</span> createBook = <span class="string">&quot;create table Book(id integer primary key autoincrement, author text, name text)&quot;</span></span><br><span class="line">    db.execSQL(createBook)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="添加数据">添加数据</h4><ul><li><p>Android提供了<strong>一系列的辅佐性方法</strong>，使得在Android中，<strong>可以不去写SQL语句</strong>也能完成<strong>增删查改</strong>操作。</p></li><li><p>调用<strong>SQLiteOpenHelper</strong>的**getReadableDatabase()<strong>或</strong>getWritableDatabase()**方法可以用于创建和升级数据库</p></li><li><p>这两个方法会<strong>返回一个SQLiteDatabase对象</strong>，借助这个对象就可以<strong>对数据库进行增删查改操作</strong>。</p></li><li><p><strong>SQLiteDatabase</strong>提供了一个<strong>insert()</strong> 方法，这个方法就是专门用于<strong>添加数据</strong>，它接收3个参数：</p><ul><li>第一个参数：<strong>表名</strong>，要操作的表</li><li>第二个参数：<strong>null</strong>，在未指定添加数据的情况下给某些可以为空的列自动复制NULL</li><li>第三个参数：<strong>要添加的数据</strong>，它是一个<strong>ContentValues</strong>对象，提供一些列的<strong>put()方法</strong>重载来传入数据</li></ul><div class="highlight-container" data-rel="Kotlin"><figure class="iseeu highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 访问数据座，先实例化 MVDBHelper 的子类</span></span><br><span class="line"><span class="keyword">val</span> dbhelper = MyDBHelper(<span class="keyword">this</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以写入模式获取数据存储库</span></span><br><span class="line"><span class="keyword">val</span> db: SQLiteDatabase = dbhelper.getWritableDatabase()</span><br><span class="line"><span class="keyword">val</span> values = ContentValues()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入第一行数据</span></span><br><span class="line">values.put(<span class="string">&quot;author&quot;</span>，<span class="string">&quot;郭霖&quot;</span>)</span><br><span class="line">values.put(<span class="string">&#x27;name&#x27;</span>，<span class="string">&quot;第一行代码&quot;</span>)</span><br><span class="line">db.insert(<span class="string">&quot;Book&quot;</span>, <span class="literal">null</span>, values)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入其它数据前先清空</span></span><br><span class="line">values.clear()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入第二条数据</span></span><br><span class="line">values.put(<span class="string">&quot;author&quot;</span> <span class="string">&quot;张三&quot;</span>)</span><br><span class="line">values.put(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;I/FARI&quot;</span>)</span><br><span class="line">db.insert(<span class="string">&quot;Book&quot;</span>, <span class="literal">null</span>, values)</span><br></pre></td></tr></table></figure></div></li></ul><h4 id="查询数据">查询数据</h4><ul><li><p>SQLiteDatabase提供了query() 方法对数据进行查询，根据需要指定7个参数</p></li><li><p>调用query()方法后会返回一个<strong>Cursor对象</strong>，查询到得所有数据都将从这个对象中取出。</p><table><thead><tr><th style="text-align:center">query() 参数</th><th style="text-align:center">对应SQL部分</th></tr></thead><tbody><tr><td style="text-align:center">table</td><td style="text-align:center">from table_name</td></tr><tr><td style="text-align:center">columns</td><td style="text-align:center">select column1, column2</td></tr><tr><td style="text-align:center">selection</td><td style="text-align:center">where column = value</td></tr><tr><td style="text-align:center">selectionArgs</td><td style="text-align:center">(where中占位符的值)</td></tr><tr><td style="text-align:center">groupBy</td><td style="text-align:center">group by coulmn</td></tr><tr><td style="text-align:center">having</td><td style="text-align:center">having column = value</td></tr><tr><td style="text-align:center">orderBy</td><td style="text-align:center">order by column</td></tr></tbody></table></li></ul><div class="highlight-container" data-rel="Kotlin"><figure class="iseeu highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> dbhelper = MyDBHelper(<span class="keyword">this</span>)</span><br><span class="line"><span class="comment">// 以读取模式获取数据存储库</span></span><br><span class="line"><span class="keyword">val</span> db: SQLiteDatabase = dbhelper.getReadableDatabase()</span><br><span class="line"><span class="keyword">val</span> cursor = db.query(<span class="string">&quot;Book&quot;</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>)</span><br><span class="line"><span class="keyword">val</span> <span class="keyword">data</span> = StringBuilder()</span><br><span class="line"><span class="keyword">var</span> i = <span class="number">1</span></span><br><span class="line">with(cursor) &#123;</span><br><span class="line">    <span class="keyword">while</span> (moveToNext()) &#123;</span><br><span class="line">        <span class="keyword">val</span> author = getString(getColumnindexOrThrow(<span class="string">&quot;author&quot;</span>)</span><br><span class="line">        <span class="keyword">val</span> name = getString(getColumnIndexOrThrow(<span class="string">&quot;name&quot;</span>))</span><br><span class="line">        <span class="keyword">data</span>.append(<span class="string">&quot;第&quot;</span>+ i +<span class="string">&quot;行数据，author ：&quot;</span> + author + <span class="string">&quot;, name : &quot;</span> + name + <span class="string">&quot;\n\n&quot;</span>)</span><br><span class="line">        i++</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">cursor.close()</span><br></pre></td></tr></table></figure></div><h4 id="更新数据">更新数据</h4><ul><li><p>SQLiteDatabase提供了<strong>update()<strong>方法对数据进行</strong>更新</strong></p></li><li><p>这个方法接收4个参数：</p><ul><li>table：String ，要更新的<strong>表名</strong></li><li>values ： ContentValues，要更新的<strong>数据</strong></li><li>whereClause：String ，<strong>约束</strong>要更新哪行的数据</li><li>whereArgs：String[]，上一个参数中<strong>占位符的值</strong></li></ul><div class="highlight-container" data-rel="Kotlin"><figure class="iseeu highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> dbhelper = MyDBHelper(<span class="keyword">this</span>)</span><br><span class="line"><span class="comment">// 以写入模式获取数据存储库</span></span><br><span class="line"><span class="keyword">val</span> db: SQLiteDatabase = dbhelper.getWritableDatabase()</span><br><span class="line"><span class="keyword">val</span> values = ContentValues().apply&#123;</span><br><span class="line">put(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;第二行代码&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ?是一个占位符</span></span><br><span class="line"><span class="comment">// 第四个参数提供一个字符串数组，为第三个参数中的每个占位符指定相应的内容</span></span><br><span class="line">db.update(<span class="string">&quot;Book&quot;</span>, values, <span class="string">&quot;author = ?&quot;</span>, arrayOf(<span class="string">&quot;郭霖&quot;</span>))</span><br></pre></td></tr></table></figure></div></li></ul><h4 id="删除数据">删除数据</h4><ul><li><p><strong>SQLiteDatabase</strong>中提供了<strong>delete()<strong>方法</strong>删除</strong>数据</p></li><li><p>这个方法接收了个参数：</p><ul><li>table ：String，要更新的<strong>表名</strong></li><li>whereClause ：String，<strong>约束</strong>要删除哪行的数据</li><li>whereArgs :String[]，上一个参数中<strong>占位符的值</strong></li></ul><div class="highlight-container" data-rel="Kotlin"><figure class="iseeu highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以写入模式获取数据存储库</span></span><br><span class="line"><span class="keyword">val</span> db: SQLiteDatabase = dbhelper.getWritableDatabase0)</span><br><span class="line"><span class="comment">// ?是一个占位符</span></span><br><span class="line"><span class="comment">// 第四个参数提供一个字符串数组，为第三个参数中的每个占位符指定相应的内容</span></span><br><span class="line">db.delete(<span class="string">&quot;Book&quot;</span>,<span class="string">&quot;author = ?&quot;</span>,arrayOf(<span class="string">&quot;郭霖&quot;</span>))</span><br></pre></td></tr></table></figure></div></li></ul><h2 id="其他的存储方式">其他的存储方式</h2><img lazyload src="/images/loading.svg" data-src="/posts/2023-Summer-Courses-%E7%99%BE%E5%BA%A6%E7%A7%BB%E5%8A%A8%E7%AB%AF/2023baiduandroidlec5-lec6/image-20230729223825183.png" class title="image-20230729223825183"><h2 id="作业-2">作业</h2><img lazyload src="/images/loading.svg" data-src="/posts/2023-Summer-Courses-%E7%99%BE%E5%BA%A6%E7%A7%BB%E5%8A%A8%E7%AB%AF/2023baiduandroidlec5-lec6/image-20230729223940920.png" class title="image-20230729223940920"><blockquote><p>引申：</p><p>用户数据如何在不同设备之间共享？</p><p>其实是有个云服务器存储数据的</p></blockquote><h1>lec8-网络编程</h1><h1>lec9-</h1>]]></content>
      
      
      <categories>
          
          <category> 2023-Summer-Courses-百度移动端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 移动端开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Day5-APIGateway</title>
      <link href="/posts/2023-Summer-CloudWeGo/day5-apigateway.html"/>
      <url>/posts/2023-Summer-CloudWeGo/day5-apigateway.html</url>
      
        <content type="html"><![CDATA[<h2 id="正向-反向代理">正向/反向代理</h2><img lazyload src="/images/loading.svg" data-src="/posts/2023-Summer-CloudWeGo/day5-apigateway/image-20230714102358455.png" class title="image-20230714102358455"><img lazyload src="/images/loading.svg" data-src="/posts/2023-Summer-CloudWeGo/day5-apigateway/image-20230714102453866.png" class title="image-20230714102453866"><p>正向代理是客户端主动知道要找一个代理：VPN</p><p>反向代理是客户端并不知道，是服务端的一些代理：基本的服务网关如Nginx</p><h2 id="反向代理服务器就是服务网关，那-API-网关是什么？">反向代理服务器就是服务网关，那 API 网关是什么？</h2><img lazyload src="/images/loading.svg" data-src="/posts/2023-Summer-CloudWeGo/day5-apigateway/image-20230714103405605.png" class title="image-20230714103405605"><p>比如大门只控制学校的进出控制（流量网关，如nginx，其实还是不太一样，因为基本网关是有URL路由转发到不同服务器的），但是某个特定的事务处理，显然不能都交给流量网关，需要对于业务有特定的了解，相当于有了业务属性（业务网关，即API网关）</p><h2 id="反向代理-Nginx-基本功能">反向代理-Nginx-基本功能</h2><img lazyload src="/images/loading.svg" data-src="/posts/2023-Summer-CloudWeGo/day5-apigateway/image-20230714104026842.png" class title="image-20230714104026842"><h2 id="网关分类">网关分类</h2><img lazyload src="/images/loading.svg" data-src="/posts/2023-Summer-CloudWeGo/day5-apigateway/image-20230714104230191.png" class title="image-20230714104230191"><h2 id="API网关形态">API网关形态</h2><img lazyload src="/images/loading.svg" data-src="/posts/2023-Summer-CloudWeGo/day5-apigateway/image-20230714104757280.png" class title="image-20230714104757280"><p>可以把与服务端更耦合的流量分给Sidecar来处理</p>]]></content>
      
      
      <categories>
          
          <category> 2023-Summer-CloudWeGo </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Day4-服务发现与负载均衡</title>
      <link href="/posts/2023-Summer-Courses-CloudWeGo/day4-%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0%E4%B8%8E%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1.html"/>
      <url>/posts/2023-Summer-Courses-CloudWeGo/day4-%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0%E4%B8%8E%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1.html</url>
      
        <content type="html"><![CDATA[<h2 id="Day4-2-服务发现和负载均衡">Day4-2 服务发现和负载均衡</h2><h3 id="引入本地缓存">引入本地缓存</h3><p><img lazyload src="/images/loading.svg" data-src="Day4-ServiceDiscoveryAndLoadBalancing/image-20230713141618044.png" alt="image-20230713141618044"></p><p>解决了注册中心压力过大的问题</p><p>但是也带来了可能与注册中心对应数据不一致的问题</p><h3 id="etcd">etcd</h3><p><img lazyload src="/images/loading.svg" data-src="Day4-ServiceDiscoveryAndLoadBalancing/image-20230713141732362.png" alt="image-20230713141732362"></p><h4 id="使用">使用</h4><p>一个终端启动，另一个写和读</p><p><img lazyload src="/images/loading.svg" data-src="Day4-ServiceDiscoveryAndLoadBalancing/image-20230713143859890.png" alt="image-20230713143859890"></p><p><img lazyload src="/images/loading.svg" data-src="Day4-ServiceDiscoveryAndLoadBalancing/image-20230713144904773.png" alt="image-20230713144904773"></p><p>Server发起Put请求</p><p>Client会发一个Range请求给Server</p>]]></content>
      
      
      <categories>
          
          <category> 2023-Summer-Courses-CloudWeGo </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Day3-RPC</title>
      <link href="/posts/2023-Summer-Courses-CloudWeGo/day3-rpc.html"/>
      <url>/posts/2023-Summer-Courses-CloudWeGo/day3-rpc.html</url>
      
        <content type="html"><![CDATA[<h2 id="Day2-1">Day2-1</h2><h3 id="RPC的定义">RPC的定义</h3><p>From wiki:  远程过程调用是一个计算机通信协议。该协议允许运行于一台计算机的程序调用另一个地址空间（通常为一个开放网络的一台计算机）的子程序。</p><p>可以像调用本地方法一样调用远程方法。</p><p>解决跨进程间/远程通信问题。</p><h3 id="通信协议">通信协议</h3><h4 id="Thrift-一个FaceBook开发的框架">Thrift-一个FaceBook开发的框架</h4><img lazyload src="/images/loading.svg" data-src="/posts/2023-Summer-Courses-CloudWeGo/day3-rpc/image-20230712111928707.png" class title="image-20230712111928707"><h4 id="IDL">IDL</h4><p>跨语言，规范性，代码生成</p><img lazyload src="/images/loading.svg" data-src="/posts/2023-Summer-Courses-CloudWeGo/day3-rpc/image-20230712113858288.png" class title="image-20230712113858288"><h4 id="Thrift-IDL">Thrift IDL</h4><img lazyload src="/images/loading.svg" data-src="/posts/2023-Summer-Courses-CloudWeGo/day3-rpc/image-20230712114126789.png" class title="image-20230712114126789"><p>基本语法</p><img lazyload src="/images/loading.svg" data-src="/posts/2023-Summer-Courses-CloudWeGo/day3-rpc/image-20230712114436233.png" class title="image-20230712114436233"><p>Field Requiredness</p><p>optional required optional</p><img lazyload src="/images/loading.svg" data-src="/posts/2023-Summer-Courses-CloudWeGo/day3-rpc/image-20230712114634069.png" class title="image-20230712114634069"><p>default未赋值也会编码</p><h3 id="快速入门-ppt上的使用入门案例复现">快速入门-ppt上的使用入门案例复现</h3><p>第三步，生成服务端代码</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kitex -module github.com/SYuan03/Day3-kitex1 -service nju.dsy.kitex.demo1 ./idl/kitex_greet.thrift</span><br><span class="line">go mod tidy</span><br></pre></td></tr></table></figure></div><img lazyload src="/images/loading.svg" data-src="/posts/2023-Summer-Courses-CloudWeGo/day3-rpc/image-20230712155853571.png" class title="image-20230712155853571"><p>第四步，生成调用端代码</p><p>成功</p><img lazyload src="/images/loading.svg" data-src="/posts/2023-Summer-Courses-CloudWeGo/day3-rpc/image-20230712165547865.png" class title="image-20230712165547865"><img lazyload src="/images/loading.svg" data-src="/posts/2023-Summer-Courses-CloudWeGo/day3-rpc/image-20230712165558739.png" class title="image-20230712165558739"><h3 id="进阶特性-泛化调用">进阶特性-泛化调用</h3><h3 id="Day3-随堂练习">Day3-随堂练习</h3><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hz new -mod github.com/SYuan03/Day3/HertzServer -idl idl/student.thrift</span><br><span class="line">go mod tidy</span><br><span class="line"></span><br><span class="line">kitex -service kitex.demo -module github.go mod tidycom/SYuan03/Day3/KitexServer idl/student.thrift</span><br><span class="line">go mod tidy</span><br></pre></td></tr></table></figure></div><h4 id="Hertz-Server">Hertz-Server</h4><p>修改Kitex Server的main.go，配置监听端口，修改 main.go。（Kitex 与 Hertz 默认端口均是 8888，需要修改端口）</p><p>修改student.service，用client作一下转发</p><h4 id="Kitex-Server">Kitex-Server</h4><p>修改main.go</p><p>修改handler.go</p>]]></content>
      
      
      <categories>
          
          <category> 2023-Summer-Courses-CloudWeGo </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2023百度移动端lec2-lec4</title>
      <link href="/posts/2023-Summer-Courses-%E7%99%BE%E5%BA%A6%E7%A7%BB%E5%8A%A8%E7%AB%AF/2023%E7%99%BE%E5%BA%A6%E7%A7%BB%E5%8A%A8%E7%AB%AFlec2-lec4.html"/>
      <url>/posts/2023-Summer-Courses-%E7%99%BE%E5%BA%A6%E7%A7%BB%E5%8A%A8%E7%AB%AF/2023%E7%99%BE%E5%BA%A6%E7%A7%BB%E5%8A%A8%E7%AB%AFlec2-lec4.html</url>
      
        <content type="html"><![CDATA[<h1>Day 7.11-第二讲</h1><blockquote><p>大作业UI示意稿：见Gitee平台-UI_Resources<br>7.11-7.13课程中的Demo工程：见Gitee平台-UI Lesson Demo</p></blockquote><h3 id="运行环境搭建">运行环境搭建</h3><p>AndroidStudio</p><h3 id="Kotlin语言简介">Kotlin语言简介</h3><img lazyload src="/images/loading.svg" data-src="/posts/2023-Summer-Courses-%E7%99%BE%E5%BA%A6%E7%A7%BB%E5%8A%A8%E7%AB%AF/2023%E7%99%BE%E5%BA%A6%E7%A7%BB%E5%8A%A8%E7%AB%AFlec2-lec4/image-20230712115616707.png" class title="image-20230712115616707"><h3 id="文件结构介绍">文件结构介绍</h3><img lazyload src="/images/loading.svg" data-src="/posts/2023-Summer-Courses-%E7%99%BE%E5%BA%A6%E7%A7%BB%E5%8A%A8%E7%AB%AF/2023%E7%99%BE%E5%BA%A6%E7%A7%BB%E5%8A%A8%E7%AB%AFlec2-lec4/image-20230712143119713.png" class title="image-20230712143119713"><h3 id="运行">运行</h3><p>跟平板练了下</p><p>跑了整整6m40s额</p><img lazyload src="/images/loading.svg" data-src="/posts/2023-Summer-Courses-%E7%99%BE%E5%BA%A6%E7%A7%BB%E5%8A%A8%E7%AB%AF/2023%E7%99%BE%E5%BA%A6%E7%A7%BB%E5%8A%A8%E7%AB%AFlec2-lec4/image-20230713131321745.png" class title="image-20230713131321745"><h3 id="日志logcat">日志logcat</h3><img lazyload src="/images/loading.svg" data-src="/posts/2023-Summer-Courses-%E7%99%BE%E5%BA%A6%E7%A7%BB%E5%8A%A8%E7%AB%AF/2023%E7%99%BE%E5%BA%A6%E7%A7%BB%E5%8A%A8%E7%AB%AFlec2-lec4/image-20230713132025681.png" class title="image-20230713132025681"><p>退到后台显示onPause</p><p>再回去就onResume</p><p>现在的过滤器方式已经改变了</p><blockquote><p>参考<a class="link" href="https://blog.csdn.net/baoolong/article/details/127572422">Android Studio2022年10月更新Logcat配置过滤_android studio logcat 过滤_baoolong的博客-CSDN博客 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p></blockquote><p>可以这样写，与老师上课所讲基本相当</p><img lazyload src="/images/loading.svg" data-src="/posts/2023-Summer-Courses-%E7%99%BE%E5%BA%A6%E7%A7%BB%E5%8A%A8%E7%AB%AF/2023%E7%99%BE%E5%BA%A6%E7%A7%BB%E5%8A%A8%E7%AB%AFlec2-lec4/image-20230713132403278.png" class title="image-20230713132403278"><h3 id="APK包组成">APK包组成</h3><img lazyload src="/images/loading.svg" data-src="/posts/2023-Summer-Courses-%E7%99%BE%E5%BA%A6%E7%A7%BB%E5%8A%A8%E7%AB%AF/2023%E7%99%BE%E5%BA%A6%E7%A7%BB%E5%8A%A8%E7%AB%AFlec2-lec4/image-20230713132800152.png" class title="image-20230713132800152"><p>两个资源文件一个是运行时参与编译，一个就是单纯的素材存储</p><p>渠道信息：比如小米应用商店，谷歌商店等信息</p><h3 id="APK包构建过程">APK包构建过程</h3><img lazyload src="/images/loading.svg" data-src="/posts/2023-Summer-Courses-%E7%99%BE%E5%BA%A6%E7%A7%BB%E5%8A%A8%E7%AB%AF/2023%E7%99%BE%E5%BA%A6%E7%A7%BB%E5%8A%A8%E7%AB%AFlec2-lec4/image-20230713133050648.png" class title="image-20230713133050648"><h3 id="Design-Code">Design&amp;&amp;Code</h3><p>一般不直接使用Design的方式</p><p>拖拽的方式不太精准</p><img lazyload src="/images/loading.svg" data-src="/posts/2023-Summer-Courses-%E7%99%BE%E5%BA%A6%E7%A7%BB%E5%8A%A8%E7%AB%AF/2023%E7%99%BE%E5%BA%A6%E7%A7%BB%E5%8A%A8%E7%AB%AFlec2-lec4/image-20230713133855953.png" class title="image-20230713133855953"><h1>Day 7.12-第三讲-UI开发初探</h1><img lazyload src="/images/loading.svg" data-src="/posts/2023-Summer-Courses-%E7%99%BE%E5%BA%A6%E7%A7%BB%E5%8A%A8%E7%AB%AF/2023%E7%99%BE%E5%BA%A6%E7%A7%BB%E5%8A%A8%E7%AB%AFlec2-lec4/image-20230714091741502.png" class title="image-20230714091741502"> <blockquote><p>图标： <a class="link" href="https://icons8.com/icons/material">https://icons8.com/icons/material <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a><br>主题：<a class="link" href="https://m3.material.io/theme-builder#/custom">https://m3.material.io/theme-builder#/custom <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p></blockquote><h2 id="View组件">View组件</h2><img lazyload src="/images/loading.svg" data-src="/posts/2023-Summer-Courses-%E7%99%BE%E5%BA%A6%E7%A7%BB%E5%8A%A8%E7%AB%AF/2023%E7%99%BE%E5%BA%A6%E7%A7%BB%E5%8A%A8%E7%AB%AFlec2-lec4/image-20230714092151466.png" class title="image-20230714092151466"><h3 id></h3><h3 id="View的属性">View的属性</h3><img lazyload src="/images/loading.svg" data-src="/posts/2023-Summer-Courses-%E7%99%BE%E5%BA%A6%E7%A7%BB%E5%8A%A8%E7%AB%AF/2023%E7%99%BE%E5%BA%A6%E7%A7%BB%E5%8A%A8%E7%AB%AFlec2-lec4/image-20230714092427546.png" class title="image-20230714092427546"><h3 id="ViewGroup">ViewGroup</h3><img lazyload src="/images/loading.svg" data-src="/posts/2023-Summer-Courses-%E7%99%BE%E5%BA%A6%E7%A7%BB%E5%8A%A8%E7%AB%AF/2023%E7%99%BE%E5%BA%A6%E7%A7%BB%E5%8A%A8%E7%AB%AFlec2-lec4/image-20230714092805440.png" class title="image-20230714092805440"><img lazyload src="/images/loading.svg" data-src="/posts/2023-Summer-Courses-%E7%99%BE%E5%BA%A6%E7%A7%BB%E5%8A%A8%E7%AB%AF/2023%E7%99%BE%E5%BA%A6%E7%A7%BB%E5%8A%A8%E7%AB%AFlec2-lec4/image-20230714092843215.png" class title="image-20230714092843215"><p>例子</p><img lazyload src="/images/loading.svg" data-src="/posts/2023-Summer-Courses-%E7%99%BE%E5%BA%A6%E7%A7%BB%E5%8A%A8%E7%AB%AF/2023%E7%99%BE%E5%BA%A6%E7%A7%BB%E5%8A%A8%E7%AB%AFlec2-lec4/image-20230714092921275.png" class title="image-20230714092921275"><h2 id="常见的布局">常见的布局</h2><img lazyload src="/images/loading.svg" data-src="/posts/2023-Summer-Courses-%E7%99%BE%E5%BA%A6%E7%A7%BB%E5%8A%A8%E7%AB%AF/2023%E7%99%BE%E5%BA%A6%E7%A7%BB%E5%8A%A8%E7%AB%AFlec2-lec4/image-20230714093011204.png" class title="image-20230714093011204"><p>RelativeLayout相对用的比较少了</p><h3 id="LinearLayout">LinearLayout</h3><img lazyload src="/images/loading.svg" data-src="/posts/2023-Summer-Courses-%E7%99%BE%E5%BA%A6%E7%A7%BB%E5%8A%A8%E7%AB%AF/2023%E7%99%BE%E5%BA%A6%E7%A7%BB%E5%8A%A8%E7%AB%AFlec2-lec4/image-20230714093159275.png" class title="image-20230714093159275"><h3 id="LinearLayout例子">LinearLayout例子</h3><p>关于weight和layout_width和layout_height：理解是如果使用weight来分配，最好把对应的就设为0dp，如果不设置为0，可能是按比例分配后再增加</p><p>当然也可以抛弃weight，直接就单纯使用数值dp为单位</p><img lazyload src="/images/loading.svg" data-src="/posts/2023-Summer-Courses-%E7%99%BE%E5%BA%A6%E7%A7%BB%E5%8A%A8%E7%AB%AF/2023%E7%99%BE%E5%BA%A6%E7%A7%BB%E5%8A%A8%E7%AB%AFlec2-lec4/image-20230714234028176.png" class title="image-20230714234028176"> <p>可以让内部的TextView居中</p><h3 id="FrameLayout">FrameLayout</h3><img lazyload src="/images/loading.svg" data-src="/posts/2023-Summer-Courses-%E7%99%BE%E5%BA%A6%E7%A7%BB%E5%8A%A8%E7%AB%AF/2023%E7%99%BE%E5%BA%A6%E7%A7%BB%E5%8A%A8%E7%AB%AFlec2-lec4/image-20230718151135107.png" class title="image-20230718151135107"><p>左上角为原点，堆叠</p><p><strong>堆叠顺序</strong></p><img lazyload src="/images/loading.svg" data-src="/posts/2023-Summer-Courses-%E7%99%BE%E5%BA%A6%E7%A7%BB%E5%8A%A8%E7%AB%AF/2023%E7%99%BE%E5%BA%A6%E7%A7%BB%E5%8A%A8%E7%AB%AFlec2-lec4/image-20230718152043186.png" class title="image-20230718152043186"><p><strong>wrap_content</strong></p><ol><li><code>android:layout_width</code>：这个属性指定了视图的宽度。它可以采用不同的值，包括：<ul><li><code>&quot;wrap_content&quot;</code>：视图的宽度将根据其内容自适应。换句话说，视图的宽度将根据其内容的尺寸来确定。</li></ul></li><li><code>android:layout_height</code>：这个属性指定了视图的高度。它可以采用不同的值，包括：<ul><li><code>&quot;wrap_content&quot;</code>：视图的高度将根据其内容自适应。换句话说，视图的高度将根据其内容的尺寸来确定。</li></ul></li></ol><h3 id="FrameLayout-2">FrameLayout</h3><img lazyload src="/images/loading.svg" data-src="/posts/2023-Summer-Courses-%E7%99%BE%E5%BA%A6%E7%A7%BB%E5%8A%A8%E7%AB%AF/2023%E7%99%BE%E5%BA%A6%E7%A7%BB%E5%8A%A8%E7%AB%AFlec2-lec4/image-20230718154131995.png" class title="image-20230718154131995"><img lazyload src="/images/loading.svg" data-src="/posts/2023-Summer-Courses-%E7%99%BE%E5%BA%A6%E7%A7%BB%E5%8A%A8%E7%AB%AF/2023%E7%99%BE%E5%BA%A6%E7%A7%BB%E5%8A%A8%E7%AB%AFlec2-lec4/image-20230718154606335.png" class title="image-20230718154606335"><blockquote><ul><li><p>bias: 偏差，对相对位置进行调整，通常<strong>设置0到1之间的值</strong>，可以改变组件在水平或垂直方向上的偏移。如，<strong>水平</strong>偏差<strong>设置为0</strong>时候，组件靠近<strong>左侧</strong>约束，而<strong>设置为1</strong>时，组件靠近<strong>右侧</strong>约束</p></li><li><p>chains: 链，链的作用是在水平或垂直方向上分配组件的控件。可以设置链的样式，“spread”(均匀分布空间)、“spread_inside”(在组件内部均匀分布空间)、和&quot;packed&quot;(将组件紧密相连)</p><p><strong>spread</strong> 和<strong>spread_inside</strong> 的区别，以三个控件举例，<strong>spread</strong> 的第二个控件在中间，第一个和第三个则分别分布在左右<strong>剩余区域的中间位置</strong>，而<strong>spread_inside</strong> 的第二个控件在中间，第一个和第三个控件则分别<strong>紧贴父容器的左右两侧</strong></p></li><li><p>dimension ratio: 尺寸比例，设置组件的<strong>宽度与高度之间的比例</strong>。</p></li></ul></blockquote><h3 id="bias">bias</h3><img lazyload src="/images/loading.svg" data-src="/posts/2023-Summer-Courses-%E7%99%BE%E5%BA%A6%E7%A7%BB%E5%8A%A8%E7%AB%AF/2023%E7%99%BE%E5%BA%A6%E7%A7%BB%E5%8A%A8%E7%AB%AFlec2-lec4/image-20230718160008721.png" class title="image-20230718160008721"><p>相对位置进行调整</p><blockquote><p>为什么要用四个parent?，不直接center?</p><img lazyload src="/images/loading.svg" data-src="/posts/2023-Summer-Courses-%E7%99%BE%E5%BA%A6%E7%A7%BB%E5%8A%A8%E7%AB%AF/2023%E7%99%BE%E5%BA%A6%E7%A7%BB%E5%8A%A8%E7%AB%AFlec2-lec4/image-20230718160548915.png" class title="image-20230718160548915"><p>感觉是这种布局没gravity的概念，也许只能在linearlayout或者framelayout用，而且bias也用不了，只能像上面注释掉的这么用</p></blockquote><h3 id="chains">chains</h3><p>“spread”(均匀分布空间)、“spread_inside”(在组件内部均匀分布空间)、和&quot;packed&quot;(将组件紧密相连)</p><h3 id="DimensionRatio">DimensionRatio</h3><p>指定height或者width，另一个指定为0，通过ration确定另一个</p><h3 id="常用控件">常用控件</h3><p>常用控件：</p><table><thead><tr><th style="text-align:center">控件名称</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">TextView</td><td style="text-align:center">文本显示控件</td></tr><tr><td style="text-align:center">Button</td><td style="text-align:center">按钮控件</td></tr><tr><td style="text-align:center">EditText</td><td style="text-align:center">文本编辑框控件</td></tr><tr><td style="text-align:center">ImageView</td><td style="text-align:center">图片显示控件</td></tr><tr><td style="text-align:center">ImageButton</td><td style="text-align:center">图片作为按钮的控件</td></tr><tr><td style="text-align:center">RadioGroup</td><td style="text-align:center">单选按钮控件</td></tr><tr><td style="text-align:center">CheckBox</td><td style="text-align:center">复选框控件</td></tr><tr><td style="text-align:center">Spiner</td><td style="text-align:center">下拉列表控件</td></tr><tr><td style="text-align:center">SeekBar</td><td style="text-align:center">拖动条控件</td></tr><tr><td style="text-align:center">ProgressBar</td><td style="text-align:center">进度条控件</td></tr><tr><td style="text-align:center">ScrollView</td><td style="text-align:center">可滚动视图控件</td></tr><tr><td style="text-align:center">DatePicker</td><td style="text-align:center">日期显示控件</td></tr><tr><td style="text-align:center">TimePicker</td><td style="text-align:center">事件显示控件</td></tr><tr><td style="text-align:center">Dialog</td><td style="text-align:center">对话框控件</td></tr><tr><td style="text-align:center">Toast</td><td style="text-align:center">信息提示框控件</td></tr></tbody></table><p>属性需要的时候在网上搜就好了</p><h2 id="Context">Context</h2><p>简单了解</p><img lazyload src="/images/loading.svg" data-src="/posts/2023-Summer-Courses-%E7%99%BE%E5%BA%A6%E7%A7%BB%E5%8A%A8%E7%AB%AF/2023%E7%99%BE%E5%BA%A6%E7%A7%BB%E5%8A%A8%E7%AB%AFlec2-lec4/image-20230718171905870.png" class title="image-20230718171905870"><h2 id="布局管理器">布局管理器</h2><img lazyload src="/images/loading.svg" data-src="/posts/2023-Summer-Courses-%E7%99%BE%E5%BA%A6%E7%A7%BB%E5%8A%A8%E7%AB%AF/2023%E7%99%BE%E5%BA%A6%E7%A7%BB%E5%8A%A8%E7%AB%AFlec2-lec4/image-20230718173117187.png" class title="image-20230718173117187"><img lazyload src="/images/loading.svg" data-src="/posts/2023-Summer-Courses-%E7%99%BE%E5%BA%A6%E7%A7%BB%E5%8A%A8%E7%AB%AF/2023%E7%99%BE%E5%BA%A6%E7%A7%BB%E5%8A%A8%E7%AB%AFlec2-lec4/image-20230718173146005.png" class title="image-20230718173146005"><h2 id="实践">实践</h2><img lazyload src="/images/loading.svg" data-src="/posts/2023-Summer-Courses-%E7%99%BE%E5%BA%A6%E7%A7%BB%E5%8A%A8%E7%AB%AF/2023%E7%99%BE%E5%BA%A6%E7%A7%BB%E5%8A%A8%E7%AB%AFlec2-lec4/image-20230718174203032.png" class title="image-20230718174203032"><p>先连接箭头对齐（或者说贴紧）</p><p>再调整右侧属性控制偏移量</p><h3 id="方法一：设置onClick属性">方法一：设置onClick属性</h3><p>有报红，但能跑。</p><img lazyload src="/images/loading.svg" data-src="/posts/2023-Summer-Courses-%E7%99%BE%E5%BA%A6%E7%A7%BB%E5%8A%A8%E7%AB%AF/2023%E7%99%BE%E5%BA%A6%E7%A7%BB%E5%8A%A8%E7%AB%AFlec2-lec4/image-20230719133121193.png" class title="image-20230719133121193"><h3 id="方法二：使用代码的方法">方法二：使用代码的方法</h3><p>见代码LessonThreeActivity</p><h2 id="随堂练习">随堂练习</h2><img lazyload src="/images/loading.svg" data-src="/posts/2023-Summer-Courses-%E7%99%BE%E5%BA%A6%E7%A7%BB%E5%8A%A8%E7%AB%AF/2023%E7%99%BE%E5%BA%A6%E7%A7%BB%E5%8A%A8%E7%AB%AFlec2-lec4/image-20230720103536788.png" class title="image-20230720103536788"><h1>Day 7.13-第四讲-UI开发详解</h1><blockquote><p>动画模拟的网站<a class="link" href="http://inloop.github.io/interpolator/">http://inloop.github.io/interpolator/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p></blockquote><h2 id="TextView">TextView</h2><h3 id="简单介绍">简单介绍</h3><img lazyload src="/images/loading.svg" data-src="/posts/2023-Summer-Courses-%E7%99%BE%E5%BA%A6%E7%A7%BB%E5%8A%A8%E7%AB%AF/2023%E7%99%BE%E5%BA%A6%E7%A7%BB%E5%8A%A8%E7%AB%AFlec2-lec4/image-20230720173427188.png" class title="image-20230720173427188"><h3 id="常用属性">常用属性</h3><img lazyload src="/images/loading.svg" data-src="/posts/2023-Summer-Courses-%E7%99%BE%E5%BA%A6%E7%A7%BB%E5%8A%A8%E7%AB%AF/2023%E7%99%BE%E5%BA%A6%E7%A7%BB%E5%8A%A8%E7%AB%AFlec2-lec4/image-20230720173612196.png" class title="image-20230720173612196"><blockquote><p>省略方式: <code>...</code>出现的位置可控</p></blockquote><h3 id="Autolink">Autolink</h3><img lazyload src="/images/loading.svg" data-src="/posts/2023-Summer-Courses-%E7%99%BE%E5%BA%A6%E7%A7%BB%E5%8A%A8%E7%AB%AF/2023%E7%99%BE%E5%BA%A6%E7%A7%BB%E5%8A%A8%E7%AB%AFlec2-lec4/image-20230720174105895.png" class title="image-20230720174105895"><img lazyload src="/images/loading.svg" data-src="/posts/2023-Summer-Courses-%E7%99%BE%E5%BA%A6%E7%A7%BB%E5%8A%A8%E7%AB%AF/2023%E7%99%BE%E5%BA%A6%E7%A7%BB%E5%8A%A8%E7%AB%AFlec2-lec4/image-20230720194540007.png" class title="image-20230720194540007"><blockquote><p>基本用不到</p></blockquote><h3 id="Spannable：处理文本样式">Spannable：处理文本样式</h3><img lazyload src="/images/loading.svg" data-src="/posts/2023-Summer-Courses-%E7%99%BE%E5%BA%A6%E7%A7%BB%E5%8A%A8%E7%AB%AF/2023%E7%99%BE%E5%BA%A6%E7%A7%BB%E5%8A%A8%E7%AB%AFlec2-lec4/image-20230720194743039.png" class title="image-20230720194743039"><p>代码实现：</p><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">SpannableString</span> <span class="variable">span</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Spannablestring</span>(<span class="string">&quot;红色打电话斜体删除线绿色下划线图片：.&quot;</span>)；</span><br><span class="line"><span class="comment">//1.设置背景色，setspan时需要指定的flag,Spanned .SPAN_EXCLUSIVE_EXCLUSIVE(前后都不包括）</span></span><br><span class="line">span.setspan(<span class="keyword">new</span> <span class="title class_">Foregroundcolorspan</span>(Color.RED)， <span class="number">0</span>, <span class="number">2</span>, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);</span><br><span class="line"><span class="comment">//2.用超链接标记文本</span></span><br><span class="line">span.setSpan (<span class="keyword">new</span> <span class="title class_">URLSpan</span>(<span class="string">&quot;tel: 4155551212&quot;</span>), <span class="number">2</span>, <span class="number">5</span>, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);</span><br><span class="line"><span class="comment">//3.用样式标记文本（斜体）</span></span><br><span class="line">span.setSpan (<span class="keyword">new</span> <span class="title class_">StyleSpan</span>(Typeface.BOLD_ITALIC), <span class="number">5</span>, <span class="number">7</span>, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);</span><br><span class="line"><span class="comment">//4.用删除线标记文本</span></span><br><span class="line">span.setSpan (<span class="keyword">new</span> <span class="title class_">StrikethroughSpan</span>(), <span class="number">7</span>, <span class="number">10</span>, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);</span><br><span class="line"><span class="comment">//5. 用下划线标记文本</span></span><br><span class="line">span.setSpan (<span class="keyword">new</span> <span class="title class_">UnderlineSpan</span>(), <span class="number">10</span>, <span class="number">16</span>, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE) ;</span><br><span class="line"><span class="comment">//6. 用颜色标记</span></span><br><span class="line">span.setSpan (<span class="keyword">new</span> <span class="title class_">ForegroundColorSpan</span>(Color. GREEN), <span class="number">10</span>, <span class="number">13</span>, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);</span><br><span class="line"><span class="comment">//7.1/获取Drawable资源</span></span><br><span class="line"><span class="type">Drawable</span> <span class="variable">d</span> <span class="operator">=</span> getResources().getDrawable(R.drawable.icon);</span><br><span class="line">d.setBounds(<span class="number">0</span>, <span class="number">0</span>, d.getIntrinsicWidth(), d.getIntrinsicHeight ());</span><br><span class="line"><span class="comment">//8.创建Imagespan,然后用Imagespan来替换文本</span></span><br><span class="line"><span class="type">ImageSpan</span> <span class="variable">imgspan</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ImageSpan</span>(d, ImageSpan. ALIGN_BASELINE);</span><br><span class="line">span.setSpan(imgspan, <span class="number">18</span>, <span class="number">19</span>, Spannable.SPAN_INCLUSIVE_EXCLUSIVE);</span><br><span class="line">ti.setText(span);</span><br></pre></td></tr></table></figure></div><h2 id="RecycleView：可滑动的列表UI组件">RecycleView：可滑动的列表UI组件</h2><img lazyload src="/images/loading.svg" data-src="/posts/2023-Summer-Courses-%E7%99%BE%E5%BA%A6%E7%A7%BB%E5%8A%A8%E7%AB%AF/2023%E7%99%BE%E5%BA%A6%E7%A7%BB%E5%8A%A8%E7%AB%AFlec2-lec4/image-20230720194951539.png" class title="image-20230720194951539"><h3 id="基本组成">基本组成</h3><ul><li><p>Data：数据，需要展示的内容</p></li><li><p>RecycleView：一个可滑动的列表View</p></li><li><p>Layout：XML文件</p><blockquote><p>布局（Layout）：布局是指定义RecyclerView中每个项目的外观和结构的XML文件。它定义了表示列表中单个项目的视图的布局。</p></blockquote></li><li><p>Layout manager：负责处理View 的UI组件</p><ul><li>每个ViewGroup 都有一个LayoutManager</li><li>用于排列展示RecycleView 中的每一个item</li><li><strong>回收/复用</strong> 离开屏幕对于用户不可见的item</li><li>内置的布局管理器：<ul><li>LinearLayoutManager(线性)</li><li>GridLayoutManager(网格)</li><li>StaggeredGridLayoutManager(瀑布流)</li></ul></li><li>可以自定义，继承：RecycleView.LayoutManager</li></ul></li><li><p>Adapter：将数据和RecycleView进行<strong>关联</strong></p><ul><li><p>负责提供数据和<strong>创建列表项(Item) 视图</strong>。</p><ul><li>比如：从数据中读取string, 将文字设置到item的view上</li></ul></li><li><p>数据和视图的媒介</p></li><li><p>当数据发生变化时，管理数据的创建、更新、添加、删除</p></li><li><p>RecyclerView.Adapter</p><blockquote><p>适配器充当数据和RecyclerView之间的桥梁。它负责为数据集中的每个项目创建和管理视图。它为每个项目视图创建视图持有者（ViewHolder），以便在用户滚动列表时高效地重用视图。</p><p>适配器对于处理数据的变化、更新、添加和删除非常重要。它在数据集发生变化时通知RecyclerView，以便RecyclerView相应地更新显示。</p></blockquote></li></ul></li><li><p>Viewholder：持有显示1个item的视图信息</p><ul><li><strong>负责保存列表项视图的引用，以便在需要时快速访问视图</strong></li><li>Layout在xml文件中进行声明</li><li>可以包含可以点击的元素</li><li>由LayoutManager进行摆放</li></ul></li></ul><h3 id="使用步骤">使用步骤</h3><ol><li><p>添加RecycleV的依赖到build.gradle文件中。</p><div class="highlight-container" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dependencies&#123;</span><br><span class="line">...</span><br><span class="line">compile &#x27;com.android.support:recyclerview-v7:26.1.0&#x27;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li><li><p>Layout在xml文件中进行声明</p><div class="highlight-container" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">androidx.recyclerview.widget.RecyclerView</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">&quot;@+id/rv_demo&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    /&gt;</span></span><br></pre></td></tr></table></figure></div></li><li><p>为每一个Item创建xml布局</p><p>recycleview_item2.xml文件</p><p>定义了其中的一行</p><img lazyload src="/images/loading.svg" data-src="/posts/2023-Summer-Courses-%E7%99%BE%E5%BA%A6%E7%A7%BB%E5%8A%A8%E7%AB%AF/2023%E7%99%BE%E5%BA%A6%E7%A7%BB%E5%8A%A8%E7%AB%AFlec2-lec4/image-20230723153626924.png" class title="image-20230723153626924"></li><li><p>继承RecyclerView.Adapter<br>三个必须实现的方法：<br>onCreateViewHolder()表示布局需要创建的viewHolder是哪个</p><p>inBindViewHolder()表示在绑定的时候如何去设置文案</p><p>getItemCount()表示这个列表的大小是多少</p><div class="highlight-container" data-rel="Kotlin"><figure class="iseeu highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DemoAdapter</span> : <span class="type">RecyclerView.Adapter</span>&lt;<span class="type">DemoViewHolder</span>&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 保存数据的列表 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> demoList: List&lt;ItemBean&gt;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>(demoList: List&lt;ItemBean&gt;) &#123;</span><br><span class="line">        <span class="keyword">this</span>.demoList = demoList</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreateViewHolder</span><span class="params">(parent: <span class="type">ViewGroup</span>, viewType: <span class="type">Int</span>)</span></span>: DemoViewHolder &#123;</span><br><span class="line">        <span class="keyword">val</span> view: View =</span><br><span class="line">            LayoutInflater.from(parent.context).inflate(R.layout.recycleview_item, parent, <span class="literal">false</span>)</span><br><span class="line">        <span class="keyword">return</span> DemoViewHolder(view)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onBindViewHolder</span><span class="params">(holder: <span class="type">DemoViewHolder</span>, position: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> itemBean = demoList[position]</span><br><span class="line"></span><br><span class="line">        itemBean.coverUrl?.let &#123;</span><br><span class="line">            holder.ivCover?.setImageResource(it)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        itemBean.title?.let &#123;</span><br><span class="line">            holder.tvTitle.text = it</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        itemBean.content?.let &#123;</span><br><span class="line">            holder.tvContent.text = it</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getItemCount</span><span class="params">()</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> demoList.size</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li><li><p>继承RecyclerView.ViewHolder(看实例代码的DemoViewHolder <strong>每个属性对应单个item的属性</strong>)</p></li><li><p>在Activity的onCreate()中，获取RecycleView，并且为它设置Adapter和LayoutParams</p><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 找到获取RecyclerView</span></span><br><span class="line">mRecyclerView = findViewById(R.id.recyclerview);</span><br><span class="line"><span class="comment">// 2. new一个adapter,第二个参数为构造的数据</span></span><br><span class="line">mAdapter = <span class="keyword">new</span> <span class="title class_">WordListAdapter</span>(<span class="built_in">this</span>, mWordList);</span><br><span class="line"><span class="comment">// 3. 创建的adapter设置给RecyclerView</span></span><br><span class="line">mRecyclerView.setAdapter(mAdapter);</span><br><span class="line"><span class="comment">// 4. 设置LayoutManager</span></span><br><span class="line">mRecyclerView.setLayoutManager(<span class="keyword">new</span> <span class="title class_">LinearLayoutManager</span>(<span class="built_in">this</span>));</span><br></pre></td></tr></table></figure></div></li></ol><h3 id="ellipsize和maxLines">ellipsize和maxLines</h3><img lazyload src="/images/loading.svg" data-src="/posts/2023-Summer-Courses-%E7%99%BE%E5%BA%A6%E7%A7%BB%E5%8A%A8%E7%AB%AF/2023%E7%99%BE%E5%BA%A6%E7%A7%BB%E5%8A%A8%E7%AB%AFlec2-lec4/image-20230723181501426.png" class title="image-20230723181501426"><p>控制<code>...</code>出现的位置</p><h3 id="短文字也能居中的方法">短文字也能居中的方法</h3><img lazyload src="/images/loading.svg" data-src="/posts/2023-Summer-Courses-%E7%99%BE%E5%BA%A6%E7%A7%BB%E5%8A%A8%E7%AB%AF/2023%E7%99%BE%E5%BA%A6%E7%A7%BB%E5%8A%A8%E7%AB%AFlec2-lec4/image-20230723182251984.png" class title="image-20230723182251984"><p>将demo的wrap_content改成match_parent</p><h2 id="动画">动画</h2><img lazyload src="/images/loading.svg" data-src="/posts/2023-Summer-Courses-%E7%99%BE%E5%BA%A6%E7%A7%BB%E5%8A%A8%E7%AB%AF/2023%E7%99%BE%E5%BA%A6%E7%A7%BB%E5%8A%A8%E7%AB%AFlec2-lec4/image-20230723211715910.png" class title="image-20230723211715910"><h3 id="帧动画">帧动画</h3><img lazyload src="/images/loading.svg" data-src="/posts/2023-Summer-Courses-%E7%99%BE%E5%BA%A6%E7%A7%BB%E5%8A%A8%E7%AB%AF/2023%E7%99%BE%E5%BA%A6%E7%A7%BB%E5%8A%A8%E7%AB%AFlec2-lec4/image-20230723212513538.png" class title="image-20230723212513538"><p>1.在XML中创建帧动画(frame_anim.xml)</p><blockquote><p>oneshot属性控制是否循环播放</p></blockquote><div class="highlight-container" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">animation-list</span> <span class="attr">mins:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span> <span class="attr">android:oneshot</span>=<span class="string">&quot;false&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">android:</span> <span class="attr">drawable</span>=<span class="string">&quot;@drawable/framel&quot;</span> <span class="attr">android:duration</span>=<span class="string">&quot;200&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">android:drawable</span>=<span class="string">&quot;@drawable/frame2&quot;</span> <span class="attr">android:duration</span>=<span class="string">&quot;200&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">android:</span> <span class="attr">drawable</span>=<span class="string">&quot;@drawable/frame3&quot;</span> <span class="attr">android:duration</span>=<span class="string">&quot;200&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">animation-list</span>&gt;</span></span><br></pre></td></tr></table></figure></div><p>2.将动画设置给指定的View</p><div class="highlight-container" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ImageView</span></span></span><br><span class="line"><span class="tag">           <span class="attr">android:id</span>=<span class="string">&quot;@+id/imageView&quot;</span></span></span><br><span class="line"><span class="tag">           <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">           <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">           <span class="attr">android:src</span>=<span class="string">&quot;@drawable/frame_anim&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure></div><p>3.通过代码控制播放</p><div class="highlight-container" data-rel="Kotlin"><figure class="iseeu highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java</span></span><br><span class="line">ImageView imageView = findViewById(R.id.imageView);</span><br><span class="line">imageView.setBackgroundResource(R.drawable.frame animation);</span><br><span class="line">AnimationDrawable animationDrawable = (AnimationDrawable) imageView.getBackground()</span><br><span class="line">animationDrawable.start();</span><br><span class="line"></span><br><span class="line"><span class="comment">// kotlin</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">showFrameAnimLoading</span><span class="params">()</span></span> &#123;</span><br><span class="line">    frameAnimLoading = findViewById(R.id.iv_loading)</span><br><span class="line">    (frameAnimLoading?.background <span class="keyword">as</span>? AnimationDrawable)?.start()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="补间动画">补间动画</h3><img lazyload src="/images/loading.svg" data-src="/posts/2023-Summer-Courses-%E7%99%BE%E5%BA%A6%E7%A7%BB%E5%8A%A8%E7%AB%AF/2023%E7%99%BE%E5%BA%A6%E7%A7%BB%E5%8A%A8%E7%AB%AFlec2-lec4/image-20230723214214546.png" class title="image-20230723214214546"><p>平移动画</p><div class="highlight-container" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">translate</span> <span class="attr">mIns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">           <span class="attr">android:fromXDelta</span>=<span class="string">&quot;0&quot;</span></span></span><br><span class="line"><span class="tag">           <span class="attr">android:toXDelta</span>=<span class="string">&quot;100&quot;</span></span></span><br><span class="line"><span class="tag">           <span class="attr">android:duration</span>=<span class="string">&quot;1000&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure></div><p>缩放动画</p><div class="highlight-container" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">scale</span> <span class="attr">mIns:</span> <span class="attr">android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:fromXScale</span>=<span class="string">&quot;1&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:toXScale</span>=<span class="string">&quot;2&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:fromYScale</span>=<span class="string">&quot;1&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:toYScale</span>=<span class="string">&quot;2&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:pivotX</span>=<span class="string">&quot;50%&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:pivotY</span>=<span class="string">&quot;50%&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:duration</span>=<span class="string">&quot;1000&quot;</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- from/to 从那放缩到哪 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- pivotX/Y 表示图的中心点位置 --&gt;</span></span><br></pre></td></tr></table></figure></div><p>动画集合（旋转、位移、透明度、缩放动画的集合）</p><div class="highlight-container" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">set</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">     <span class="attr">android:interpolator</span>=<span class="string">&quot;@android:anim/decelerate interpolator&quot;</span></span></span><br><span class="line"><span class="tag">     <span class="attr">android:shareInterpolator</span>=<span class="string">&quot;true&quot;</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rotate</span> </span></span><br><span class="line"><span class="tag">            <span class="attr">android:duration</span>=<span class="string">&quot;1000&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:fromDegrees</span>=<span class="string">&quot;0&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:repeatCount</span>=<span class="string">&quot;1&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:repeatMode</span>=<span class="string">&quot;reverse&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:toDegrees</span>=<span class="string">&quot;360&quot;</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 从多少度旋转到多少度 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">alpha</span></span></span><br><span class="line"><span class="tag">           <span class="attr">android:duration</span>=<span class="string">&quot;2000&quot;</span></span></span><br><span class="line"><span class="tag">           <span class="attr">android:fromAlpha</span>=<span class="string">&quot;1.0&quot;</span></span></span><br><span class="line"><span class="tag">           <span class="attr">android:toAlpha</span>=<span class="string">&quot;0.1&quot;</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 从多少消失到多少持续时间多久 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br></pre></td></tr></table></figure></div><p>监听器AnimationListener</p><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Animation</span> <span class="variable">animation</span> <span class="operator">=</span> AnimationUtils.loadAnimation(MainActivity.<span class="built_in">this</span>, R.anim.translate_animation)</span><br><span class="line">animation.setAnimationListener(<span class="keyword">new</span> <span class="title class_">Animation</span>.AnimationListener () &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onAnimationStart</span><span class="params">(Animation animation)</span> &#123;</span><br><span class="line">        <span class="comment">// 动画开始时执行的操作</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onAnimationEnd</span><span class="params">(Animation animation)</span> &#123;</span><br><span class="line">        <span class="comment">// 动画结束时执行的操作</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onAnimationRepeat</span><span class="params">(Animation animation)</span> &#123;</span><br><span class="line">        <span class="comment">// 动画重复时执行的操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">imageView.startAnimation(animation);</span><br></pre></td></tr></table></figure></div><h3 id="属性动画">属性动画</h3><p>直接对组件的属性进行改变</p><img lazyload src="/images/loading.svg" data-src="/posts/2023-Summer-Courses-%E7%99%BE%E5%BA%A6%E7%A7%BB%E5%8A%A8%E7%AB%AF/2023%E7%99%BE%E5%BA%A6%E7%A7%BB%E5%8A%A8%E7%AB%AFlec2-lec4/image-20230723220825113.png" class title="image-20230723220825113"><p>**定义：**改变对象的属性值来实现动画效果。需要一个属性名称(如&quot;alpha&quot;, &quot;translationX&quot;等)，一个或多个关键帧(表示属性值在某个时间点的取值)以及一个插值器(用于控制属性值在关键帧之间的变化规律)</p><p>**范围：**可以作用于任何对象</p><h4 id="ValueAnimator">ValueAnimator</h4><ul><li><p>不直接操作对象的属性，而是计算一系列值，这些值可以用于为对象的属性提供动画效果。ValueAnimator通过设定起始值、结束值、持续时间和插值器等参数，实现值的动态变化。</p></li><li><p>使用方法</p><ol><li><p>​调用ofInt(), ofFloat()或ofObject()静态方法创建ValueAnimator实例</p><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ValueAnimator</span> <span class="variable">valueAnimator</span> <span class="operator">=</span> ValueAnimator.ofInt(<span class="number">0</span>, <span class="number">100</span>);</span><br></pre></td></tr></table></figure></div></li><li><p>配置动画：时间、动画次数、动画速度等</p><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">valueAnimator.setDuration(<span class="number">1000</span>);<span class="comment">// 设置动画持续时间为1s</span></span><br><span class="line">valueAnimator.setInterpolator(<span class="keyword">new</span> <span class="title class_">LInearInterpolator</span>());<span class="comment">// 设置插值器为线性插值器</span></span><br></pre></td></tr></table></figure></div></li><li><p>监听值的变化</p><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">valueAnimator.addUpdateListener(<span class="keyword">new</span> <span class="title class_">ValueAnimator</span>.AnimatorUpdateListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onAnimatonUpdate</span><span class="params">(ValueAnimator animator)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">currentValue</span> <span class="operator">=</span> (<span class="type">int</span>) animaton.getAnimatedValue();</span><br><span class="line">        <span class="comment">// 将 currentValue 应用到对象的属性上，例如更行 ProgressBar 的进度</span></span><br><span class="line">        progressBar.setProgress(currentValue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></div></li></ol></li></ul><h4 id="ObjectAnimator（简单了解即可">ObjectAnimator（简单了解即可</h4><ul><li><p>继承自ValueAnimator，并添加了对目标对象属性的支持。它可以对目标对象的属性进行动画操作，例如平移、旋转、缩放等。</p></li><li><p>使用方法</p><ol><li><p>target: 需要动画的View; translationX：需要修改的属性；初始值、结束值</p><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ObjectAnimator</span> <span class="variable">animator</span> <span class="operator">=</span> ObjectAnimator.ofFloat(target, <span class="string">&quot;translatonX&quot;</span>, <span class="number">0f</span>, <span class="number">200f</span>);</span><br><span class="line">animator.setDuration(<span class="number">500</span>);</span><br><span class="line">animator.setInterpolator(<span class="keyword">new</span> <span class="title class_">AccelerateDecelerateInterpolator</span>());</span><br><span class="line">animator.start();</span><br></pre></td></tr></table></figure></div></li><li><p>给自定义View添加</p><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyView</span> <span class="keyword">extends</span> <span class="title class_">View</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> floate myProperty;</span><br><span class="line">    get...</span><br><span class="line">    set...&#123;</span><br><span class="line">        ...</span><br><span class="line">        invalidate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">ObjectAnimator</span> <span class="variable">animator</span> <span class="operator">=</span> ObjectAnimator.ofFloat(myView, <span class="string">&quot;myProperty&quot;</span>, <span class="number">0f</span>, <span class="number">100f</span>);</span><br><span class="line">animator.setDuration(<span class="number">500</span>);</span><br><span class="line">animator.start();</span><br></pre></td></tr></table></figure></div></li></ol></li></ul><h4 id="插值器（51-38">插值器（51:38</h4><p>体验插值器的网站<a class="link" href="https://inloop.github.io/interpolator/">Interpolator (inloop.github.io) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p><img lazyload src="/images/loading.svg" data-src="/posts/2023-Summer-Courses-%E7%99%BE%E5%BA%A6%E7%A7%BB%E5%8A%A8%E7%AB%AF/2023%E7%99%BE%E5%BA%A6%E7%A7%BB%E5%8A%A8%E7%AB%AFlec2-lec4/image-20230723221222248.png" class title="image-20230723221222248"><h2 id="过度绘制-布局优化">过度绘制&amp;布局优化</h2><h3 id="布局显示的过程">布局显示的过程</h3><ol><li><p>inflate</p><p>将XML格式的layout文件实例化为相应的View对象</p></li><li><p>measure</p><p>从根节点开始计算所有VIew的尺寸。会调用每个View的measure方法(可能会调用多次)。</p></li><li><p>layout</p><p>从根节点开始计算所有View的位置。(根据measure中确定的尺寸)</p></li><li><p>draw</p><p>绘制View</p></li></ol><h3 id="影响UI效率的因素">影响UI效率的因素</h3><ol><li><p>View太多</p><p>更多的inflate</p><p>更长的drawing时间</p></li><li><p>布局太深</p><p>更多的measure和layout</p></li><li><p>图片&amp;背景</p><p>图片资源过大</p><p>图片缩放耗时</p><p>过度绘制</p></li><li><p>频繁刷新UI</p><p>占用cpu资源</p><p>界面卡顿，交互反应慢，甚至造成ANR</p></li></ol><h3 id="过度绘制">过度绘制</h3><ul><li><strong>真彩色</strong>：没有过度绘制</li><li><strong>蓝色</strong>：过度绘制1次</li><li><strong>绿色</strong>：2次</li><li><strong>粉色</strong>：3次</li><li><strong>红色</strong>：4次或更多</li></ul><h3 id="优化实践">优化实践</h3><ol><li><p>优化布局：减少View</p><p>尽可能减的减少控件的使用，(使用drawbleLeft)</p></li><li><p>使用更合适的布局容器</p></li><li><p>使用&lt;ViewStub&gt;标签</p><p><strong>不需要立即显示的视图</strong>，可以使用该标签对其进行延迟加载(在代码中判断)</p><div class="highlight-container" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ViewStub</span></span></span><br><span class="line"><span class="tag">          <span class="attr">android:id</span>=<span class="string">&quot;@+id/vs&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">android:layout</span>=<span class="string">&quot;@layout/layout_example&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">anroid:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">anroid:layout_height</span>=<span class="string">&quot;match_parent&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure></div><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取ViewStub</span></span><br><span class="line"><span class="type">ViewStub</span> <span class="variable">viewStub</span> <span class="operator">=</span> findViewById(R.id.vs);</span><br><span class="line"><span class="keyword">if</span>(<span class="comment">/* 某个条件成立*/</span>) &#123;</span><br><span class="line">    <span class="type">View</span> <span class="variable">inflatedView</span> <span class="operator">=</span> viewStub.inflate();</span><br><span class="line">    <span class="comment">// 此时， ViewStub已经替换为Layout_example.xml中定义的布局</span></span><br><span class="line">    <span class="comment">// inflatedView 是替换后的布局的根视图</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li><li><p>使用&lt;inclued&gt; 标签</p><p>将公共布局抽取到独立的文件中，并通过该标签进行引用，以减少视图层级和代码重复</p></li><li><p>使用&lt;merge&gt; 标签</p><p>对于包含多个子视图的自定义视图，可以在根布局中使用该标签，减少视图层级，从而减少过度绘制。</p></li></ol><h3 id="过度绘制-2">过度绘制</h3><img lazyload src="/images/loading.svg" data-src="/posts/2023-Summer-Courses-%E7%99%BE%E5%BA%A6%E7%A7%BB%E5%8A%A8%E7%AB%AF/2023%E7%99%BE%E5%BA%A6%E7%A7%BB%E5%8A%A8%E7%AB%AFlec2-lec4/image-20230723222647084.png" class title="image-20230723222647084"><h3 id="检查工具">检查工具</h3><img lazyload src="/images/loading.svg" data-src="/posts/2023-Summer-Courses-%E7%99%BE%E5%BA%A6%E7%A7%BB%E5%8A%A8%E7%AB%AF/2023%E7%99%BE%E5%BA%A6%E7%A7%BB%E5%8A%A8%E7%AB%AFlec2-lec4/image-20230723222733287.png" class title="image-20230723222733287"><h2 id="作业">作业</h2><img lazyload src="/images/loading.svg" data-src="/posts/2023-Summer-Courses-%E7%99%BE%E5%BA%A6%E7%A7%BB%E5%8A%A8%E7%AB%AF/2023%E7%99%BE%E5%BA%A6%E7%A7%BB%E5%8A%A8%E7%AB%AFlec2-lec4/image-20230723222917599.png" class title="image-20230723222917599"><img lazyload src="/images/loading.svg" data-src="/posts/2023-Summer-Courses-%E7%99%BE%E5%BA%A6%E7%A7%BB%E5%8A%A8%E7%AB%AF/2023%E7%99%BE%E5%BA%A6%E7%A7%BB%E5%8A%A8%E7%AB%AFlec2-lec4/image-20230723222933356.png" class title="image-20230723222933356">]]></content>
      
      
      <categories>
          
          <category> 2023-Summer-Courses-百度移动端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 移动端开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Day2-HTTP</title>
      <link href="/posts/2023-Summer-Courses-CloudWeGo/day2-http.html"/>
      <url>/posts/2023-Summer-Courses-CloudWeGo/day2-http.html</url>
      
        <content type="html"><![CDATA[<h2 id="Day2-1-HTTP基础">Day2-1 HTTP基础</h2><h3 id="为什么需要协议">为什么需要协议</h3><ol><li>明确的边界</li><li>信息解析</li><li>（预留拓展）</li></ol><h3 id="HTTP最早版本">HTTP最早版本</h3><p>0.9</p><p>HTTP协议的最初版本是HTTP/0.9，它于1991年问世。这个版本非常简单，只支持无格式的文本数据传输，没有请求头、响应头等结构化信息。</p><p>HTTP/0.9的主要特点如下：</p><ol><li>请求方式：只支持GET请求方法，即通过GET方法请求服务器上的资源。</li><li>URL：只能包含请求的路径，没有主机名、端口号、查询参数等。</li><li>响应格式：服务器返回的响应只包含请求资源的纯文本内容，没有响应头、状态码等。</li><li>连接：每次请求都会关闭连接，无法保持持久连接。</li><li>内容类型：响应的内容类型默认为HTML。</li></ol><h3 id="HTTP协议里有什么">HTTP协议里有什么</h3><p>0.9到1.1的版本变化</p><img lazyload src="/images/loading.svg" data-src="/posts/2023-Summer-Courses-CloudWeGo/day2-http/image-20230711105619899.png" class title="image-20230711105619899"><h3 id="状态码">状态码</h3><ul><li>1xx（信息性状态码）：表示请求已被接收，正在处理中。<ul><li>100 Continue：服务器已收到请求的初始部分，客户端应继续发送剩余部分。</li><li>101 Switching Protocols：服务器已经理解请求，将切换到不同的协议进行通信。</li></ul></li><li>2xx（成功状态码）：表示请求已成功处理。<ul><li>200 OK：请求成功，返回对应的资源。</li><li>201 Created：请求已成功处理，并在服务器上创建了新资源。</li><li>204 No Content：请求成功，但响应不包含实体主体内容。</li></ul></li><li>3xx（重定向状态码）：表示需要进行进一步操作以完成请求。<ul><li>301 Moved Permanently：资源的URI已永久移动到新位置。</li><li>302 Found：资源的URI已临时移动到新位置。</li><li>304 Not Modified：客户端的缓存副本仍然有效，可以使用缓存的版本。</li></ul></li><li>4xx（客户端错误状态码）：表示请求包含语法错误或无法完成请求。<ul><li>400 Bad Request：请求无效，服务器无法理解请求。</li><li>401 Unauthorized：请求要求身份验证。</li><li>404 Not Found：请求的资源不存在。</li></ul></li><li>5xx（服务器错误状态码）：表示服务器在处理请求时发生错误。<ul><li>500 Internal Server Error：服务器遇到意外错误，无法完成请求。</li><li>502 Bad Gateway：服务器作为网关或代理，从上游服务器收到无效响应。</li></ul></li></ul><blockquote><img lazyload src="/images/loading.svg" data-src="/posts/2023-Summer-Courses-CloudWeGo/day2-http/image-20230711111350794.png" class title="image-20230711111350794"></blockquote><h3 id="HTTP报文结构">HTTP报文结构</h3><img lazyload src="/images/loading.svg" data-src="/posts/2023-Summer-Courses-CloudWeGo/day2-http/image-20230711112326548.png" class title="image-20230711112326548"><h4 id="1、请求行和响应行（状态行）">1、请求行和响应行（状态行）</h4><p>请求行：请求方法，url，HTTP版本</p><p>相应行：HTTP版本，状态码，状态描述</p><img lazyload src="/images/loading.svg" data-src="/posts/2023-Summer-Courses-CloudWeGo/day2-http/image-20230711112540419.png" class title="image-20230711112540419"><h4 id="2、请求头和响应头">2、请求头和响应头</h4><img lazyload src="/images/loading.svg" data-src="/posts/2023-Summer-Courses-CloudWeGo/day2-http/image-20230711112702967.png" class title="image-20230711112702967"><blockquote><p>不止有图上这些</p></blockquote><h5 id="1-请求头">1.请求头</h5><p><strong>Accept:MIME</strong> 可选项，不一定有</p><p>指明了期望返回的类型</p><img lazyload src="/images/loading.svg" data-src="/posts/2023-Summer-Courses-CloudWeGo/day2-http/image-20230711113256917.png" class title="image-20230711113256917"><p><strong>Host</strong></p><p>请求头中的 “Host” 字段用于指定目标服务器的主机名或 IP 地址。它是 HTTP/1.1 协议中的一个必需字段，在发送请求时应该包含在请求头部中。</p><h5 id="2-响应头">2.响应头</h5><p>Content-Length</p><p>Content-Type</p><h4 id="3、空行">3、空行</h4><h4 id="4、请求体和响应体">4、请求体和响应体</h4><h3 id="Day2-2-Hertz-应用篇">Day2-2 Hertz 应用篇</h3><h4 id="hz和thriftgo">hz和thriftgo</h4><img lazyload src="/images/loading.svg" data-src="/posts/2023-Summer-Courses-CloudWeGo/day2-http/image-20230711151253162.png" class title="image-20230711151253162"><h4 id="IDL-Interface-Definition-Language">IDL Interface Definition Language</h4><img lazyload src="/images/loading.svg" data-src="/posts/2023-Summer-Courses-CloudWeGo/day2-http/image-20230711151516937.png" class title="image-20230711151516937"><img lazyload src="/images/loading.svg" data-src="/posts/2023-Summer-Courses-CloudWeGo/day2-http/image-20230711151635573.png" class title="image-20230711151635573"><h3 id="Hz实战1">Hz实战1</h3><p><a class="link" href="https://www.cloudwego.io/zh/docs/hertz/tutorials/toolkit/usage/usage-thrift/">hz 使用 (thrift) | CloudWeGo <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p><p>创建hello.thrift文件</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> idl</span><br><span class="line">vim hello.thrift</span><br></pre></td></tr></table></figure></div><p><code>hello.thrift</code>文件内容</p><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// idl/hello.thrift</span></span><br><span class="line">namespace go nju.dsy.example </span><br><span class="line"><span class="comment">// 指明目标代码语言是go</span></span><br><span class="line"><span class="comment">// 命名空间是nju.dsy.example</span></span><br><span class="line"></span><br><span class="line">struct HelloReq &#123;</span><br><span class="line">    <span class="number">1</span>: string <span class="title function_">Name</span> <span class="params">(api.query=<span class="string">&quot;name&quot;</span>)</span>; </span><br><span class="line">    <span class="comment">// 添加 api 注解为方便进行参数绑定</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct HelloResp &#123;</span><br><span class="line">    <span class="number">1</span>: string RespBody;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">service HelloService &#123;</span><br><span class="line">    HelloResp <span class="title function_">HelloMethod</span><span class="params">(<span class="number">1</span>: HelloReq request)</span> (api.get=<span class="string">&quot;/hello&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hz new -module github.com/SYuan03/thrift/example -idl idl/hello.thrift</span><br><span class="line">go mod tidy<span class="comment"># 整理 &amp; 拉取依赖</span></span><br></pre></td></tr></table></figure></div><blockquote><p>namespace里面就是对应的多级目录结构</p></blockquote><blockquote><p>执行go mod tidy后，爆红消失</p><img lazyload src="/images/loading.svg" data-src="/posts/2023-Summer-Courses-CloudWeGo/day2-http/image-20230711231931491.png" class title="image-20230711231931491"></blockquote><p>修改 handler，添加自己的逻辑</p><div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// handler path: biz/handler/hello/example/hello_service.go</span></span><br><span class="line"><span class="comment">// 其中 &quot;hello/example&quot; 是 thrift idl 的 namespace</span></span><br><span class="line"><span class="comment">// &quot;hello_service.go&quot; 是 thrift idl 中 service 的名字，所有 HelloService 定义的方法都会生成在这个文件中</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// HelloMethod .</span></span><br><span class="line"><span class="comment">// @router /hello [GET]</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">HelloMethod</span><span class="params">(ctx context.Context, c *app.RequestContext)</span></span> &#123;</span><br><span class="line">        <span class="keyword">var</span> err <span class="type">error</span></span><br><span class="line">        <span class="keyword">var</span> req example.HelloReq</span><br><span class="line">        err = c.BindAndValidate(&amp;req)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                c.String(<span class="number">400</span>, err.Error())</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        resp := <span class="built_in">new</span>(example.HelloResp)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 你可以修改整个函数的逻辑，而不仅仅局限于当前模板</span></span><br><span class="line">        resp.RespBody = <span class="string">&quot;hello,&quot;</span> + req.Name <span class="comment">// 添加的逻辑</span></span><br><span class="line"></span><br><span class="line">        c.JSON(<span class="number">200</span>, resp)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">go build</span><br><span class="line"><span class="built_in">ls</span></span><br><span class="line">./example</span><br><span class="line">curl http://127.0.0.1:8888/hello?name=dsy -w <span class="string">&quot;\n&quot;</span></span><br></pre></td></tr></table></figure></div><img lazyload src="/images/loading.svg" data-src="/posts/2023-Summer-Courses-CloudWeGo/day2-http/image-20230711233040123.png" class title="image-20230711233040123"><p>成功</p><h3 id="Hz实战2">Hz实战2</h3><p><a class="link" href="https://www.cloudwego.io/zh/docs/hertz/tutorials/toolkit/usage/usage-thrift/">hz 使用 (thrift) | CloudWeGo <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p><p>更新一个已有的项目</p><img lazyload src="/images/loading.svg" data-src="/posts/2023-Summer-Courses-CloudWeGo/day2-http/image-20230711233626785.png" class title="image-20230711233626785"><p>根据需求重写hello.thrift的内容</p><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// idl/hello.thrift</span></span><br><span class="line">namespace go nju.dsy.example </span><br><span class="line"><span class="comment">// 指明目标代码语言是go</span></span><br><span class="line"><span class="comment">// 命名空间是nju.dsy.example</span></span><br><span class="line"></span><br><span class="line">struct GetStudentInfoReq &#123;</span><br><span class="line">    <span class="number">1</span>: i32 <span class="title function_">ID</span> <span class="params">(api.query=<span class="string">&quot;id&quot;</span>)</span>; <span class="comment">// 添加 api 注解为方便进行参数绑定</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct GetStudentInfoResp &#123;</span><br><span class="line">    <span class="number">1</span>: i32 ID;</span><br><span class="line">    <span class="number">2</span>: string Name;</span><br><span class="line">    <span class="number">3</span>: string Favorite;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct PostStudentInfoReq &#123;</span><br><span class="line">    <span class="number">1</span>: i32 ID;</span><br><span class="line">    <span class="number">2</span>: string Name;</span><br><span class="line">    <span class="number">3</span>: string Favorite;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct PostStudentInfoResp &#123;</span><br><span class="line">    <span class="number">1</span>: string RespBody;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">service StudentService &#123;</span><br><span class="line">    GetStudentInfoResp <span class="title function_">GetStudentInfoMethod</span><span class="params">(<span class="number">1</span>: GetStudentInfoReq request)</span> (api.get=<span class="string">&quot;/query&quot;</span>);</span><br><span class="line"></span><br><span class="line">    PostStudentInfoResp <span class="title function_">PostStudentInfoMethod</span><span class="params">(<span class="number">1</span>: PostStudentInfoReq request)</span> (api.post=<span class="string">&quot;/add-student-info&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><blockquote><p>thrift的idl的结构体需要标序号，参数也要标序号，以指明顺序</p><p>int用不了，要用i32</p></blockquote><p>执行</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hz update -idl idl/hello.thrift</span><br></pre></td></tr></table></figure></div><p>关于make</p><img lazyload src="/images/loading.svg" data-src="/posts/2023-Summer-Courses-CloudWeGo/day2-http/image-20230711235734655.png" class title="image-20230711235734655"><p>成功</p><p>post</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl http://127.0.0.1:8888/add-student-info -X POST -H <span class="string">&#x27;Content-Type:application/json&#x27;</span> -d <span class="string">&#x27;&#123;&quot;ID&quot;:666,&quot;Name&quot;: &quot;dsy&quot;, &quot;Favorite&quot;: &quot;peach&quot;&#125;&#x27;</span> -w <span class="string">&quot;\n&quot;</span></span><br></pre></td></tr></table></figure></div><p>get</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl http://127.0.0.1:8888/query?<span class="built_in">id</span>=10 -w <span class="string">&quot;\n&quot;</span></span><br></pre></td></tr></table></figure></div><img lazyload src="/images/loading.svg" data-src="/posts/2023-Summer-Courses-CloudWeGo/day2-http/image-20230712001708832.png" class title="image-20230712001708832"><h3 id="Hz实战3">Hz实战3</h3><p><a class="link" href="https://www.cloudwego.io/zh/docs/hertz/tutorials/toolkit/more-feature/client/">hz client 代码生成 | CloudWeGo <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p><p>参考</p><p><a class="link" href="https://github.com/cloudwego/hertz-examples/tree/main/hz/hz_client">hertz-examples/hz/hz_client at main · cloudwego/hertz-examples · GitHub <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p><p>啥玩意？</p><img lazyload src="/images/loading.svg" data-src="/posts/2023-Summer-Courses-CloudWeGo/day2-http/image-20230712002635960.png" class title="image-20230712002635960"><blockquote><ul><li><p>IDL（Interface Definition Language）：接口定义语言，用于定义分布式系统中服务接口的规范和格式。IDL 可以用于生成客户端和服务器端的代码，以便它们可以相互通信和交互数据。Thrift 和 gRPC 等框架都支持使用 IDL 进行服务定义和代码生成。</p></li><li><p>RPC（Remote Procedure Call）：远程过程调用，是一种跨网络的分布式系统通信方式，允许客户端应用程序调用远程服务器上的过程或方法，并接收返回结果。RPC 可以使用 HTTP、TCP、UDP 等协议进行通信，常用的框架包括 Thrift、gRPC、Dubbo 等。</p></li><li><p>HTTP 请求：超文本传输协议（HTTP）定义了客户端和服务器之间的通信协议。HTTP 请求是客户端向服务器发送的请求，包括请求方法、URL、请求头、请求体等信息。服务器根据这些信息来处理请求，并返回响应结果。</p></li><li><p>Hertz client：Hertz 是一个开源的 RPC 框架，支持使用 IDL 进行服务定义和代码生成。Hertz client 是客户端程序，用于向 Hertz server 发送 RPC 请求，并接收响应结果。</p></li><li><p>Hertz server：Hertz server 是服务端程序，用于接收 Hertz client 发送的 RPC 请求，并处理请求，返回响应结果。</p></li></ul><p>它提到了一种工具或框架，可以根据 IDL 文件生成客户端代码，并自动屏蔽创建和初始化 Hertz client 的繁琐操作。生成的客户端代码可以直接使用 HTTP 请求调用 Hertz server 提供的服务，并接收响应结果。使用这种工具或框架，可以大大简化分布式系统中的开发和调试过程，提高开发效率。</p></blockquote><p>先把之前的idl搬过来</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> server</span><br><span class="line"><span class="built_in">cd</span> server</span><br><span class="line">hz new -mod=github.com/SYuan03/thrift/example2 --idl=../idl/hello.thrift --handler_by_method -t=template=slim</span><br></pre></td></tr></table></figure></div><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 同理，略</span></span><br><span class="line">hz client -mod=github.com/SYuan03/thrift/client --idl=../idl/hello.thrift --model_dir=hertz_gen -t</span><br><span class="line">=template=slim --client_dir=hz_client</span><br></pre></td></tr></table></figure></div><img lazyload src="/images/loading.svg" data-src="/posts/2023-Summer-Courses-CloudWeGo/day2-http/image-20230712004622251.png" class title="image-20230712004622251"><p>成功！</p><img lazyload src="/images/loading.svg" data-src="/posts/2023-Summer-Courses-CloudWeGo/day2-http/image-20230712012317679.png" class title="image-20230712012317679">]]></content>
      
      
      <categories>
          
          <category> 2023-Summer-Courses-CloudWeGo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>note-RISC-V</title>
      <link href="/posts/2023-Spring-Courses-%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/note-risc-v.html"/>
      <url>/posts/2023-Spring-Courses-%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/note-risc-v.html</url>
      
        <content type="html"><![CDATA[<h3 id="伪指令与基本指令">伪指令与基本指令</h3><p>伪指令就是并不是硬件实现的直接指令，只是给解释器看的，比如li</p><p>就是说向li这种指令，其实并不直接对硬件进行操作</p><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/note-risc-v/image-20230602151643461.png" class title="image-20230602151643461"><p>实际上他就是一个addi指令</p><h3 id="加法、减法">加法、减法</h3><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">li t0, 20# li: load immediate 加载立即数，现在这种写法是10进制</span><br><span class="line">li t1, 22</span><br><span class="line">add t2, t0, t1</span><br><span class="line"></span><br><span class="line">li t0, 32</span><br><span class="line">addi t0, t0, 32 # addi: add immediate</span><br><span class="line">addi t0, t0, -16# 没有subi指令，所以只能这样，但是sub还是有的</span><br><span class="line"></span><br><span class="line"># f = (g + h) - (i + j)</span><br><span class="line"># t6 = (t0 + t1) - (t3 + t4)</span><br><span class="line">li t0, 0</span><br><span class="line">li t1, 10</span><br><span class="line">add t2, t0, t1</span><br><span class="line">li t3, 30</span><br><span class="line">li t4, 40</span><br><span class="line">add t5, t3, t4</span><br><span class="line">sub t6, t2, t5</span><br></pre></td></tr></table></figure></div><h3 id="系统调用">系统调用</h3><p>一共4步</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># Step 1. Load the service number in register a7. </span><br><span class="line"># Step 2. Load argument values, if any, in a0, a1, a2, a3, fa0, ... as specified. </span><br><span class="line"># Step 3. Issue the ECALL instruction. </span><br><span class="line"># Step 4. Retrieve return values, if any, from result registers as specified.</span><br><span class="line"></span><br><span class="line">li t0, 16</span><br><span class="line">li t1, 32</span><br><span class="line">add t2, t0, t1</span><br><span class="line"></span><br><span class="line">li a7, 1# a7存放系统调用号，此处为输出</span><br><span class="line">mv a0, t2# argument1，伪指令，实际上是add a0, zero, t2</span><br><span class="line">ecall</span><br></pre></td></tr></table></figure></div><blockquote><p>mv其实是cp并不是会把原来的地方的数据就清空了的</p></blockquote><h3 id="data-text">.data .text</h3><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/note-risc-v/image-20230604172502658.png" class title="image-20230604172502658"> <p>.text就是代码指令开始的地方</p><p>带<code>.</code>的就是写给汇编器看的，比如.data编译器就会放到.data的块的地方</p><p>.text就会放到存放代码的地方(如0x0040 0000)</p><p>.word = 4byte</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">.data </span><br><span class="line">g: .word 16</span><br><span class="line">h: .word 48</span><br><span class="line">i: .word 0</span><br><span class="line">j: .word 0</span><br><span class="line">result: .word 0</span><br><span class="line">msg: .string &quot;Hello world!:&quot;# .string会在末尾加&#x27;\0&#x27;而.ascii不会</span><br><span class="line"></span><br><span class="line">.text</span><br><span class="line">la t0, g# load address to t0</span><br><span class="line">lw t0, 0(t0)# load word t0中的地址+偏移量0</span><br><span class="line">la t1, h# load address to t0</span><br><span class="line">lw t1, 0(t1)# load word t0中的地址+偏移量0</span><br><span class="line"></span><br><span class="line">add t5, t0, t1</span><br><span class="line"></span><br><span class="line">la t0, result</span><br><span class="line">sw t5, 0(t0)# t5的结果保存到t0的地址中</span><br><span class="line"></span><br><span class="line"># la t1, msg</span><br><span class="line"># li a7, 4</span><br><span class="line"># mv a0, t1</span><br><span class="line"># ecall</span><br><span class="line"></span><br><span class="line">li a7, 4# 打印字符串</span><br><span class="line">la a0, msg# 其实可以直接la到a0里面就行，不需要再经过寄存器中转了，本身就是地址</span><br><span class="line">ecall</span><br><span class="line"></span><br><span class="line">li a7, 1# 打印数字</span><br><span class="line">mv a0, t5</span><br><span class="line">ecall</span><br></pre></td></tr></table></figure></div><h3 id="数组">数组</h3><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.data</span><br><span class="line">nums: .word -30, -40, -50, -60, 60, 100</span><br><span class="line"></span><br><span class="line">.text</span><br><span class="line">la t0, nums</span><br><span class="line">lw t1, 8(t0)</span><br><span class="line">addi t1, t1, 50</span><br><span class="line">sw t1, 8(t0)# 把-50变成了0</span><br></pre></td></tr></table></figure></div><h3 id="branch-max-asm">branch-max.asm</h3><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"># 实现c = max(a,b)</span><br><span class="line"></span><br><span class="line">.data</span><br><span class="line">a: .word 100</span><br><span class="line">b: .word 200</span><br><span class="line">c: .word 0</span><br><span class="line"></span><br><span class="line">.text</span><br><span class="line"># la t0, a</span><br><span class="line"># lw t0, 0(t0)</span><br><span class="line">lw t0, a# 该RARS支持的一个语法糖，并不是RISC-V的语法，考试应该不能用</span><br><span class="line">lw t1, b</span><br><span class="line"></span><br><span class="line">bge t0, t1, greater_equal# t0 &gt;= t1 就跳转到greater_equal</span><br><span class="line">mv t2, t1</span><br><span class="line">j end# 伪指令, 防止再执行到greater_equal</span><br><span class="line"></span><br><span class="line">greater_equal:</span><br><span class="line">mv t2, t0</span><br><span class="line"></span><br><span class="line">end:</span><br><span class="line">la t3, c</span><br><span class="line">sw t2, 0(t3)# 存到c的地方，同样也有简便写法 sw t2, c, t3</span><br></pre></td></tr></table></figure></div><h3 id="array-index-bit-asm求一个数组正数的和与负数的和">array-index-bit.asm求一个数组正数的和与负数的和</h3><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">.data</span><br><span class="line">numbers: .word -30, 30, -20, 20, -10, 10, 0</span><br><span class="line">size: .word 7</span><br><span class="line">positive_sum: .word 0</span><br><span class="line">negative_sum: .word 0</span><br><span class="line"></span><br><span class="line">.text</span><br><span class="line">la t0, numbers # t0: the address of the current array</span><br><span class="line">lw t1, size</span><br><span class="line">mv t2, zero # counter, initially 0</span><br><span class="line">li t3, 0 # t3: sum of positive numbers &lt;- 0</span><br><span class="line">li t4, 0 # t4: sum of negative numbers &lt;- 0</span><br><span class="line"></span><br><span class="line">loop: </span><br><span class="line">bge t2, t1, end_loop#计数器大于等于size就跳转到end_loop</span><br><span class="line"># number[t2]</span><br><span class="line"># mul t5, t2, 4</span><br><span class="line">slli t5, t2, 2 # 逻辑左移，即t5*4</span><br><span class="line">add t5, t0, t5</span><br><span class="line">lw t5, 0(t5)</span><br><span class="line">addi t2, t2, 1</span><br><span class="line">bltz t5, negative # bltz: branch if less than zero</span><br><span class="line">add t3, t3, t5</span><br><span class="line">j loop</span><br><span class="line">negative:</span><br><span class="line">add t4, t4, t5</span><br><span class="line">j loop</span><br><span class="line">end_loop:</span><br><span class="line">sw, t3, positive_sum, t5</span><br><span class="line">sw, t3, positive_sum, t5</span><br></pre></td></tr></table></figure></div><h3 id="proc-max-asm函数调用">proc-max.asm函数调用</h3><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">.data</span><br><span class="line">max_result: .word 0</span><br><span class="line"></span><br><span class="line">.text</span><br><span class="line">.global main</span><br><span class="line"></span><br><span class="line">max:</span><br><span class="line"># a0 argument 0</span><br><span class="line"># a1 argument 1</span><br><span class="line"># 同时a0-a7的前两个寄存器也可以用来返回值的保存</span><br><span class="line">    blt a0, a1, smaller</span><br><span class="line">    # 没跳转说明a0 &gt;= a1</span><br><span class="line">    # mv a0, a0 正好省略不用写</span><br><span class="line">    j end_max</span><br><span class="line"></span><br><span class="line">smaller:</span><br><span class="line">    mv a0, a1</span><br><span class="line">    </span><br><span class="line">end_max:</span><br><span class="line">ret# 等同</span><br><span class="line"># jr ra# 等同</span><br><span class="line">    # jalr zero 0(ra) # jalr: jump and link register</span><br><span class="line">                    # zero的作用：jalr会将下一条指令的地址存入</span><br><span class="line"></span><br><span class="line">### main ###</span><br><span class="line">.data</span><br><span class="line">a: .word 100</span><br><span class="line">b: .word 200</span><br><span class="line"></span><br><span class="line">.text</span><br><span class="line">main:</span><br><span class="line">    lw a0, a    # 并非risc-v的指令，而是汇编器的伪指令，将a的地址存入a0</span><br><span class="line">    lw a1, b</span><br><span class="line"></span><br><span class="line">    # jal ra, max # jal: jump and link  ra: Return Address register</span><br><span class="line">             # ra保存了返回地址，jal会将下一条指令的地址存入ra</span><br><span class="line">    # jal max</span><br><span class="line">    call max # 三种写法都一样</span><br><span class="line">    sw a0, max_result, t0</span><br></pre></td></tr></table></figure></div><h3 id="调用函数">调用函数</h3><p>参数多了可以考虑用栈来传递</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jalr zero 0(ra) # jalr: jump and link register</span><br><span class="line">                # zero的作用：jalr会将下一条指令的地址存入</span><br></pre></td></tr></table></figure></div><p>zero的作用：</p><p>jalr会做两件事情</p><ul><li><p>一是按照后面给的0(ra)进行跳转</p></li><li><p>二是会把目前所在位置的下一条指令的地址存入给出的寄存器中，如果把zero换成t0就会保存到t0，写zero的话就表示不想存这个下一条地址（用不到），因为写到zero的东西都会被清零</p></li></ul><h3 id="proc-fact-asm递归">proc-fact.asm递归</h3><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">.text</span><br><span class="line">.global main</span><br><span class="line"></span><br><span class="line">factorial:</span><br><span class="line">beqz a0, base_case  # 为0跳转，f(0) = 1</span><br><span class="line"></span><br><span class="line"># 先改变栈指针，再保存寄存器的值，先保存参数寄存器的值，再保存ra的值</span><br><span class="line">addi sp, sp, -8     # 栈空间高地址往低地址增长，所以先减8</span><br><span class="line">sw a0, 4(sp)        # 先保存a0的值，即n</span><br><span class="line">sw ra, 0(sp)        # 还需要再保存ra的值</span><br><span class="line"></span><br><span class="line"># n &gt; 0: n * f(n-1)</span><br><span class="line">addi a0, a0, -1     # 此时a0为n-1</span><br><span class="line">call factorial      # a0为f(n-1)</span><br><span class="line">mv t0, a0# t0:f(n-1)</span><br><span class="line"></span><br><span class="line">lw ra, 0(sp)        # 恢复ra的值</span><br><span class="line">lw a0, 4(sp)        # 恢复a0的值</span><br><span class="line">addi sp, sp, 8      # 恢复栈指针</span><br><span class="line"></span><br><span class="line">mul a0, a0, t0      # a0 = n * f(n-1)</span><br><span class="line">j end               # 返回, a0还要用来保存返回值</span><br><span class="line"></span><br><span class="line">base_case:</span><br><span class="line">    li a0, 1</span><br><span class="line"></span><br><span class="line">end:</span><br><span class="line">    ret</span><br><span class="line"></span><br><span class="line">### main ###</span><br><span class="line">.data</span><br><span class="line">n: .word 5</span><br><span class="line"></span><br><span class="line">.text</span><br><span class="line">main:</span><br><span class="line">lw a0, n</span><br><span class="line">call factorial</span><br></pre></td></tr></table></figure></div><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/note-risc-v/image-20230607153022783.png" class title="image-20230607153022783"> <p>注意ra的值会变</p>]]></content>
      
      
      <categories>
          
          <category> 2023-Spring-Courses-编译原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编译原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Review-CompilePrinciple</title>
      <link href="/posts/2023-Spring-Courses-%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/review-compileprinciple.html"/>
      <url>/posts/2023-Spring-Courses-%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/review-compileprinciple.html</url>
      
        <content type="html"><![CDATA[<h2 id="题目1-正则表达式与自动机">题目1 正则表达式与自动机</h2><h3 id="前置知识">前置知识</h3><h4 id="自动机：">自动机：</h4><p>Automaton/Automata 状态集+转移函数</p><h4 id="RE：">RE：</h4><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/review-compileprinciple/image-20230622172316744.png" class title="image-20230622172316744"><p>RE与DFA与NFA表达能力是等价的，所以可以相互转换</p><h4 id="DFA与NFA：">DFA与NFA：</h4><p>确定性和非确定性有穷自动机</p><p>DFA一个状态通过一个字符转移只能有一个确定的状态（也就是隐含了无法使用空串进行转移</p><p><strong>NFA 简洁易于理解, 便于描述语言 <em>L</em>(<em>A</em>)</strong></p><p><strong>DFA 易于判断 <em>x</em> <em>∈</em> <em>L</em>(<em>A</em>), 适合产生词法分析器</strong></p><p>用 NFA 描述语言, 用 DFA 实现词法分析器</p><p>RE =<em>⇒</em> NFA =<em>⇒</em> DFA =<em>⇒</em> 词法分析器</p><h4 id="DFA的死状态：">DFA的死状态：</h4><blockquote><p>死状态的画法：圈里面套个类似空集的符号</p></blockquote><h3 id="Thompson-构造法-从RE到-NFA">Thompson 构造法 (从RE到 NFA)</h3><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/review-compileprinciple/image-20230622171006623.png" class title="image-20230622171006623"><blockquote><p>外面的q/f是新增的开始和截止状态</p></blockquote><h4 id="一个例子">一个例子</h4><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/review-compileprinciple/image-20230622173337939.png" class title="image-20230622173337939"><blockquote><p>画完记得重标下状态序号</p></blockquote><h3 id="子集构造法-NFA-到-DFA">子集构造法 (NFA 到 DFA)</h3><p>一开始的状态可以是0,1,2,4,7</p><p>再看通过a,b可以转移到哪里，注意空串转移也算可到</p><p>某个状态包含NFA的某一个结束状态，就是DFA的结束状态</p><blockquote><p>可以有多个结束状态，2022-hw2甚至全是结束状态</p><p>做的时候直接看某个节点有没有通过某个字符的路径，不需要考虑他空串转移了再继续，因为他空串转移能到的那个状态本身也会在这个集合里</p></blockquote><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/review-compileprinciple/image-20230622194807211.png" class title="image-20230622194807211"><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/review-compileprinciple/image-20230622194743475.png" class title="image-20230622194743475"><h3 id="DFA-最小化">DFA 最小化</h3><p>一开始分成接受状态，非接受状态，死状态<strong>三类</strong></p><blockquote><p>课上的例子遗漏了补充死状态</p></blockquote><p>这三者肯定不等价，然后就是回到死状态的肯定跟不到的不一样，所以要补上死状态</p><ol><li>先划分等价类</li><li>再合并状态</li></ol><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/review-compileprinciple/image-20230622201739476.png" class title="image-20230622201739476"><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/review-compileprinciple/image-20230622201828915.png" class title="image-20230622201828915"> <h2 id="题目2-LL语法分析">题目2 LL语法分析</h2><h3 id="前置知识-2">前置知识</h3><h4 id="LL1文法：">LL1文法：</h4><p>L的含义：</p><p>第一个L表示 从左向右读入词法单元</p><p>第二个L表示 总是选择最左边的非终结符进行展开</p><p>语法分析的算法主要有两大类LR和LL，LL自顶向下，LR自底向上，我们只考虑无二义性的文法</p><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/review-compileprinciple/image-20230622203259136.png" class title="image-20230622203259136"><h4 id="预测分析表：用于选择产生式">预测分析表：用于选择产生式</h4><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/review-compileprinciple/image-20230622203820425.png" class title="image-20230622203820425"><blockquote><p>当前读到某个非终结符，该选用那条产生式展开，这就是预测分析表的作用</p></blockquote><h4 id="First集合：对所有产生式的右部求">First集合：对所有产生式的右部求</h4><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/review-compileprinciple/image-20230622204247007.png" class title="image-20230622204247007"><blockquote><p>参照上例</p><p>如果当前指针指向的是a2，A有三条展开式，只有第一条的右部的FIRST中包含a2，那么选用第一条产生式</p><p>FIRST集合可能会有空串符号</p></blockquote><h4 id="Follow集合：对所有非终结符">Follow集合：对所有非终结符</h4><p>其实FOLLOW集合就是对FIRST集合做了进一步补充和防备？</p><p>因为FIRST可能推出空串，所以需要FOLLOW集合辅助判断</p><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/review-compileprinciple/image-20230622205655897.png" class title="image-20230622205655897"><blockquote><p>FOLLOW集合可能有结束符$</p></blockquote><h3 id="•-First-集合与-Follow-集合">• First 集合与 Follow 集合</h3><h4 id="计算FIRST">计算FIRST</h4><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/review-compileprinciple/image-20230622210009638.png" class title="image-20230622210009638"><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/review-compileprinciple/image-20230622210107455.png" class title="image-20230622210107455"><h5 id="例子">例子</h5><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/review-compileprinciple/image-20230622211046488.png" class title="image-20230622211046488"><p>看一眼右边所有的可能性，发现要先计算FIRST(X) FIRST(Y) FIRST(Z)，仔细想想这是显然的</p><blockquote><p>推到FIRSTZ 包含于 FIRSTZ，这句显然是废话</p><p>继续考虑FIRSTZ集合有没有空串就行了</p><p>大致看一下，发现是不行的</p></blockquote><h4 id="计算FOLLOW">计算FOLLOW</h4><p>注意下图说的是对X，不是对A</p><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/review-compileprinciple/image-20230622212559227.png" class title="image-20230622212559227"><blockquote><p>如果是开始符号，FOLLOW集合中就加入$</p></blockquote><h5 id="例子：">例子：</h5><p><strong>先看X会在右侧哪里出现和是否是开始符号</strong></p><p>X是初始符，放入$</p><p>然后发现X会在Z-&gt;XYZ中</p><p>那么FLX就会包含<strong>FIRST(YZ)</strong>，先加入FIRSTY，加入了c，发现Y有可能是空串，那么FLX就会包含FIRSTZ，加入a,c,d</p><p>然后判断<strong>YZ</strong>整体会不会空，如果空了就要按照第二条把FOLLOWZ加到FOLLOWX里面</p><blockquote><p>FLZ是空，因为推到了FLZ包含FLZ，不再变化了</p></blockquote><h3 id="•-构造预测分析表">• 构造预测分析表</h3><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/review-compileprinciple/image-20230622232028397.png" class title="image-20230622232028397"><blockquote><p>上下两种表述等价，推导符号上面加个*表示经过多次推导（多次推导得到空串和空串属于FIRST alpha是等价的表述</p></blockquote><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/review-compileprinciple/image-20230622232036113.png" class title="image-20230622232036113"><blockquote><p>满足两者之一，即可填入</p></blockquote><p><strong>行是终结符和$，列是非终结符</strong></p><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/review-compileprinciple/image-20230622235125782.png" class title="image-20230622235125782"><h3 id="•-判断文法是否是LL-1-文法">• 判断文法是否是LL(1)文法</h3><p>预测分析表无冲突，即为LL1文法</p><h2 id="题目3-LR语法分析">题目3 LR语法分析</h2><blockquote><p>考试时会给出 LR(0) 自动机</p></blockquote><h3 id="•-掌握-LR-0-自动机的构造方法以及-SLR-1-表格的构造方法">• 掌握 LR(0) 自动机的构造方法以及 SLR(1) 表格的构造方法</h3><h3 id="•-掌握-LR-0-自动机与栈之间的交互运行过程">• 掌握 LR(0) 自动机与栈之间的交互运行过程</h3><h2 id="题目4-ANTLR4与“优先级上升算法”">题目4 ANTLR4与“优先级上升算法”</h2><h3 id="前置知识-3">前置知识</h3><p>消除左递归：</p><p>因为自顶向下的算法如LL1没法处理左递归，所以需要先改写一下</p><p>书P134</p><blockquote><p>不考查 ANTLR 4 AllStar 算法的其余内容</p><p>不考查LR1、LALR1</p></blockquote><h3 id="•-能够根据优先级上升算法改造给定文法">• 能够根据优先级上升算法改造给定文法</h3><h3 id="•-能够给出给定输入在改造后的文法下对应的语法分析树">• 能够给出给定输入在改造后的文法下对应的语法分析树</h3><p><strong>antlr4不能处理间接左递归</strong>，但是<code>直接左递归</code>可以，并且处理的很好</p><blockquote><p>注意是非左递归，不是像我们前面一样写成右递归，右递归不太好看，且存在一定问题（结合性问题好像是）</p></blockquote><h4 id="重点：antlr如何处理优先级和直接左递归？">重点：antlr如何<code>处理优先级</code>和<code>直接左递归</code>？</h4><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/review-compileprinciple/image-20230410211520448.png" class title="image-20230410211520448"> <p>使用该命令可看到antlr把上述语法改写成什么样</p><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/review-compileprinciple/image-20230410211927751.png" class title="image-20230410211927751"><p>看上去大体上是把递归改写成了循环</p><p>对应一段带参数的递归函数</p><blockquote><p><mark>这张图上的算法是有助于理解的</mark></p></blockquote><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/review-compileprinciple/image-20230410212354906.png" class title="image-20230410212354906"><h4 id="优先级怎么定的">优先级怎么定的</h4><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/review-compileprinciple/image-20230410212636567.png" class title="image-20230410212636567"><h4 id="例子1-2-3">例子1+2+3</h4><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/review-compileprinciple/image-20230410213228783.png" class title="image-20230410213228783"><p>匹配加法展开后参数_p变成4，目的是为了让加法优先级高的才能继续向下深入展开，因为语法树的优先级越往下展开越高，乘法同理，_p相当于一个判断能否展开的当前优先级</p><h4 id="例子1-2-3-2">例子1+2*3</h4><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/review-compileprinciple/image-20230410213708956.png" class title="image-20230410213708956"><h4 id="根本问题">根本问题</h4><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/review-compileprinciple/image-20230410213741515.png" class title="image-20230410213741515"><h4 id="另一个例子">另一个例子</h4><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/review-compileprinciple/image-20230410213934203.png" class title="image-20230410213934203"><h4 id="优先级一定就是要上升-1吗">优先级一定就是要上升+1吗</h4><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/review-compileprinciple/image-20230410214150813.png" class title="image-20230410214150813"><p><code>-</code>右结合</p><p><code>!</code>左结合</p><p>改写：</p> <img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/review-compileprinciple/image-20230410214820860.png" class title="image-20230410214820860"><p><code>-</code>是右结合，不是左递归的，所以放在上面的部分，并且优先级不变</p><p><code>!</code>左结合左递归但是是一元的左结合运算符，不需要再调用expr[]递归函数</p><h4 id="例子：-a-b">例子：-a+b!</h4><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/review-compileprinciple/image-20230410215257229.png" class title="image-20230410215257229"><p><strong>注意</strong>从E[4]返回时代码中是返回到第一个括号后，而不是回到最开始，所以开始匹配加号（进入了带*的那个循环里</p><h4 id="二元左递归运算符想要右结合">二元左递归运算符想要右结合</h4><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/review-compileprinciple/image-20230410215713340.png" class title="image-20230410215713340"><p><mark>反正就是右结合不升级，左结合升一级</mark></p><h2 id="题目5-语法制导的翻译">题目5 语法制导的翻译</h2><blockquote><p>不考查 ANTLR 4 中的写法</p></blockquote><h3 id="•-语法制导的翻译">• 语法制导的翻译</h3><h2 id="题目6-目标代码生成">题目6 目标代码生成</h2><h3 id="•-给定一段-C-语言程序-含过程调用-与对应的-RISC-V-代码片段-填充缺失的代码行。">• 给定一段 C 语言程序 (含过程调用) 与对应的 RISC-V 代码片段, 填充缺失的代码行。</h3>]]></content>
      
      
      <categories>
          
          <category> 2023-Spring-Courses-编译原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编译原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>notes-os</title>
      <link href="/posts/2023-Spring-Courses-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/notes-os.html"/>
      <url>/posts/2023-Spring-Courses-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/notes-os.html</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1>chap2 处理器管理</h1><h2 id="如何区分内核态和用户态？">如何区分内核态和用户态？</h2><p>P43</p><p>处理器状态位（程序状态字PSW中的一个比特位</p><h2 id="中断源">中断源</h2><ol><li><p><strong>硬件故障中断</strong>：电源故障，主存故障，线路故障</p></li><li><p><strong>程序性中断</strong>：执行指令异常或出错</p><p>除0、溢出、虚拟地址异常等</p></li><li><p>**自愿性中断：**又称为系统调用</p></li><li><p>**I/O中断：**比如外围设备输入输出完了，又或者输入输出异常了</p></li><li><p>**外部中断：**时钟中断，关机重启等</p></li></ol><h2 id="系统调用的处理过程">系统调用的处理过程</h2><p>P46 + P25-26（详细）</p><p>陷入指令：操作码（用于标识是陷入指令）+ 功能号</p><p>这是非特权指令</p><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/notes-os/image-20230613160246671.png" class title="image-20230613160246671"><h2 id="中断、异常与系统异常">中断、异常与系统异常</h2><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/notes-os/image-20230613160644480.png" class title="image-20230613160644480"><p>感觉就是前面5类分成了三类</p><ul><li>中断：I/O + 外部</li><li>异常：程序性 + 硬件故障</li><li>系统异常：自愿性中断（系统调用）</li></ul><h2 id="三态模型">三态模型</h2><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/notes-os/image-20230613163358249.png" class title="image-20230613163358249"><h2 id="PSW-vs-PCB">PSW vs PCB</h2><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/notes-os/image-20230613164054502.png" class title="image-20230613164054502"><h2 id="进程管理是由许多程序共同实现的">进程管理是由许多程序共同实现的</h2><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/notes-os/image-20230613170109607.png" class title="image-20230613170109607"><h2 id="队列管理程序：核心模块">队列管理程序：核心模块</h2><h2 id="进程控制程序：使用原语">进程控制程序：使用原语</h2><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/notes-os/image-20230613170548730.png" class title="image-20230613170548730"><h2 id="进程切换：必须在内核态完成，所以需要模式切换">进程切换：必须在内核态完成，所以需要模式切换</h2><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/notes-os/image-20230613170847402.png" class title="image-20230613170847402"><blockquote><p>进程切换使用的是软中断，反正不是硬件中断，就是软中断了，书上程序性中断里有一条就是“终止进程中断”，应该就是能引起进程切换的一种中断</p></blockquote><h2 id="单线程到多线程">单线程到多线程</h2><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/notes-os/image-20230613184055766.png" class title="image-20230613184055766"><blockquote><p>用户栈和内核栈</p><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/notes-os/image-20230613184324234.png" class title="image-20230613184324234"></blockquote><h2 id="多线程技术的优点和应用">多线程技术的优点和应用</h2><p>P67</p><h2 id="KLT与ULT">KLT与ULT</h2><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/notes-os/image-20230613185033419.png" class title="image-20230613185033419"><blockquote><p>稍微有点理解，因为虽然是用户级多线程，但是OS调度的还是进程去执行，并没有达到并行的效果</p></blockquote><h2 id="混合策略">混合策略</h2><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/notes-os/image-20230613185331108.png" class title="image-20230613185331108"><h2 id="三级调度">三级调度</h2><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/notes-os/image-20230613190255629.png" class title="image-20230613190255629"><blockquote><p>补充：周转时间的概念</p><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/notes-os/image-20230613194512119.png" class title="image-20230613194512119"><style>.kxfbbebcwdrg{zoom: 50%;}</style><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/notes-os/image-20230613194611521.png" class="kxfbbebcwdrg" alt="image-20230613194611521"> </blockquote><blockquote><p><strong>进程调度算法汇总</strong></p><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/notes-os/image-20230620202102546.png" class title="image-20230620202102546"></blockquote><h2 id="1-优先数调度算法">1.优先数调度算法</h2><p>分为抢占式和非抢占式</p><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/notes-os/image-20230613191056829.png" class title="image-20230613191056829"><h3 id="优先数可以是">优先数可以是</h3><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/notes-os/image-20230613191112408.png" class title="image-20230613191112408"><h3 id="1-1-FCFS先来先服务">1.1 FCFS先来先服务</h3><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/notes-os/image-20230613191930833.png" class title="image-20230613191930833"><blockquote><ul><li><p><strong><mark>一个短进程可能不得不等待很长时间才能获得执行</mark></strong></p></li><li><p><mark><strong>偏袒计算为主的进程</strong></mark></p><p><mark><strong>I/O多的进程不得不等待计算为主的进程做完</strong></mark></p><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/notes-os/image-20230613192032887.png" class title="image-20230613192032887"></li></ul></blockquote><h3 id="1-2-最短进程优先SPF">1.2 最短进程优先SPF</h3><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/notes-os/image-20230613193043368.png" class title="image-20230613193043368"><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/notes-os/image-20230613193056108.png" class title="image-20230613193056108"><p>例子</p><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/notes-os/image-20230613193109303.png" class title="image-20230613193109303"><blockquote><p>非抢占式，所以轮到了就能执行完，从没轮到的里挑最短的就行</p><p><mark>问题在于长进程可能会饿死</mark></p></blockquote><h3 id="1-3-最短剩余时间优先SRTF">1.3 最短剩余时间优先SRTF</h3><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/notes-os/image-20230613193302122.png" class title="image-20230613193302122"><p>例子</p><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/notes-os/image-20230613193616228.png" class title="image-20230613193616228"><blockquote><p>应该每个时间片都会检查下，不然没法抢占</p><p><strong>emm也可能是有新进程到达的时刻会进行能否抢占的判断</strong></p></blockquote><h3 id="1-4-最高响应比优先HRRF">1.4 最高响应比优先HRRF</h3><p>非抢占式，一个进程能运行完</p><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/notes-os/image-20230613193855402.png" class title="image-20230613193855402"><blockquote><p>作业1有例子：算一下1+ 已等待时间/服务所需时间</p></blockquote><h2 id="2-时间片轮转调度算法">2.时间片轮转调度算法</h2><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/notes-os/image-20230613191149620.png" class title="image-20230613191149620"><h3 id="2-1-RR时间片轮转">2.1 RR时间片轮转</h3><p>反正就是有个队列</p><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/notes-os/image-20230613192454834.png" class title="image-20230613192454834"><p>例子</p><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/notes-os/image-20230613192703778.png" class title="image-20230613192703778"><blockquote><p>0-1: A</p><p>1-2: A</p><p>2-3: B执行（因为2的时候B来了，B开始执行，A进入队列</p><p>3-4: A执行（B进入队列，4的时候C进入队列，此时队列是BC</p><p>4-5: B执行（队列C，A执行完了</p></blockquote><h2 id="3-分级调度算法feedback">3.分级调度算法feedback</h2><p>又叫<strong>多级反馈队列</strong>，抢占式</p><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/notes-os/image-20230613191253802.png" class title="image-20230613191253802"><h3 id="例子">例子</h3><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/notes-os/image-20230613191317257.png" class title="image-20230613191317257"><h3 id="如何分级？">如何分级？</h3><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/notes-os/image-20230613191414270.png" class title="image-20230613191414270"><h3 id="算法如下：">算法如下：</h3><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/notes-os/731364e5424c493ae86ec16e7a368c8c.png" class title="BF5A3j.png"><blockquote><p>被抢占才会降级</p></blockquote><h3 id="q-1">q=1</h3><blockquote><p>q=1表示虽然是多级但其实每个分的时间片都是1，所以后续会有一个跟RR算法的比较（因为看起来似乎一样，都是平等时间片</p><p>q=2<sup>i</sup> 表示RQ0分到2<sup>0</sup> = 1个片，RQ1分到2个，RQ2分到4个</p></blockquote><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/notes-os/image-20230613195235656.png" class title="image-20230613195235656"><h3 id="对比RR和Feedback-q-1">对比RR和Feedback(q=1)</h3><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/notes-os/image-20230613195655867.png" class title="image-20230613195655867"><blockquote><p><strong>上面的比较就是Feedback算法 C会先获得一段运行的时间</strong></p><p>Feedback：RQ0-&gt;RQ2优先级降低，时间片增长，有种均衡的感觉，优先级高的队列里都没了才轮到优先级低的队列</p><p>t=0，A到进入RQ0，A运行</p><p>t=1，A虽然没有结束，但是没有别的队列，所以A还是可以运行</p><p>t=2，B到B进入RQ0，A被降到RQ1，B运行</p><p>t=3，B也没运行完，进入RQ1排在A后面，由于没有RQ0，调度RQ1，A轮到运行，A结束</p><p>t=4，C到了，进入RQ0，C运行</p><p>t=5，C进入RQ1排在B之后，B运行</p><p>t=6，B又没运行完，进入RQ2，C运行</p><p>B一直运行到结束</p></blockquote><h3 id="例2">例2</h3><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/notes-os/image-20230613202244850.png" class title="image-20230613202244850"><h2 id="4-彩票调度算法">4.彩票调度算法</h2><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/notes-os/image-20230613191435701.png" class title="image-20230613191435701"><ol><li>基本思想：为进程发放针对<strong>系统各种资源</strong>(如CPU时间)的彩票；当调度程序需要做出决策时，随机选择一张彩票，持有该彩票的进程将获得系统资源</li><li>功能比保证调度好的多，服务器和客户：客户需要调用服务器服务，则将彩票交给服务器</li><li>合作进程之间的彩票交换</li><li>一般不会在实时操作系统中使用，但是可以在服务器端进行使用，特别是视频点播服务器</li></ol><blockquote><p>这篇文章写的蛮生动的，但是公式显然是错的</p><p><a class="link" href="https://www.cnblogs.com/tobe98/p/11792610.html">彩票调度算法——让进程们拼手气？ - tobe的呓语 - 博客园 (cnblogs.com) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/notes-os/1780031-20191104161113276-377431431.png" class title="img"><p>P应该是1-(99/100)^100 = 0.634概率随n增大而增大</p></blockquote><h2 id="Unix-SVR4-调度算法"><strong>Unix SVR4</strong> 调度算法</h2><p>任务的优先级分成了三种</p><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/notes-os/image-20230613220816415.png" class title="image-20230613220816415"><p>实时》内核》分时</p><h2 id="进程管理的fork调用">进程管理的fork调用</h2><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/notes-os/image-20230613221513690.png" class title="image-20230613221513690"><blockquote><p>注意题干：可再产生，所以是7个</p><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/notes-os/image-20230613222130541.png" class title="image-20230613222130541"></blockquote><h1>chap3 存储管理</h1><p>逻辑地址：用户编程用的</p><p>物理地址：又叫绝对地址，是实际的地址</p><h2 id="四种模式">四种模式</h2><p>P83</p><p>2*2=4种</p><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/notes-os/image-20230613232345541.png" class title="image-20230613232345541"><p>大体分为两类</p><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/notes-os/image-20230615192544792.png" class title="image-20230615192544792"><h2 id="虚拟存储器的基本思想">虚拟存储器的基本思想</h2><ul><li>存储管理把进程全部信息放在辅存中，执行时先将其中一部分装入主存，以后根据执行行为<strong>随用随调入</strong>（<mark>部分装入</mark></li><li>如主存中没有足够的空闲空间，存储管理需要根据执行行为把主存中暂时不用的信息<strong>调出</strong>到辅存上去（空间不足时需要调出一部分信息（<mark>部分替换</mark></li></ul><h2 id="虚拟存储器的示意图">虚拟存储器的示意图</h2><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/notes-os/0615164452.png" class><blockquote><p>虚拟地址可以说是将逻辑地址映射到物理地址的一种手段</p></blockquote><h2 id="单用户连续分区存储管理-固定分区存储管理-可变分区存储管理">单用户连续分区存储管理-&gt;固定分区存储管理-&gt;可变分区存储管理</h2><p>P90</p><h3 id="可变分区主存分配算法">可变分区主存分配算法</h3><ol><li><p><strong>最先适配/最先适应：</strong></p><p>最先适应就是从上向下查找，找到第一块区域放进去，将剩下的区域分割后仍作为空闲区。有利于大作业装入，但也使得内存低地址和高地址两端的分区利用不均衡，回收分区麻烦。（都从低开始放，为的是后面能放下大的，但也势必造成不平衡</p></li><li><p><strong>邻近适应/下次适配：</strong></p><p>从上次查找结束的地方开始执行最先适应分配算法</p><p>缩短平均查找时间，且存储空间利用率更均衡，不会使得小空闲区集中在内存一侧（算是对最先适应的变种</p></li><li><p><strong>最优适应</strong></p><p>最优就是要找到最适合的，所以未分配分区按小到大排，查找到第一个满足的就用</p><p>明显更容易造成很多小的内存内零头</p><p>每次都是分配最接近需要使用大小的部分，会生成很多很小的内存内零头，通常会将空闲区按照长度递增顺序排列，等同于最先适应分配算法，查找时间最长</p><blockquote><p>最优适配算法最容易产生外零头</p></blockquote></li><li><p><strong>最坏适应</strong></p><p>与最优相反，每次都挑最大的进行分配，有利于中小型作业，剩下的空闲区不至于过小</p></li></ol><h2 id="移动技术（内存紧凑-程序浮动技术）">移动技术（内存紧凑/程序浮动技术）</h2><p>P95</p><h2 id="页式存储管理的地址转换思路">页式存储管理的地址转换思路</h2><p>逻辑地址到物理地址的转换 通过 页号到页框号的转换实现（利用页表）</p><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/notes-os/image-20230615192401412.png" class title="image-20230615192401412"><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/notes-os/image-20230615192630913.png" class title="image-20230615192630913"><h2 id="使用位示图记录分配情况">使用位示图记录分配情况</h2><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/notes-os/image-20230615192807367.png" class title="image-20230615192807367"><blockquote><p>每一位与页框相对应，记录使用情况</p></blockquote><h2 id="利用Cache存放部分页表">利用Cache存放部分页表</h2><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/notes-os/image-20230615193454572.png" class title="image-20230615193454572"><blockquote><p>只是部分存在cache，主存中依旧有</p><p>页表通常被存储在主存中。每个进程都有自己的页表，用于将其虚拟地址空间映射到物理内存中的实际地址。当程序访问虚拟地址时，通过查询页表可以确定对应的物理地址，从而进行实际的内存访问。</p><p>由于页表通常比较大，访问页表可能会导致频繁的主存访问。为了提高访问效率，现代计算机系统通常使用缓存（cache）来存储最近访问的页表项。这样，当需要查询页表时，先在缓存中搜索，如果缓存命中则可以快速获取所需的映射关系，减少对主存的访问。</p><p>这个缓存通常称为&quot;Translation Lookaside Buffer&quot;（TLB），它是一个快速的硬件缓存，用于存储页表的部分或全部映射信息。TLB位于CPU内部，作为虚拟地址到物理地址转换的一级缓存。当CPU需要进行地址转换时，首先在TLB中查找对应的页表项，如果找到了映射关系，则可以直接进行物理地址访问，而无需访问主存中的页表。如果在TLB中未找到对应的映射关系，就需要访问主存中的页表来获取相应的映射信息，并将其存储到TLB中以供后续使用。</p><p>总结起来，页表主要存储在主存中，但部分或全部的页表项可能被缓存到TLB中，以提高地址转换的速度。</p></blockquote><h2 id="抖动或颠簸">抖动或颠簸</h2><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/notes-os/image-20230615200501368.png" class title="image-20230615200501368"><blockquote><p>缺页中断率：类似于未命中率</p><style>.keklpyyesmqs{zoom:50%;}</style><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/notes-os/image-20230615200617786.png" class="keklpyyesmqs" alt="image-20230615200617786"> </blockquote><h2 id="1-Belady-最佳置换-OPT">1. Belady/最佳置换/OPT</h2><p>按照不再访问、最长时间后访问到进行替换</p><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/notes-os/image-20230615201125633.png" class title="image-20230615201125633"><h2 id="2-FIFO-先进先出">2. FIFO/先进先出</h2><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/notes-os/image-20230615201245959.png" class title="image-20230615201245959"><blockquote><p>存在Belady异常：</p><p>一般情况下，增加物理内存的页框数会减少缺页次数，因为更多的页面可以留在内存中，减少了对磁盘的访问。然而，FIFO算法存在Belady异常，即在某些情况下，增加物理内存的页框数反而导致更多的页面置换和更高的缺页次数。</p><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/notes-os/image-20230615201536957.png" class title="image-20230615201536957"></blockquote><h2 id="3-最近最少使用-LRU">3. 最近最少使用/ LRU</h2><p>严格实现的代价比较大</p><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/notes-os/image-20230615201727995.png" class title="image-20230615201727995"><blockquote><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/notes-os/image-20230615202040744.png" class title="image-20230615202040744"> <p>前面3个有5，命中</p><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/notes-os/image-20230615202102891.png" class title="image-20230615202102891"> <p>前面3个没2，F，最前的是4，替换4</p></blockquote><h2 id="4-最不常使用-LFU">*4. 最不常使用 LFU</h2><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/notes-os/image-20230615202234944.png" class title="image-20230615202234944"><blockquote><p>这个似乎不考</p></blockquote><h2 id="5-时钟CLOCK">5. 时钟CLOCK</h2><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/notes-os/image-20230615205048843.png" class title="image-20230615205048843"><blockquote><p>一步步移动，2 3 2 1 5</p><p>5的时候发生了什么？指针开始寻找插入位置，会把带星号的变成不带星号的（即把访问位为1的置为了0</p><p>一遍走下来全是0了，指针回到指向2的位置，发现2的访问位为0了，就进行替换，同时让5带上*，指针指向下一个3</p></blockquote><h2 id="为什么有了页表还要反置页表">*为什么有了页表还要反置页表?</h2><p>只记住了减少了空间使用</p><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/notes-os/image-20230615210911649.png" class title="image-20230615210911649"><blockquote><style>.bqaqqcceobui{zoom: 67%;}</style><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/notes-os/image-20230615211123452.png" class="bqaqqcceobui" alt="image-20230615211123452"> </blockquote><h2 id="请求-分-页式存储管理">请求(分)页式存储管理</h2><p>首次只把进程第一页信息装入主存</p><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/notes-os/image-20230615211338877.png" class title="image-20230615211338877"><h2 id="页式和段式">页式和段式</h2><blockquote><p>书上写的很好的一段话</p></blockquote><ul><li><p>如果说促使存储管理方式<strong>从固定分区到动态分区，从分区方式向分页方式发展</strong>的主要原因是要是<strong>提高主存空间利用率。</strong></p></li><li><p>那么，<strong>引人段式</strong>存储管理的主要目的则是<strong>满足用户编程的需求。</strong></p></li></ul><p>页式存储管理是从0开始编址的单一连续逻辑地址空问，虽然可以把程序划分成页面，<strong>但页面与源程序之间并不存在逻辑关系</strong>，也就难以对源程序以模块为单位进行分配、共享和保护。段式程序设计可以更好地体现<strong>模块化程序设计</strong>的思想,应用程序由若干程序段(模块）和数据段组成，如主程序段(M)、子程序段(又）、数据段(D)和工作区段(W），每段都从0 开始编址，有各自的名字和长度，且实现不同的功能。</p><h2 id="程序的分段结构">程序的分段结构</h2><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/notes-os/image-20230615212334147.png" class title="image-20230615212334147"><blockquote><p>数组也可分成一“段”</p></blockquote><h2 id="从段式存储到段式虚拟存储">从段式存储到段式虚拟存储</h2><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/notes-os/image-20230615213449495.png" class title="image-20230615213449495"><h2 id="请求分段管理方式">请求分段管理方式</h2><p>在请求分段存储管理系统中，作业运行之前，只要求将当前需要的若干个分段装入内存，便可启动作业运行。在作业运行过程中，如果要访问的分段不在内存中，则通过调段功能将其调入，同时还可以通过置换功能将暂时不用的分段换出到外存，以便腾出内存空间。</p><blockquote><p>跟请求分页大致一个意思</p></blockquote><h2 id="关于辅存">关于辅存</h2><style>.llcpcdsmgasi{zoom:50%;}</style><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/notes-os/image-20230615214447358.png" class="llcpcdsmgasi" alt="image-20230615214447358"><h2 id="段页式存储的地址转换过程">段页式存储的地址转换过程</h2><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/notes-os/image-20230615215247468.png" class title="image-20230615215247468"><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/notes-os/image-20230615215421204.png" class title="image-20230615215421204"><blockquote><p>gg补充部分</p><p>这一章有好多部分没细看，页的大小设计之类的</p></blockquote><h2 id="伙伴系统">伙伴系统</h2><blockquote><p>参考1：</p><p><a class="link" href="https://blog.csdn.net/djl806943371/article/details/90246313">(2条消息) 操作系统学习笔记（九）：连续内存分配——伙伴系统_时间很奇妙！的博客-CSDN博客 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p><p>长得有点丑</p><p>参考2：</p><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/notes-os/image-20230615221916536.png" class title="image-20230615221916536"></blockquote><h3 id="例题">例题</h3><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/notes-os/image-20230615220746714.png" class title="image-20230615220746714"><h3 id="Slab分配器">Slab分配器</h3><p><a class="link" href="https://zhuanlan.zhihu.com/p/358891862">Linux 内核 | 内存管理——slab 分配器 - 知乎 (zhihu.com) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p><p>其中一个功能就是可以自己分配管理更小的内存，减少与Buddy系统打交道</p><h2 id="6-局部最佳页面替换算法MIN">*6. 局部最佳页面替换算法MIN</h2><blockquote><p>可能不考？</p><p>看个例子吧</p><p>驻留集其实没必要分成已驻留和In，徒增麻烦</p><p>好像也有点用，In的次数好像就是缺页的次数</p><p>因为是闭区间，所以刚到来的那个肯定是会驻留的（下一时刻能不能留当然还不好说</p></blockquote><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/notes-os/image-20230615223200898.png" class title="image-20230615223200898"><h2 id="7-工作集模型和工作集置换方法">7. 工作集模型和工作集置换方法</h2><p>基于程序性原理向后看</p><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/notes-os/image-20230615231752703.png" class title="image-20230615231752703"><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/notes-os/image-20230615231804685.png" class title="image-20230615231804685"><blockquote><p>补充一道mooc选择题：</p><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/notes-os/image-20230616110831405.png" class title="image-20230616110831405"><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/notes-os/image-20230616110809512.png" class title="image-20230616110809512"><p>简单理解就是<strong>分段</strong>是按自己需求来的，要多少划分多少，所以不可能有内部碎片（内部就是指放段的地方和段本身是否契合，那显然是正好的，因为是自己划分的），但是<strong>会有外部碎片</strong>，因为段和段直接肯定没法正好放下相容</p><p><strong>分页</strong>全都分成一个个固定的页了，自然没有外部碎片，但是自己一个页内不一定能放满，自然就<strong>造成了内部碎片</strong></p><p><strong>段页式</strong>本质还是分页，只是对段进行页的拆解后再塞入，所以还是有<strong>内部碎片</strong></p><p><strong>固定分区</strong>显然还会有内部碎片</p></blockquote><h1>chap4 设备管理</h1><h2 id="I-O设备分类">*I/O设备分类</h2><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/notes-os/image-20230616135838645.png" class title="image-20230616135838645"><h2 id="设备管理的目标">设备管理的目标</h2><p>解决设备和CPU速度的不匹配，使主机和设备充分并行工作，提高设备使用效率</p><h2 id="什么是设备控制器？">什么是设备控制器？</h2><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/notes-os/image-20230616140924473.png" class title="image-20230616140924473"><h2 id="I-O控制">I/O控制</h2><p><strong>轮询</strong></p><p><strong>中断</strong></p><p>**DMA直接存储器访问：**相当于小处理器：模仿处理器来控制主存和设备控制器之间的数据交换</p><p>“周期窃取”</p><blockquote><p>完成后依然需要中断，因为要告知CPU处理的情况，只是数据交换/传输/传送不需要CPU的介入了</p></blockquote><p><strong>通道 I/O处理器 通道控制器</strong></p><p>多级连接</p><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/notes-os/image-20230616142347755.png" class title="image-20230616142347755"><blockquote><p>通道可以一次面向多个不同的数据块</p></blockquote><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/notes-os/image-20230616142306767.png" class title="image-20230616142306767"><h2 id="I-O缓冲">*I/O缓冲</h2><p>解决设备和进程速度不匹配的问题</p><h3 id="单缓冲技术">单缓冲技术</h3><h3 id="双缓冲技术">双缓冲技术</h3><p>以输入为例，从设备读一部分数据到缓冲区1，用户进程从缓冲区1读取数据的同时，缓冲区2可以从设备读取下一部分数据读取，这样就有了一定的并行性，提高了效率</p><h3 id="循环缓冲技术">循环缓冲技术</h3><p>没细看</p><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/notes-os/image-20230616144518266.png" class title="image-20230616144518266"><h2 id="设备独立性">*设备独立性</h2><p>用户不指定物理设备，而是逻辑设备</p><p>分离用户进程和物理设备，达成设备的独立性</p><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/notes-os/image-20230616144627412.png" class title="image-20230616144627412"><h2 id="独占型设备需要分配-共享设备一般不必分配">独占型设备需要分配 共享设备一般不必分配</h2><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/notes-os/image-20230616144932095.png" class title="image-20230616144932095"><h2 id="磁盘存取时间：三部分">磁盘存取时间：三部分</h2><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/notes-os/image-20230616145406139.png" class title="image-20230616145406139"><h2 id="驱动调度：移臂调度-旋转调度">驱动调度：移臂调度 + 旋转调度</h2><p>**移臂调度：**使移动臂的移动时间最短，从而减少寻道总时间</p><p>**旋转调度：**在最少的旋转圈数之内解决该柱面上的全部I/O请求（处理同一个柱面上的请求</p><h2 id="移臂调度算法">移臂调度算法</h2><h3 id="1-FCFS">1. FCFS</h3><ul><li><p>移臂距离大，性能不好，移动臂是随机移动，寻道性能较差</p></li><li><p>按顺序处理请求，对所有进程公平</p></li></ul><h3 id="2-最短查找时间优先-SSTF">2. 最短查找时间优先 SSTF</h3><ul><li>先执行查找时间最短的请求，具有较好的寻道性能</li><li>存在“饥饿”现象：距离比较远的很难被满足</li><li>总是选择最小寻道时间并不能保证平均寻道时间最小，但是它的性能比 FCFS 更好</li></ul><h3 id="3-扫描算法">3. 扫描算法</h3><ol><li><p><strong>SCAN/双向扫描</strong></p><p>双向，扫到头回头</p></li><li><p><strong>分步扫描/N-step-SCAN</strong></p><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/notes-os/image-20230620201058810.png" class title="image-20230620201058810"></li><li><p><strong>LOOK/电梯</strong></p><p>双向，扫到某方向最后一个回头</p></li><li><p><strong>C-SCAN/循环扫描/单向扫描</strong></p></li></ol><h2 id="旋转调度">旋转调度</h2><p>没看</p><h2 id="虚拟设备">虚拟设备</h2><h3 id="虚拟设备技术">虚拟设备技术</h3><p>虚拟设备是用一类物理设备模拟另一类物理设备的技术，可以让独享型设备变为共享设备</p><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/notes-os/image-20230616172015815.png" class title="image-20230616172015815"><blockquote><p>鼠标模拟游戏操纵杆</p><p>串行接口设备模拟并行接口设备</p></blockquote><h2 id="SPOOLing系统">SPOOLing系统</h2><p>SPOOLing = 外围设备联机并行操作 = 假脱机操作</p><blockquote><p>简单理解</p><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/notes-os/image-20230616173055924.png" class title="image-20230616173055924"></blockquote><h2 id="一个经典的SPOOLing系统">一个经典的SPOOLing系统</h2><p>主要就是预输入，缓输出，加上一个“井”管理程序</p><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/notes-os/image-20230616173702995.png" class title="image-20230616173702995"><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/notes-os/image-20230616173833922.png" class title="image-20230616173833922"><blockquote><p>简单理解就是先存一点，然后统一抽个去处理，这样就不会某个设备其实实际上使用外围设备的时间就只有一开始一点点，但是占用了外围设备很久，导致其他进程无法使用外围设备</p></blockquote><blockquote><p>补充内容</p></blockquote><h2 id="磁盘Cache">磁盘Cache</h2><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/notes-os/image-20230616175638916.png" class title="image-20230616175638916"><h2 id="设备的分配">设备的分配</h2><p>设备类表和设备表</p><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/notes-os/image-20230616175821628.png" class title="image-20230616175821628"><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/notes-os/image-20230616175903847.png" class title="image-20230616175903847"><p>设备分配算法</p><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/notes-os/image-20230616175913552.png" class title="image-20230616175913552"><h2 id="出错处理">出错处理</h2><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/notes-os/image-20230616180050230.png" class title="image-20230616180050230"><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/notes-os/image-20230616180110001.png" class title="image-20230616180110001"><h2 id="I-O软件层次">I/O软件层次</h2><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/notes-os/image-20230616185653196.png" class title="image-20230616185653196"><p>其中设备驱动程序会做一件事情：</p><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/notes-os/image-20230616185723178.png" class title="image-20230616185723178"><blockquote><p>这部分最好再看看，每个层次的I/O都做了什么事情</p></blockquote><h2 id="习题">习题</h2><h3 id="通道技术是一种硬件机制">通道技术是一种硬件机制</h3><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/notes-os/image-20230616185138645.png" class title="image-20230616185138645"><h1>chap5 文件管理</h1><h2 id="文件系统的组成">文件系统的组成</h2><p>总体结构</p><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/notes-os/image-20230616200234765.png" class title="image-20230616200234765"><h2 id="存取存储方法">存取存储方法</h2><h3 id="顺序存取">顺序存取</h3><p>磁带机</p><p>光盘设备</p><h3 id="直接存取-随机存取">直接存取/随机存取</h3><p>磁盘</p><p>机械硬盘 + 固态硬盘</p><p>它的每个物理记录有确定的位置和唯一的地址，存取任何一个物理块所需的时间几乎不依赖于此信息的位置</p><blockquote><p>顺序存取和直接存取的理解：</p><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/notes-os/image-20230616221907283.png" class title="image-20230616221907283"></blockquote><h2 id="文件的逻辑结构">文件的逻辑结构</h2><h3 id="流式文件">流式文件</h3><p>全是连续字节流，可能有特殊字符作为分界线</p><p>无结构</p><h3 id="记录式文件">记录式文件</h3><p>若干逻辑记录组成的记录流文件</p><p>如每个职工的工资信息是一个逻辑记录</p><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/notes-os/image-20230616220621896.png" class title="image-20230616220621896"><h2 id="成组与分解">成组与分解</h2><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/notes-os/image-20230616221105634.png" class title="image-20230616221105634"> <h2 id="文件的物理结构">文件的物理结构</h2><h3 id="顺序文件-连续文件">顺序文件/连续文件</h3><p>磁带文件、光盘文件</p><h3 id="连接文件-串联文件">连接文件/串联文件</h3><p>每个块会有个连接字，指出文件的下一个物理块位置，为0则表示本文件块结束，第一个块的位置由文件目录给出</p><h3 id="直接文件-散列文件">直接文件/散列文件</h3><p>hash</p><p>通过计算记录的关键字建立与其物理存储地址之间的对应关系</p><h3 id="索引文件">索引文件</h3><p>文件目录-&gt;索引表地址-&gt;查索引表得到键和存储地址</p><p>多级索引结构</p><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/notes-os/image-20230616224722564.png" class title="image-20230616224722564"><h2 id="文件目录">文件目录</h2><h3 id="一级文件目录">一级文件目录</h3><h3 id="二级文件目录">二级文件目录</h3><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/notes-os/image-20230616235630425.png" class title="image-20230616235630425"><h3 id="树形目录结构">树形目录结构</h3><p>有点像FAT12</p><p>内容既可以是文件也可以是目录</p><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/notes-os/image-20230616235913120.png" class title="image-20230616235913120"><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/notes-os/image-20230617000121547.png" class title="image-20230617000121547"><blockquote><p>应该是目前主流的，树形目录结构</p></blockquote><h2 id="存取控制矩阵">存取控制矩阵</h2><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/notes-os/image-20230617000311267.png" class title="image-20230617000311267"><h2 id="存取控制表">存取控制表</h2><p>因为矩阵往往比较稀疏</p><h2 id="文件的存取方法">文件的存取方法</h2><h3 id="顺序存取-2">顺序存取</h3><p>读指针，写指针进行推进</p><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/notes-os/image-20230617000526507.png" class title="image-20230617000526507"><h3 id="直接存取">直接存取</h3><p>没啥可说的，找到地方直接就能读写</p><h3 id="索引存取">索引存取</h3><p>实际的系统中，大都采用多级索引，以加速记录查找过程</p><h2 id="再遇位示图">再遇位示图</h2><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/notes-os/image-20230617000849041.png" class title="image-20230617000849041"><h2 id="成组连接法">成组连接法</h2><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/notes-os/image-20230617004856741.png" class title="image-20230617004856741"><p>比如这张图上，盘块50里面的内容就是记录了下一组的情况，空闲数100，有哪些空闲块，然后第一个空闲块是150，又被用来记录下一组的情况，依此类推（其实是一个栈的结构，第一个空闲块最先进入，所以最后出去</p><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/notes-os/image-20230617005320992.png" class title="image-20230617005320992"><blockquote><p>归还时的算法</p><p>如果已经100了怎么办</p><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/notes-os/image-20230617010049445.png" class title="image-20230617010049445"><p>比如a盘块目前记录了100个空闲块，</p><p>又归还来一个c，那么把a盘块的专用快b的信息复制到c，然后把b清空，c放进去（b的空间快置为1）</p><p>分配时如果不够了怎么办，其实就是把下一个的数据复制进来</p><p>a盘块目前只有一个空闲块b，b是专用块，里面存了信息的，现在要分配，那么复制b的信息到栈中继续分配</p></blockquote><blockquote><p>看这个例子把，PPT不知道写的什么玩意</p><p><a class="link" href="https://blog.csdn.net/smartab/article/details/81285353">(2条消息) 实例讲解成组链接法_成组链接法例题_smartab的博客-CSDN博客 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p></blockquote><blockquote><p>补充部分chap5</p></blockquote><p>最重要的其实就是这一张表</p><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/notes-os/image-20230620175412980.png" class title="image-20230620175412980"><blockquote><p>用户打开文件表在pcb里，存放的是指向系统打开文件表项的指针，系统打开文件表就有inode等重要信息</p><p>files_struct 用户打开文件表</p><p>file_struct 系统打开文件表</p><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/notes-os/image-20230620175638662.png" class title="image-20230620175638662"></blockquote><h2 id="简答题汇总">简答题汇总</h2><h3 id="1-试写出进程映像包括哪些组成部分-不必详述每个组成部分的具体内容-。">1. 试写出进程映像包括哪些组成部分(不必详述每个组成部分的具体内容)。</h3><p>进程控制块、进程程序块（进程数据块）和进程核心栈。</p><blockquote><p>第六版的书上P57只分了三个</p><p>进程数据块包含了下图的绿色部分</p></blockquote><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/notes-os/image-20230620194342893.png" class title="image-20230620194342893"><h3 id="2-I-O-软件的一般分为四层结构，请按照自顶向下的顺序写出四层结构的名称。">2. I/O 软件的一般分为四层结构，请按照自顶向下的顺序写出四层结构的名称。</h3><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/notes-os/image-20230620194352594.png" class title="image-20230620194352594"><h3 id="3-请画出三状态、五状态和七状态进程模型（包括挂起）及其状态转换图">3. 请画出三状态、五状态和七状态进程模型（包括挂起）及其状态转换图</h3><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/notes-os/image-20230620200130428.png" class title="image-20230620200130428"><h3 id="4-进程调度：6种-3抢-3不抢">4. 进程调度：6种 3抢 3不抢</h3><p>感觉就是FeedBack只要来了就会给机会运行一段时间</p><p>注意RR算法是先来先服务的，所以新来的只要还有在运行，就要排队，<strong>而且新来的会比正在运行的那个先排到队尾</strong></p><h3 id="5-银行家算法">5. 银行家算法</h3><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/notes-os/image-20230620213058841.png" class title="image-20230620213058841"><h3 id="6-页面替换算法">6. 页面替换算法</h3><p>Belady/最佳置换/OPT</p><p>FIFO/先进先出</p><p>最近最少使用/ LRU</p><p>时钟CLOCK</p><ul><li>设置访问位和一个循环移动的指针</li><li>如果命中，指针是不会动的，只是把访问位变为1（本来是1就还是1</li></ul><p>工作集模型和工作集置换方法</p><ul><li><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/notes-os/image-20230620221401511.png" class title="image-20230620221401511"></li></ul><h3 id="7-操作系统三个最基本的抽象以及为什么要引入">7. 操作系统三个最基本的抽象以及为什么要引入</h3><ul><li>进程抽象–是对已进入主存正在运行的程序在处理器上操作的状态集的抽象</li><li>虚存抽象–是对物理主存的抽象,进程可获得-个硕大的连续地址空间来存放可执行程序和数据，可使用虚拟地址来引用物理主存单元。</li><li>文件抽象–是对设备(磁盘)的抽象。</li></ul><p><strong>防止硬件资源被失控的应用程序滥用</strong></p><p>以及<strong>屏蔽复杂的硬件资源操作细节</strong>，为应用程序提供使用硬件资源的简单且一致的方法。</p><h3 id="8-霍尔管程">8. 霍尔管程</h3><p>读者写者：应该是写者优先，实现的是</p><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/notes-os/image-20230621004746103.png" class title="image-20230621004746103"><blockquote><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/notes-os/image-20230621004842245.png" class title="image-20230621004842245"></blockquote><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/notes-os/image-20230621013953943.png" class title="image-20230621013953943"><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/notes-os/image-20230621014011125.png" class title="image-20230621014011125"><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/notes-os/image-20230621014029945.png" class title="image-20230621014029945">]]></content>
      
      
      <categories>
          
          <category> 2023-Spring-Courses-操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>notes-dbms</title>
      <link href="/posts/2023-Spring-Courses-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86/notes-dbms.html"/>
      <url>/posts/2023-Spring-Courses-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86/notes-dbms.html</url>
      
        <content type="html"><![CDATA[<h2 id="chap1-绪论">chap1 绪论</h2><h3 id="SQL数据库与NoSQL数据库">SQL数据库与NoSQL数据库</h3><p>其实就是NoSQL主要是面向单一的大量数据（比如一个人每天的定位数据这种，显然那比较适合NoSQL</p><p>但是那种需要经常读写的，就需要关系型数据库来维持ACID的性质</p><style>.lbmrysfxbesb{zoom: 33%;}</style><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86/notes-dbms/image-20230606145656080.png" class="lbmrysfxbesb" alt="image-20230606145656080"> <blockquote><p>SQL 结构化查询语言</p><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86/notes-dbms/image-20230606145744392.png" class title="image-20230606145744392"></blockquote><h3 id="三级模式结构-例子">三级模式结构-例子</h3><p>GPT:</p><p>让我们以一个简单的学生信息管理系统为例来说明外模式-模式-内模式的概念。</p><p>假设我们有一个学生信息管理系统，其中包含以下数据：</p><ul><li>**内模式（Internal Schema）：**在底层，数据库的内模式定义了数据在物理存储介质上的实际存储方式和结构。假设我们使用关系型数据库，并使用MySQL的InnoDB存储引擎，数据以表格的形式存储在磁盘上，包括学生表（Student table）、课程表（Course table）和成绩表（Grade table）等。内模式定义了表的存储方式、索引结构、数据分区等底层实现细节。</li><li>**模式（Conceptual Schema）：**在中间层，数据库的模式定义了整个数据库的逻辑结构和关系。假设我们的模式包括学生表（Student table）、课程表（Course table）和成绩表（Grade table）之间的关系。它描述了表之间的主键-外键关系、表的属性和约束等信息。模式是对整个数据库的全局视图，独立于具体的应用程序。</li><li>**外模式（External Schema）：**在最高层，数据库的外模式定义了特定用户或应用程序对数据库的部分可见视图。假设我们有两个外模式：<ol><li>学生用户外模式（Student User External Schema）：学生用户只对学生表（Student table）感兴趣，他们可以访问学生的基本信息，如学号、姓名、年龄等。其他表（如课程表和成绩表）对他们不可见。</li><li>教师用户外模式（Teacher User External Schema）：教师用户对课程表（Course table）和成绩表（Grade table）感兴趣，他们可以访问课程的信息和学生的成绩。其他表（如学生表）对他们不可见。</li></ol></li></ul><p>通过这个案例，可以看到：</p><ul><li>内模式定义了数据在底层存储介质上的物理结构和存储方式。</li><li>模式定义了整个数据库的逻辑结构和表之间的关系。</li><li><mark>外模式定义了特定用户或应用程序对数据库的部分可见视图，根据用户的需求定义了他们可以访问的数据集合。</mark></li></ul><p>这种外模式-模式-内模式的层次结构帮助实现数据的抽象和分离，使得不同用户或应用程序可以根据自己的需求访问数据库中的数据，而不需要了解底层的物理存储细节或其他用户不可见的数据。</p><h2 id="chap2-关系数据库">chap2 关系数据库</h2><h3 id="规范条件">规范条件</h3><p>最基本的一条，不允许“表中有表”</p><h3 id="关系模式">关系模式</h3><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86/notes-dbms/image-20230607093402503.png" class title="image-20230607093402503"><p>D就是域的集合</p><p>DOM是指明属性的域是哪个</p><h3 id="外码">外码</h3><p>参照关系和被参照关系不一定是不同的关系</p><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86/notes-dbms/image-20230607094521264.png" class title="image-20230607094521264"><h3 id="主键和主属性">主键和主属性</h3><p>个人感觉任一候选码的属性都是主属性</p><p>主键就是人为选定的一个候选码，应该等同于主码的概念</p><h3 id="五种基本关系代数运算">五种基本关系代数运算</h3><p>并 差 笛卡尔积 选 投</p><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86/notes-dbms/image-20230607130030167.png" class title="image-20230607130030167"><h3 id="连接操作">连接操作</h3><p>分类众多</p><p>连接：</p><ul><li>等值连接<ul><li>自然连接<ul><li>内连接</li><li>外连接<ul><li>外连接</li><li>左外连接</li><li>右外连接</li></ul></li></ul></li><li>普通等值连接</li></ul></li><li>非等值连接</li></ul><h2 id="chap3-SQL">chap3 SQL</h2><blockquote><div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">center</span>&gt;</span><span class="tag">&lt;<span class="name">embed</span> <span class="attr">src</span>=<span class="string">&quot;https://box.nju.edu.cn/f/e58b4ec1bf54441eb433/&quot;</span> <span class="attr">width</span>=<span class="string">&quot;100%&quot;</span> <span class="attr">height</span>=<span class="string">&quot;700&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">center</span>&gt;</span></span><br></pre></td></tr></table></figure></div></blockquote><center><embed src="https://box.nju.edu.cn/f/69dba853072a483ea525/" width="100%" height="700"></center><h3 id="MySQL中没有模式Schema的概念吗？">MySQL中没有模式Schema的概念吗？</h3><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86/notes-dbms/image-20230608223932854.png" class title="image-20230608223932854"><blockquote><p>比如PostgreSQL中一个数据库下还是有Schema的概念的</p><style>.wnrwnogwbxph{zoom:33%;}</style><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86/notes-dbms/image-20230608224113186.png" class="wnrwnogwbxph" alt="image-20230608224113186"> </blockquote><h3 id="Show-search-path-语句">Show search_path; 语句</h3><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86/notes-dbms/image-20230608232225767.png" class title="image-20230608232225767"><h3 id="索引">索引</h3><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86/notes-dbms/image-20230608234525154.png" class title="image-20230608234525154"><blockquote><p>以及数据字典</p><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86/notes-dbms/image-20230608234659179.png" class title="image-20230608234659179"></blockquote><h3 id="涉及空串的查询-P96">涉及空串的查询 P96</h3><p>必须用IS NULL 或者IS NOT NULL</p><p>用=NULL永远返回False</p><h3 id="派生表">派生表</h3><p>AS关键字可以省略，但是必须起一个别名</p><h3 id="空值">空值</h3><style>.ulqpqultlxhu{zoom: 50%;}</style><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86/notes-dbms/image-20230609223622182.png" class="ulqpqultlxhu" alt="image-20230609223622182"> <h3 id="行列子集视图">行列子集视图</h3><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86/notes-dbms/image-20230609230314911.png" class title="image-20230609230314911"><h3 id="视图消解">视图消解</h3><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86/notes-dbms/image-20230610113136034.png" class title="image-20230610113136034"><p>意思就是转换成对基本表的操作</p><h3 id="视图的作用-更清晰的表达">视图的作用-更清晰的表达</h3><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86/notes-dbms/image-20230610113942910.png" class title="image-20230610113942910"><blockquote><p>感觉也可以用嵌套查询</p><p>比如使用派生表，感觉差不太多</p><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86/notes-dbms/image-20230610114303292.png" class title="image-20230610114303292"></blockquote><h3 id="join关键字">join关键字</h3><p>ppt貌似只有这里出现过</p><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86/notes-dbms/image-20230610114454170.png" class title="image-20230610114454170"><h3 id="视图的作用">视图的作用</h3><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86/notes-dbms/image-20230610130713351.png" class title="image-20230610130713351"><h3 id="SQL语言的两种使用方式">SQL语言的两种使用方式</h3><p><strong>交互式</strong>和<strong>嵌入式</strong></p><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86/notes-dbms/image-20230610132105603.png" class title="image-20230610132105603"><h3 id="GROUP-BY-多个字段">GROUP BY 多个字段</h3><p><a class="link" href="https://www.cnblogs.com/zhuchenglin/p/9732612.html">group by 多个字段 - lin_zone - 博客园 (cnblogs.com) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p><h2 id="chap4-数据库安全性">chap4 数据库安全性</h2><h3 id="不安全因素">不安全因素</h3><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86/notes-dbms/image-20230610152056054.png" class title="image-20230610152056054"><h3 id="用户身份鉴别">用户身份鉴别</h3><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86/notes-dbms/image-20230610152855646.png" class title="image-20230610152855646"><h3 id="存取控制">存取控制</h3><p>• <strong>用户权限定义</strong>，并将用户权限登记到数据字典中</p><p>​<strong>–</strong> 用户对某一数据对象的操作权力称为权限</p><p>​<strong>–</strong> DBMS 提供适当的语言来定义用户权限，存放在数据字典中，称做安全规则或授权规则</p><p>• <strong>合法权限检查</strong></p><p>• 用户权限定义和合法权检查机制一起组成了数据库管理系统的存取控制子系统</p><h3 id="两种存取控制方法">两种存取控制方法</h3><p>C2 级的数据库管理系统支持自主存取控制（Discretionary Access Control，DAC），B1 级的数据库管理系统支持强制存取控制（Mandatory Access Control，MAC）</p><p><strong>–</strong> 在<strong>自主存取控制</strong>方法中，用户对不同的数据对象有不同的存取权限，不同的用户对同一对象也</p><p>有不同的权限，而且用户还可将其拥有的存取权限转授给其他用户</p><p><strong>–</strong> 在<strong>强制存取控制</strong>方法中，每一个数据对象被标以一定的密级，每一个用户也被授予某一个级别</p><p>的许可证，对于任意一个对象，只有具有合法许可证的用户才可以存取</p><h3 id="DAC-自主存取控制">DAC 自主存取控制</h3><h3 id="PUBLIC">PUBLIC</h3><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86/notes-dbms/image-20230610153601736.png" class title="image-20230610153601736"><h3 id="WITH-GRANT-OPTION">WITH GRANT OPTION</h3><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86/notes-dbms/image-20230610153638308.png" class title="image-20230610153638308"><h3 id="REVOKE">REVOKE</h3><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86/notes-dbms/image-20230610153855101.png" class title="image-20230610153855101"><h3 id="创建数据库模式的权限">创建数据库模式的权限</h3><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86/notes-dbms/image-20230610160403928.png" class title="image-20230610160403928"><h3 id="数据库角色">数据库角色</h3><p>先给角色grant权限再把角色grant给用户，能稍微简便点</p><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86/notes-dbms/image-20230610160614668.png" class title="image-20230610160614668"><h3 id="自主存取控制的缺点">自主存取控制的缺点</h3><p>优点就是灵活吧，并且达到了C级别的安全级别（C2？）</p><p>缺点如下</p><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86/notes-dbms/image-20230610160736743.png" class title="image-20230610160736743"><h3 id="MAC？强取存取控制">MAC？强取存取控制</h3><blockquote><p>解释</p><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86/notes-dbms/image-20230610165125024.png" class title="image-20230610165125024"></blockquote><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86/notes-dbms/image-20230610165149459.png" class title="image-20230610165149459"><h3 id="视图机制">视图机制</h3><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86/notes-dbms/image-20230610165235728.png" class title="image-20230610165235728"><blockquote><p>这个间接有点迷，背背吧</p><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86/notes-dbms/image-20230610165642818.png" class title="image-20230610165642818"></blockquote><h3 id="审计">审计</h3><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86/notes-dbms/image-20230610165742294.png" class title="image-20230610165742294"><h4 id="审计语句AUDIT">审计语句AUDIT</h4><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86/notes-dbms/image-20230610165827484.png" class title="image-20230610165827484"><h3 id="数据加密">数据加密</h3><p>存储加密，传输加密等</p><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86/notes-dbms/image-20230610170017449.png" class title="image-20230610170017449"><h2 id="chap5-数据库完整性">chap5 数据库完整性</h2><h3 id="完整性机制">完整性机制</h3><p>三类</p><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86/notes-dbms/image-20230610184540328.png" class title="image-20230610184540328"><h3 id="实体完整性">实体完整性</h3><p>PRIMARY KEY</p><p>列级和表级说明</p><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86/notes-dbms/image-20230610184746158.png" class title="image-20230610184746158"><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86/notes-dbms/image-20230610184755985.png" class title="image-20230610184755985"><h3 id="实体完整性检查">实体完整性检查</h3><p>唯一 + 主码各属性非空</p><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86/notes-dbms/image-20230610184910472.png" class title="image-20230610184910472"><h4 id="全表扫描-或-索引（如B-树）">全表扫描 或 索引（如B+树）</h4><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86/notes-dbms/image-20230610185757457.png" class title="image-20230610185757457"><h3 id="参照完整性">参照完整性</h3><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86/notes-dbms/image-20230610190521113.png" class title="image-20230610190521113"><h4 id="处理">处理</h4><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86/notes-dbms/image-20230610190621422.png" class title="image-20230610190621422"><h4 id="例：SET-NULL">例：SET-NULL</h4><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86/notes-dbms/image-20230610190652007.png" class title="image-20230610190652007"><h3 id="显示说明参照完整性的违约处理">显示说明参照完整性的违约处理</h3><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86/notes-dbms/image-20230610190808522.png" class title="image-20230610190808522"><h3 id="用户定义的完整性">用户定义的完整性</h3><h4 id="属性上">属性上</h4><p>非空 唯一等</p><p>或者使用CHECK关键字</p><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86/notes-dbms/image-20230610193319187.png" class title="image-20230610193319187"><h4 id="元组上">元组上</h4><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86/notes-dbms/image-20230610193354768.png" class title="image-20230610193354768"><h3 id="还可以使用完整性命名子句CONSTRAINT">还可以使用完整性命名子句CONSTRAINT</h3><p>这样约束就能有名字了，同时也便于删去</p><p>主码约束也可以成为Constraint的一部分</p><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86/notes-dbms/image-20230610193927385.png" class title="image-20230610193927385"><h3 id="删除（修改）CONSTARINT">删除（修改）CONSTARINT</h3><p>似乎没有修改语句</p><p>只能先DROP掉，再ADD</p><p>注意要配合<strong>alter table</strong>使用</p><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86/notes-dbms/image-20230610194023534.png" class title="image-20230610194023534"><h3 id="断言">断言</h3><p>可以定义更具一般性的约束，比如涉及聚合操作等比较复杂的完整性约束</p><h4 id="例子">例子</h4><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86/notes-dbms/image-20230610194721442.png" class title="image-20230610194721442"><h3 id="触发器">触发器</h3><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86/notes-dbms/image-20230610194850051.png" class title="image-20230610194850051"><h4 id="定义">定义</h4><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86/notes-dbms/image-20230610195159214.png" class title="image-20230610195159214"><h4 id="触发器类型">触发器类型</h4><p>行级，语句级</p><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86/notes-dbms/image-20230610195232494.png" class title="image-20230610195232494"><h4 id="例子-2">例子</h4><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86/notes-dbms/image-20230610200130535.png" class title="image-20230610200130535"><blockquote><p>这是一个<strong>行级触发器</strong>，有FOR EACH ROW</p><p>这例子有点绕，OLDROW（或者OLD）和NEWROW（或者NEW）是保留字，不随题目变化而变化，Oldgrade和Newgrade只是该题恰好要的两个属性</p></blockquote><h4 id="触发器激活顺序">触发器激活顺序</h4><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86/notes-dbms/image-20230610200341268.png" class title="image-20230610200341268"><h4 id="删除触发器">删除触发器</h4><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86/notes-dbms/image-20230610200404711.png" class title="image-20230610200404711"><h2 id="chap6-关系数据理论">chap6 关系数据理论</h2><h3 id="1NF">1NF</h3><p>First Normal Form</p><p>通俗理解</p><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86/notes-dbms/image-20230610213750498.png" class title="image-20230610213750498"><blockquote><p>虽然chatgpt说理解为“表中有表”并不完全正确</p></blockquote><h3 id="数据依赖">数据依赖</h3><p>有很多类型</p><p>主要是<strong>函数依赖</strong>和<strong>多值依赖</strong></p><h3 id="函数依赖-FD-Function-Dependency">函数依赖 FD Function Dependency</h3><p>很字面的意思，就是像y=fx一样，y由x决定</p><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86/notes-dbms/image-20230610214138860.png" class title="image-20230610214138860"><h3 id="1NF：F的表示">1NF：F的表示</h3><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86/notes-dbms/image-20230610214809590.png" class title="image-20230610214809590"><h3 id="范式">范式</h3><p>模式分解</p><p>规范化</p><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86/notes-dbms/image-20230610215237850.png" class title="image-20230610215237850"><h3 id="函数依赖的标准定义">函数依赖的标准定义</h3><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86/notes-dbms/image-20230610222733548.png" class title="image-20230610222733548"><blockquote><p>简单说就是X一样，Y一定一样，所以X-&gt;Y</p><p>X 函数确定 Y</p><p>Y 函数依赖于 X</p></blockquote><h3 id="平凡函数依赖与非平凡函数依赖">平凡函数依赖与非平凡函数依赖</h3><p>关键在于Y是否被包含于X</p><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86/notes-dbms/image-20230610223048974.png" class title="image-20230610223048974"><blockquote><p>显然平凡函数依赖没什么意义</p></blockquote><h3 id="完全函数依赖和部分函数依赖">完全函数依赖和部分函数依赖</h3><p>看例子就懂意思了，定义削微有点晦涩</p><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86/notes-dbms/image-20230610223748591.png" class title="image-20230610223748591"><h3 id="传递函数依赖">传递函数依赖</h3><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86/notes-dbms/image-20230610224944849.png" class title="image-20230610224944849"><p>Y非平凡依赖于X，Z非平凡依赖于Y，同时X不依赖与Y（否则Z就直接函数依赖于X了）</p><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86/notes-dbms/image-20230614220209386.png" class title="image-20230614220209386"> <h3 id="码">码</h3><blockquote><p>书P181：</p><p>在后面的章节中<strong>主码</strong>或<strong>候选码</strong>都简称为<strong>码</strong></p><p>书上这段文字很清晰</p></blockquote><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86/notes-dbms/image-20230610230200735.png" class title="image-20230610230200735"><h3 id="外码-2">外码</h3><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86/notes-dbms/image-20230610232027629.png" class title="image-20230610232027629"><h3 id="1NF-2">1NF</h3><p>关系数据库的最基本要求</p><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86/notes-dbms/image-20230610232142373.png" class title="image-20230610232142373"><h3 id="2NF">2NF</h3><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86/notes-dbms/image-20230610232505906.png" class title="image-20230610232505906"><style>.aeolkwsfifxm{zoom:50%;}</style><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86/notes-dbms/image-20230614220229006.png" class="aeolkwsfifxm" alt="image-20230614220229006"> <blockquote><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86/notes-dbms/image-20230610232940543.png" class title="image-20230610232940543"></blockquote><p>1NF + 没有非主属性对码的部分依赖</p><h3 id="分解成2NF">分解成2NF</h3><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86/notes-dbms/image-20230610233628746.png" class title="image-20230610233628746"><h3 id="3NF">3NF</h3><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86/notes-dbms/image-20230610233812701.png" class title="image-20230610233812701"><blockquote><p>为什么不分解成S(Student)-D(Department)和S-L？这样会使得函数依赖关系丢失？不太好</p></blockquote><blockquote><p>消除了非主属性对码的传递函数依赖</p><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86/notes-dbms/image-20230610233955791.png" class title="image-20230610233955791"><p>辨析</p><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86/notes-dbms/image-20230610234017147.png" class title="image-20230610234017147"></blockquote><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86/notes-dbms/image-20230611223918842.png" class title="image-20230611223918842"><h3 id="1NF-2NF-3NF-依赖关系图对比">1NF 2NF 3NF 依赖关系图对比</h3><p>看图更容易判断</p><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86/notes-dbms/image-20230611103438269.png" class title="image-20230611103438269"><p>存在非主属性对码的<strong>部分函数依赖</strong>，所以不是2NF</p><p>也有非主属性对码的<strong>传递函数依赖</strong>，所以不是3NF</p><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86/notes-dbms/image-20230611103720282.png" class title="image-20230611103720282"><p>存在非主属性对码的<strong>传递函数依赖</strong>，所以不是3NF</p><h3 id="BCNF-Boyce-Codd-NF">BCNF Boyce Codd NF</h3><p>修正的第三范式，扩充的第三范式</p><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86/notes-dbms/image-20230611104036019.png" class title="image-20230611104036019"><p>决定属性集就是指X</p><p>1NF + 所有决定属性集都包含候选码/没有主属性对码的部分和传递依赖</p><h3 id="BCNF：消除了插入异常和删除异常">BCNF：消除了<strong>插入异常</strong>和<strong>删除异常</strong></h3><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86/notes-dbms/image-20230611104712457.png" class title="image-20230611104712457"><h3 id="BCNF与3NF">BCNF与3NF</h3><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86/notes-dbms/image-20230611105330946.png" class title="image-20230611105330946"><h3 id="多值依赖">多值依赖</h3><p>简单看了下</p><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86/notes-dbms/image-20230611110509370.png" class title="image-20230611110509370"><h4 id="例子：">例子：</h4><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86/notes-dbms/image-20230611110559465.png" class title="image-20230611110559465"><h2 id="chap7-数据库设计">chap7 数据库设计</h2><h3 id="数据库设计6个阶段">数据库设计6个阶段</h3><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86/notes-dbms/image-20230611125725981.png" class title="image-20230611125725981"><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86/notes-dbms/image-20230611125829451.png" class title="image-20230611125829451"><h3 id="各级模式">各级模式</h3><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86/notes-dbms/image-20230611130015952.png" class title="image-20230611130015952"><h3 id="需求分析">需求分析</h3><h4 id="需求分析过程">需求分析过程</h4><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86/notes-dbms/image-20230611140356001.png" class title="image-20230611140356001"><h3 id="数据字典">数据字典</h3><blockquote><p>注意区分之前的“数据字典”</p></blockquote><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86/notes-dbms/image-20230611141116947.png" class title="image-20230611141116947"><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86/notes-dbms/image-20230611141055207.png" class title="image-20230611141055207"><h3 id="需求分析小结">需求分析小结</h3><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86/notes-dbms/image-20230611141343015.png" class title="image-20230611141343015"><h3 id="概念模型">概念模型</h3><p>真实反映现实世界，易于理解，可以用于和不熟悉计算机的用户交换意见</p><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86/notes-dbms/image-20230611142343528.png" class title="image-20230611142343528"><blockquote><p>1.2.2节 概念模型</p><p>实体：学生</p><p>属性：学号、姓名</p><p>码：学号</p><p>实体型：实体名+属性名集合，如<code>学生（学号，姓名）</code></p><p>实体集：全体学生</p><p>联系：</p><p>概念模型的一种表示方法：实体E-联系R方法 <strong>E-R方法</strong> <strong>使用 E-R图</strong></p></blockquote><h3 id="联系-Relation">联系 Relation</h3><h4 id="两个实体性之间">两个实体性之间</h4><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86/notes-dbms/image-20230611143648711.png" class title="image-20230611143648711"><h4 id="两个以上实体型之间">两个以上实体型之间</h4><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86/notes-dbms/image-20230611143708189.png" class title="image-20230611143708189"><h4 id="单个实体型内部">单个实体型内部</h4><p>员工之间存在领导和被领导的关系</p><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86/notes-dbms/image-20230611145518615.png" class title="image-20230611145518615"><h3 id="联系的度">联系的度</h3><p>几个实体型就是几元联系</p><h3 id="E-R图">E-R图</h3><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86/notes-dbms/image-20230611151855601.png" class title="image-20230611151855601"><h4 id="联系也可以有属性">联系也可以有属性</h4><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86/notes-dbms/image-20230611151917472.png" class title="image-20230611151917472"><h3 id="ISA联系">ISA联系</h3><p>三角形，代表继承父类所有属性，并且子类可以有自己的属性</p><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86/notes-dbms/image-20230611152520080.png" class title="image-20230611152520080"><h4 id="分类属性">分类属性</h4><p>比如学生类别</p><p>可用于进行实体分派</p><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86/notes-dbms/image-20230611152639167.png" class title="image-20230611152639167"><h4 id="不相交-可重叠约束">不相交/可重叠约束</h4><p>既是，又是</p><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86/notes-dbms/image-20230611152826795.png" class title="image-20230611152826795"><p>能否属于子类中的过多个实体集</p><h4 id="完备性约束：是否必须是其中之一？">完备性约束：是否必须是其中之一？</h4><p>要么是，要么是</p><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86/notes-dbms/image-20230611152914464.png" class title="image-20230611152914464"><h4 id="基数约束">基数约束</h4><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86/notes-dbms/image-20230611153052561.png" class title="image-20230611153052561"><p>左到右 学生 可以选修 20-30门 课程</p><p>右到左 课程 可以<strong>被</strong>0-*个学生选修</p><h4 id="Part-Of-联系">Part Of 联系</h4><p>非独占(的Part Of)联系：整体实体如果被破坏，另一部分实体仍然可以独立存在</p><p>独占(的Part Of)联系：整体实体如果被破坏，部分实体不能存在**（整体没了，部分就没了）**</p><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86/notes-dbms/image-20230611153716106.png" class title="image-20230611153716106"><h3 id="概念结构设计的方法">概念结构设计的方法</h3><blockquote><p>这部分书上没有？</p></blockquote><p>自顶向下：先全局概念结构</p><p>自底向上：先子需求</p><p>逐步扩张</p><p>混合策略</p><h3 id="自底向上的概念结构设计的步骤">自底向上的概念结构设计的步骤</h3><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86/notes-dbms/image-20230611154352614.png" class title="image-20230611154352614"><h3 id="实体与属性的划分原则">实体与属性的划分原则</h3><ul><li><p>属性不可再有属性</p></li><li><p>属性不能再与其他实体有联系</p></li></ul><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86/notes-dbms/image-20230611154431578.png" class title="image-20230611154431578"><h4 id="例子：职工和职称">例子：职工和职称</h4><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86/notes-dbms/image-20230611154533909.png" class title="image-20230611154533909"><blockquote><p>ppt有好多例子</p></blockquote><h3 id="E-R图的集成">E-R图的集成</h3><p>合并 + 重构去除冗余</p><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86/notes-dbms/image-20230611155101043.png" class title="image-20230611155101043"><h3 id="三类冲突">三类冲突</h3><p>1属性冲突：整数类型和字符串类型，单位冲突</p><p>2命名冲突：同名异义，异名同义（一义多名）</p><blockquote><p>讨论协商解决</p></blockquote><h4 id="3结构冲突">3结构冲突</h4><p>合并</p><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86/notes-dbms/image-20230611155606670.png" class title="image-20230611155606670"><h3 id="E-R图集成之二：修改和重构">E-R图集成之二：修改和重构</h3><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86/notes-dbms/image-20230611155826245.png" class title="image-20230611155826245"><h3 id="第三步：逻辑结构设计">第三步：逻辑结构设计</h3><h4 id="任务">任务</h4><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86/notes-dbms/image-20230611160014880.png" class title="image-20230611160014880"><h4 id="转换">转换</h4><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86/notes-dbms/image-20230611160227449.png" class title="image-20230611160227449"><h4 id="对于实体型">对于实体型</h4><p>很直接的转换</p><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86/notes-dbms/image-20230611160359028.png" class title="image-20230611160359028"><h4 id="对于联系">对于联系</h4><p>• 一个 1 ∶ 1 联系可以转换为一个独立的关系模式，也可以与任意一端对应的关系模式合并</p><p>• 一个 1 ∶ 𝑛 联系可以转换为一个独立的关系模式，也可以与 𝑛 端对应的关系模式合并</p><p>• 一个 𝑚 ∶ 𝑛 联系转换为一个关系模式，与该联系相连的各实体部分的码以及联系本身的属性均转换为关系的属性，各实体的码组成关系的码或关系码的一部分</p><p>• 三个或三个以上实体间的一个多元联系转换为一个关系模式</p><p>• 具有相同码的关系模式可合并</p><h3 id="数据模型的优化">数据模型的优化</h3><p>关系数据模型的优化通常以<strong>规范化理论</strong>为指导，方法为：</p><ul><li><p>确定数据依赖</p></li><li><p>对于各个关系模式之间的数据依赖进行极小化处理，消除冗余的联系</p></li><li><p>按照数据依赖的理论对关系模式进行分析，考察是否存在部分函数依赖、传递函数依赖、多值依赖等，确定各关系模式分别属于第几范式</p></li><li><p>按照需求分析阶段得到的各种应用对数据处理的要求，分析对于这样的应用环境这些模式是否合适，确定是否要对它们进行合并或分解</p></li><li><p>对关系模式进行必要<strong>分解</strong>，提高数据操作效率和存储空间的利用率</p></li></ul><h4 id="并不是规范化程度越高的关系就越优">并不是规范化程度越高的关系就越优</h4><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86/notes-dbms/image-20230611162121086.png" class title="image-20230611162121086"><h3 id="关系模式的分解">关系模式的分解</h3><h4 id="水平分解">水平分解</h4><p>元组分解，例如分解出经常用的</p><p>80/20原则</p><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86/notes-dbms/image-20230611162252101.png" class title="image-20230611162252101"><h4 id="垂直分解">垂直分解</h4><p>对常用属性分解</p><p>风险是可能有时必须进行连接操作了</p><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86/notes-dbms/image-20230611162404663.png" class title="image-20230611162404663"><h3 id="设计用户子模式">设计用户子模式</h3><p>应该还是自底向上设计过程中的一部分</p><p>现在已经有全局逻辑模型了</p><p>现在是根据局部需求，设计用户的外模式</p><p>但应该还是处于<code>逻辑结构设计</code>的部分</p><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86/notes-dbms/image-20230611163854720.png" class title="image-20230611163854720"><p>别名、视图、简化使用</p><h3 id="第四步：物理结构设计">第四步：物理结构设计</h3><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86/notes-dbms/image-20230611165012425.png" class title="image-20230611165012425"><h4 id="存取方法的选择">存取方法的选择</h4><h5 id="B-树索引存取">B+树索引存取</h5><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86/notes-dbms/image-20230611165346315.png" class title="image-20230611165346315"><h5 id="Hash索引存取">Hash索引存取</h5><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86/notes-dbms/image-20230611165525925.png" class title="image-20230611165525925"><h5 id="聚簇存取">聚簇存取</h5><p>Cluster</p><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86/notes-dbms/image-20230611165649840.png" class title="image-20230611165649840"><h5 id="例如：">例如：</h5><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86/notes-dbms/image-20230611165721350.png" class title="image-20230611165721350"><h5 id="聚簇存取方法的选择">聚簇存取方法的选择</h5><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86/notes-dbms/image-20230611165937973.png" class title="image-20230611165937973"><h3 id="数据库的重组织">数据库的重组织</h3><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86/notes-dbms/image-20230611170318483.png" class title="image-20230611170318483"><h3 id="数据库的重构造">数据库的重构造</h3><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86/notes-dbms/image-20230611170410197.png" class title="image-20230611170410197"><h2 id="chap8-数据库编程">chap8 数据库编程</h2><h3 id="JDBC驱动">JDBC驱动</h3><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86/notes-dbms/image-20230611170906433.png" class title="image-20230611170906433"><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86/notes-dbms/image-20230611170913063.png" class title="image-20230611170913063"><blockquote><p>可以看某次实验的代码</p></blockquote><h3 id="过程化SQL">过程化SQL</h3><p>SQL的扩展</p><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86/notes-dbms/image-20230611171635704.png" class title="image-20230611171635704"><blockquote><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86/notes-dbms/image-20230611172133121.png" class title="image-20230611172133121"></blockquote><h3 id="游标">游标</h3><p>类似于指针吧</p><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86/notes-dbms/image-20230611172712784.png" class title="image-20230611172712784"><h3 id="SQL块的概念">SQL块的概念</h3><p>主要就是两种</p><p>命名块有名字，能存储在数据库中供调用</p><p><code>过程</code>和<code>函数</code>的区别在于函数必须制定返回的类型</p><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86/notes-dbms/image-20230611172739476.png" class title="image-20230611172739476"><blockquote><p>没太懂存储过程和过程的区别在哪</p></blockquote><h2 id="chap10-数据库恢复技术">chap10 数据库恢复技术</h2><h3 id="事务Transaction">事务Transaction</h3><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86/notes-dbms/image-20230612134242791.png" class title="image-20230612134242791"><h3 id="ACID特性">ACID特性</h3><p>事物的ACID特性：</p><p><strong>原子性Atomicity</strong>：事务是数据库的逻辑工作单位，事务中包括的诸操作要么都做，要么都不做</p><p><strong>一致性Consistency</strong>：</p><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86/notes-dbms/image-20230612142553431.png" class title="image-20230612142553431"><p><strong>隔离性Isolation</strong>：</p><p>隔离性是指多个并发事务同时运行时，每个事务都被隔离并互不干扰的特性。</p><p>隔离性确保了并发事务之间的独立性，以防止出现干扰、数据损坏或不一致的情况。当多个事务同时访问和修改数据库时，隔离性保证每个事务都感觉不到其他事务的存在，就好像它们是按顺序执行的一样。这意味着每个事务将以一种隔离的方式运行，不会受到其他事务的干扰。</p><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86/notes-dbms/image-20230612142813057.png" class title="image-20230612142813057"><p><strong>持续性Durability</strong>：</p><p>也称永久性</p><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86/notes-dbms/image-20230612142843495.png" class title="image-20230612142843495"><h3 id="恢复子系统">恢复子系统</h3><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86/notes-dbms/image-20230612143003438.png" class title="image-20230612143003438"><h3 id="故障的种类">故障的种类</h3><h4 id="故障1-事务内部的故障">故障1-事务内部的故障</h4><p>非预期的</p><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86/notes-dbms/image-20230612143237450.png" class title="image-20230612143237450"><p>恢复操作是进行<strong>事务撤销（UNDO）</strong>，即强行回滚事务</p><h4 id="故障2-系统故障">故障2-系统故障</h4><p>又称为“软故障”</p><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86/notes-dbms/image-20230612143414907.png" class title="image-20230612143414907"><h5 id="恢复">恢复</h5><p>既要UNDO，又要REDO</p><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86/notes-dbms/image-20230612143549455.png" class title="image-20230612143549455"><h4 id="故障3-介质故障">故障3-介质故障</h4><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86/notes-dbms/image-20230612143752017.png" class title="image-20230612143752017"><h4 id="故障4-计算机病毒">故障4-计算机病毒</h4><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86/notes-dbms/image-20230612143825578.png" class title="image-20230612143825578"><h3 id="恢复的基本原理">恢复的基本原理</h3><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86/notes-dbms/image-20230612143917410.png" class title="image-20230612143917410"><h3 id="数据转储">数据转储</h3><p>简单说就是定期保存下</p><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86/notes-dbms/image-20230612153437885.png" class title="image-20230612153437885"><h4 id="转储方法1-静态转储">转储方法1-静态转储</h4><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86/notes-dbms/image-20230612153605130.png" class title="image-20230612153605130"><h4 id="转储方法2-动态转储">转储方法2-动态转储</h4><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86/notes-dbms/image-20230612153732379.png" class title="image-20230612153732379"><h3 id="转储分类2-海量与增量">转储分类2-海量与增量</h3><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86/notes-dbms/image-20230612153832744.png" class title="image-20230612153832744"><blockquote><p>所以排列组合后一共可以有4种转储方式</p></blockquote><h3 id="日志文件">日志文件</h3><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86/notes-dbms/image-20230612154302917.png" class title="image-20230612154302917"><blockquote><p>协助动态转储的后备副本进行数据库恢复至某一正确状态</p></blockquote><h4 id="以记录为单位的日志文件">以记录为单位的日志文件</h4><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86/notes-dbms/image-20230612154629419.png" class title="image-20230612154629419"><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86/notes-dbms/image-20230612154646743.png" class title="image-20230612154646743"><h4 id="以数据块为单位的日志文件">以数据块为单位的日志文件</h4><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86/notes-dbms/image-20230612154857301.png" class title="image-20230612154857301"><blockquote><p>均要记录事务标识</p></blockquote><h3 id="日志文件的作用">日志文件的作用</h3><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86/notes-dbms/image-20230612155105439.png" class title="image-20230612155105439"><blockquote><p>最后一点的意思是不需要运行<strong>程序</strong>，直接根据日志文件记录的一步步操作即可</p></blockquote><h3 id="先日志，后改数据库">先日志，后改数据库</h3><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86/notes-dbms/image-20230612155244493.png" class title="image-20230612155244493"><h4 id="原因">原因</h4><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86/notes-dbms/image-20230612155328096.png" class title="image-20230612155328096"><h3 id="恢复策略">恢复策略</h3><h4 id="事务故障的恢复">事务故障的恢复</h4><p>事务故障是指未正常运行到commit或者rollback</p><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86/notes-dbms/image-20230612155835375.png" class title="image-20230612155835375"><h4 id="事务故障的恢复步骤">事务故障的恢复步骤</h4><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86/notes-dbms/image-20230612160125271.png" class title="image-20230612160125271"><blockquote><p>细读这段可以明白究竟日志文件里面记了些什么</p><p>反正开始结束标志肯定记了，然后每个事物都有ID（事务标识），然后有增删改查的操作就记一条（所谓的更新操作，这种记录就会包括上面讲的五个部分）</p><p>反向扫描</p></blockquote><h4 id="系统故障的恢复">系统故障的恢复</h4><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86/notes-dbms/image-20230612160525864.png" class title="image-20230612160525864"><h4 id="系统故障的恢复步骤">系统故障的恢复步骤</h4><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86/notes-dbms/image-20230612160604161.png" class title="image-20230612160604161"><h4 id="介质故障的恢复">介质故障的恢复</h4><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86/notes-dbms/image-20230612160754358.png" class title="image-20230612160754358"><h4 id="介质故障的恢复步骤">介质故障的恢复步骤</h4><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86/notes-dbms/image-20230612160854540.png" class title="image-20230612160854540"><h3 id="检查点技术">检查点技术</h3><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86/notes-dbms/image-20230612161347266.png" class title="image-20230612161347266"><h3 id="日志文件加入检查点记录">日志文件加入检查点记录</h3><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86/notes-dbms/image-20230612161458253.png" class title="image-20230612161458253"><h3 id="采取的策略">采取的策略</h3><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86/notes-dbms/image-20230612161514500.png" class title="image-20230612161514500"><blockquote><p>为什么T1不用重做？有没有可能他的数据还在缓冲区？</p><p>没有可能，这正是检查点的作用</p><p>因为在“动态维护日志文件”中，有一个步骤是“将当前数据缓冲区的所有数据记录写入磁盘的数据库中”</p><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86/notes-dbms/image-20230612161704463.png" class title="image-20230612161704463"></blockquote><h3 id="数据库镜像">数据库镜像</h3><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86/notes-dbms/image-20230612161837298.png" class title="image-20230612161837298"><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86/notes-dbms/image-20230612161847115.png" class title="image-20230612161847115"><blockquote><p>有故障时可救火，没故障时还可并发</p></blockquote><h4 id="并不对整个数据库进行镜像">并不对整个数据库进行镜像</h4><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86/notes-dbms/image-20230612161940076.png" class title="image-20230612161940076"><h2 id="chap11-并发控制">chap11 并发控制</h2><p>串行、交叉并行、同时并行</p><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86/notes-dbms/image-20230612162828851.png" class title="image-20230612162828851"><blockquote><p>事务是并发控制的基本单位</p></blockquote><h3 id="并发操作带来的数据不一致性">并发操作带来的数据不一致性</h3><h4 id="1-丢失修改">1.丢失修改</h4><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86/notes-dbms/image-20230612162958300.png" class title="image-20230612162958300"><h4 id="2-不可重复读"><strong>2.不可重复读</strong></h4><p>有好几种</p><p>还有幻影现象Phantom Row</p><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86/notes-dbms/image-20230612163220847.png" class title="image-20230612163220847"><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86/notes-dbms/image-20230612163102314.png" class title="image-20230612163102314"><h4 id="3-读-脏-数据">3.读&quot;脏&quot;数据</h4><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86/notes-dbms/image-20230612163335089.png" class title="image-20230612163335089"><p>原本的修改事务被撤销了，读到了脏数据</p><h3 id="并发控制的主要技术">并发控制的主要技术</h3><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86/notes-dbms/image-20230612163452173.png" class title="image-20230612163452173"><h3 id="封锁">封锁</h3><p>排它锁：写锁，只能上锁者读写</p><p>共享锁：读锁，自己只能读，保证别人不能改</p><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86/notes-dbms/image-20230612165226372.png" class title="image-20230612165226372"><h3 id="封锁协议">封锁协议</h3><h4 id="一级封锁协议">一级封锁协议</h4><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86/notes-dbms/image-20230612170010908.png" class title="image-20230612170010908"><p>因为一定在T改完后</p><p>别人才能读或者写，所以不会丢失修改</p><h4 id="二级封锁协议"><strong>二级封锁协议</strong></h4><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86/notes-dbms/image-20230612170120631.png" class title="image-20230612170120631"><h4 id="三级封锁协议"><strong>三级封锁协议</strong></h4><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86/notes-dbms/image-20230612170250578.png" class title="image-20230612170250578"><h4 id="小结">小结</h4><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86/notes-dbms/image-20230612170302699.png" class title="image-20230612170302699"><blockquote><p>不可重复读的理解：</p><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86/notes-dbms/image-20230612170442391.png" class title="image-20230612170442391"></blockquote><h3 id="活锁">活锁</h3><p>意思就是有个怨种一直没轮到，一直在等</p><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86/notes-dbms/image-20230612172602170.png" class title="image-20230612172602170"><h4 id="如何避免">如何避免</h4><p>FCFS</p><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86/notes-dbms/image-20230612172617900.png" class title="image-20230612172617900"><h3 id="死锁">死锁</h3><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86/notes-dbms/image-20230612173202725.png" class title="image-20230612173202725"><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86/notes-dbms/image-20230612173139839.png" class title="image-20230612173139839"><h4 id="死锁的预防">死锁的预防</h4><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86/notes-dbms/image-20230612174053238.png" class title="image-20230612174053238"><h4 id="死锁的诊断">死锁的诊断</h4><p>超时法：可能误判</p><p>等待图法</p><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86/notes-dbms/image-20230612174206336.png" class title="image-20230612174206336"><h4 id="等待图法">等待图法</h4><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86/notes-dbms/image-20230612174252132.png" class title="image-20230612174252132"><h3 id="解除死锁">解除死锁</h3><p>选择处理代价最小的事务，将其撤销</p><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86/notes-dbms/image-20230612174324233.png" class title="image-20230612174324233"><h3 id="可串行调度">可串行调度</h3><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86/notes-dbms/image-20230612184556826.png" class title="image-20230612184556826"><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86/notes-dbms/image-20230612185725296.png" class title="image-20230612185725296"><h3 id="冲突可串行化：给出一个判断课串行化的充分条件">冲突可串行化：给出一个判断课串行化的充分条件</h3><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86/notes-dbms/image-20230612185846853.png" class title="image-20230612185846853"><h3 id="充分条件">充分条件</h3><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86/notes-dbms/image-20230612190015596.png" class title="image-20230612190015596"><h3 id="例子-3">例子</h3><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86/notes-dbms/image-20230612190041353.png" class title="image-20230612190041353"><h3 id="两段锁协议2PL">两段锁协议2PL</h3><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86/notes-dbms/image-20230612190423127.png" class title="image-20230612190423127"><p>就是对事务来说，所有获取锁的操作都在释放锁之前</p><h3 id="扩展阶段和收缩阶段">扩展阶段和收缩阶段</h3><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86/notes-dbms/image-20230612190524530.png" class title="image-20230612190524530"><h3 id="遵循2PL协议：又一个可串行化的充分条件">遵循2PL协议：又一个可串行化的充分条件</h3><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86/notes-dbms/image-20230612190649405.png" class title="image-20230612190649405"><h3 id="一次封锁法-vs-2PL协议">一次封锁法 vs 2PL协议</h3><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86/notes-dbms/image-20230612190741530.png" class title="image-20230612190741530"><p>例如</p><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86/notes-dbms/image-20230612190757867.png" class title="image-20230612190757867"><h3 id="封锁粒度">封锁粒度</h3><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86/notes-dbms/image-20230612191103318.png" class title="image-20230612191103318"><h3 id="选择封锁粒度原则"><strong>选择封锁粒度原则</strong></h3><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86/notes-dbms/image-20230612191131578.png" class title="image-20230612191131578"><h3 id="多粒度树">多粒度树</h3><h3 id="多粒度协议">多粒度协议</h3><h3 id="显示封锁与隐式封锁">显示封锁与隐式封锁</h3><h3 id="引进意向锁的目的Intention-Lock">引进意向锁的目的Intention Lock</h3><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86/notes-dbms/image-20230612191438951.png" class title="image-20230612191438951"><blockquote><p>注意，上层所有节点都要加上意向锁</p></blockquote><h3 id="意向共享锁IS">意向共享锁IS</h3><h3 id="意向排它锁IX">意向排它锁IX</h3><h3 id="共享意向排它锁SIX">共享意向排它锁SIX</h3><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86/notes-dbms/image-20230612191647028.png" class title="image-20230612191647028"><blockquote><p>表达的是，要读这个节点，并且可能修改子节点</p></blockquote><h3 id="意向锁提高了加锁时的检查效率">意向锁提高了加锁时的检查效率</h3><blockquote><p>因为不用往下检查了</p></blockquote><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86/notes-dbms/image-20230612191853109.png" class title="image-20230612191853109"><blockquote><p>例子：</p><p>意向锁的作用，相当于就是在低层次资源是否使用，加了一个tag来标识而已。对于步骤2的执行可以大大加速，仅此而已。</p><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86/notes-dbms/image-20230612192429335.png" class title="image-20230612192429335"><p><a class="link" href="https://blog.csdn.net/dreamvyps/article/details/84500543">(1条消息) 意向锁的作用_werflychen的博客-CSDN博客 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p></blockquote><h3 id="意向锁的相容矩阵">意向锁的相容矩阵</h3><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86/notes-dbms/image-20230612192552557.png" class title="image-20230612192552557"><blockquote><p>意向锁之间，只有互相带X的不兼容</p></blockquote><h2 id="NoSQL">NoSQL</h2><h3 id="阻抗失谐">阻抗失谐</h3><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86/notes-dbms/image-20230612201130858.png" class title="image-20230612201130858"><h3 id="集群问题">集群问题</h3><p>关系型数据库不适合集群，大规模的数据</p><p>涉及分片和复制，但关系型数据库本身其实没有这些概念</p><p>所以NoSQL要更加适合集群，有的NoSQL就是分布式的</p><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86/notes-dbms/image-20230612204205658.png" class title="image-20230612204205658"><h3 id="特点">特点</h3><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86/notes-dbms/image-20230612201752496.png" class title="image-20230612201752496"><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86/notes-dbms/image-20230612204327913.png" class title="image-20230612204327913"><blockquote><p>无模式，上课举了不同宠物有不同的描述属性的例子</p><p>有点类似于面向对象的感觉</p><p>比如A有属性A1 A2</p><p>B可以有B1 B2 B3 B4</p><p>不需要每个都有相同的属性列</p></blockquote><h3 id="聚合：名词而非动词">聚合：名词而非动词</h3><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86/notes-dbms/image-20230612202818656.png" class title="image-20230612202818656"><h3 id="NoSQL特点：无模式">NoSQL特点：无模式</h3><p><img lazyload src="/images/loading.svg" data-src="../../../NJUer-dsy/2023-Spring/Devens_Yuan/%25E6%2595%25B0%25E6%258D%25AE%25E7%25AE%25A1%25E7%2590%2586%25E5%259F%25BA%25E7%25A1%2580-dsy/%25E6%2595%25B0%25E6%258D%25AE%25E7%25AE%25A1%25E7%2590%2586%25E5%259F%25BA%25E7%25A1%2580%25E6%259C%259F%25E6%259C%25AB%25E5%25A4%258D%25E4%25B9%25A0-dsy/%25E8%25AF%25BB%25E4%25B9%25A6%25E5%25A4%258D%25E4%25B9%25A0%25E7%25AC%2594%25E8%25AE%25B0/image-20230612205211355.png" alt="image-20230612205211355"></p><h3 id="格式不一致的数据">格式不一致的数据</h3><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86/notes-dbms/image-20230612205304934.png" class title="image-20230612205304934"><blockquote><p>直接看看这两篇文章</p><p><a class="link" href="https://blog.csdn.net/Foools/article/details/120205655">《NoSQL精粹》了解NoSQL这一篇就够了_Foools的博客-CSDN博客 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>这篇全一点，但错别字有点多</p><p><a class="link" href="https://blog.csdn.net/qq_27250279/article/details/129234918">NoSQL精粹笔记-概念_面向聚合数据库_平平无奇的小颜的博客-CSDN博客 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p></blockquote><h3 id="CAP定理">CAP定理</h3><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86/notes-dbms/image-20230612221537514.png" class title="image-20230612221537514"><h3 id="BASE属性">BASE属性</h3><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86/notes-dbms/image-20230612221630548.png" class title="image-20230612221630548"><h2 id="做题记录">做题记录</h2><h3 id="如何判断码">如何判断码</h3><style>.oavudszmrdut{zoom: 50%;}</style><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86/notes-dbms/image-20230611233327926.png" class="oavudszmrdut" alt="image-20230611233327926"> <p>R型没什么写的必要，写出L和LR型就够了</p><p>先求所有L型的闭包，不够再LR型一个个加进去</p><blockquote><p>对于判断迷茫了可以看看P203第6题</p><img lazyload src="/images/loading.svg" data-src="/posts/2023-Spring-Courses-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86/notes-dbms/image-20230611233533751.png" class title="image-20230611233533751"></blockquote>]]></content>
      
      
      <categories>
          
          <category> 2023-Spring-Courses-数据库管理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hw2学习记录</title>
      <link href="/posts/23-Spring-Courses-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/hw2%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95.html"/>
      <url>/posts/23-Spring-Courses-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/hw2%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95.html</url>
      
        <content type="html"><![CDATA[<h1>P1</h1><h3 id="电梯调度算法">电梯调度算法</h3><img lazyload src="/images/loading.svg" data-src="/posts/23-Spring-Courses-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/hw2%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20230530152123129.png" class title="image-20230530152123129"><p>简单说明下</p><h4 id="SCAN">SCAN</h4><p>扫到头就换方向扫，所以是双向的</p><h4 id="C-SCAN">C-SCAN</h4><p>扫到头就回到起始点，期间不扫描，所以是单向的</p><p>只会按照一个方向</p><h4 id="LOOK">LOOK</h4><p>扫到最左/右的请求就换方向扫，双向</p><h4 id="C-LOOK">C-LOOK</h4><p>单向的，同理</p><h1>P2</h1><h3 id="位示图">位示图</h3><p>每个磁盘块都对应位示图上的一位，位的状态可以是0或1，表示该磁盘块是否已被占用或空闲</p><img lazyload src="/images/loading.svg" data-src="/posts/23-Spring-Courses-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/hw2%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20230530163816669.png" class title="image-20230530163816669"><h1>P3</h1><img lazyload src="/images/loading.svg" data-src="/posts/23-Spring-Courses-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/hw2%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20230530170510167.png" class title="image-20230530170510167"><h1>P5</h1><h3 id="PV操作原语">PV操作原语</h3><img lazyload src="/images/loading.svg" data-src="/posts/23-Spring-Courses-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/hw2%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20230530232905494.png" class title="image-20230530232905494"><p>牢记！</p><h3 id="并发进程的无关性：Bernstein条件">并发进程的无关性：Bernstein条件</h3><img lazyload src="/images/loading.svg" data-src="/posts/23-Spring-Courses-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/hw2%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20230531111311817.png" class title="image-20230531111311817"><p>其实感觉3、7语句无关肉眼也能看出来吧其实，不用这个什么条件算也行</p><p>PV操作其实就是在做一定量的同步</p><p>P（S1)想要继续执行下去，一定是V（S1）执行之后才行</p><h1>P10 银行家算法</h1><p>看看视频（<a class="link" href="https://www.bilibili.com/video/BV1rJ411p7au/">操作系统-银行家算法_哔哩哔哩_bilibili <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>）+书 就行了</p>]]></content>
      
      
      <categories>
          
          <category> 23-Spring-Courses-操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> homework </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软工二第一次代码作业</title>
      <link href="/posts/2023-Spring-Courses-%E8%BD%AF%E5%B7%A5%E4%BA%8C/%E8%BD%AF%E5%B7%A5%E4%BA%8C%E7%AC%AC%E4%B8%80%E6%AC%A1%E4%BB%A3%E7%A0%81%E4%BD%9C%E4%B8%9A.html"/>
      <url>/posts/2023-Spring-Courses-%E8%BD%AF%E5%B7%A5%E4%BA%8C/%E8%BD%AF%E5%B7%A5%E4%BA%8C%E7%AC%AC%E4%B8%80%E6%AC%A1%E4%BB%A3%E7%A0%81%E4%BD%9C%E4%B8%9A.html</url>
      
        <content type="html"><![CDATA[<h2 id="什么是kwic">什么是kwic?</h2><p>KWIC是&quot;Keyword in Context&quot;（关键词上下文）的缩写。 KWIC是一种文本分析方法，用于提取文本中的关键词并在其周围显示一定数量的上下文信息。这通常被用于索引和搜索系统中的文本数据，以便用户可以快速找到与其关注的关键词相关的文本。KWIC索引通常显示在一个表格或网格中，其中每一行都是一个关键词及其周围的文本片段，让用户可以快速浏览文本内容，快速找到感兴趣的信息。</p><blockquote><p>貌似还有些相关网站？</p><p><a class="link" href="https://www.bilibili.com/video/BV1Ke4y1i7jb/?spm_id_from=333.337.search-card.all.click&amp;vd_source=6be38b36e75fc2dd932ed882233a8a39">语料库网站介绍之KWiC Finder_哔哩哔哩_bilibili <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p><p><a class="link" href="http://kwicfinder.com/KWiCFinder.html">KWiCFinder Web Concordancer &amp; Online Research Tool <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p></blockquote><br><h2 id="直接看点资料">直接看点资料</h2><blockquote><p><a class="link" href="https://www.cnblogs.com/youxin/p/3514594.html">软件体系结构经典问题——KWIC的分析和解决 - youxin - 博客园 (cnblogs.com) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p><p>含代码：<a class="link" href="https://blog.csdn.net/weixin_43853097/article/details/110943379">主程序-子程序、面向对象、事件系统和管道-过滤软件体系结构实现KWIC_Himit_ZH的博客-CSDN博客 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p></blockquote><h3 id="要做什么？">要做什么？</h3><p>**问题陈述：**KWIC(Key Word In Context)，Parnas (1972)</p><p>KWIC索引系统接受一些行，每行有若干字，每个字由若干字符组成；每行都可以循环移位，亦即重复地把第一个字删除，然后接到行末； KWIC把所有行的各种移位情况按照字母表顺序输出</p><p><strong>例子如下：</strong></p><p><img lazyload src="/images/loading.svg" data-src="https://s2.loli.net/2023/04/30/MlSmV6HC58NPLhD.png" alt="image-20230430220928676"></p><blockquote><p>原来的还是要输出的，所以一共3+2+3=8个</p></blockquote><h2 id="如何实现？">如何实现？</h2><h3 id="使用ms（主程序与子程序）实现">使用ms（主程序与子程序）实现</h3><p><img lazyload src="/images/loading.svg" data-src="https://s2.loli.net/2023/04/30/7ya4TzAIBjoqvVZ.png" alt="image-20230430225702377"></p><p>KWIC类：</p><p><img lazyload src="/images/loading.svg" data-src="https://s2.loli.net/2023/04/30/tWIfxOB7jsG2NVd.png" alt="image-20230430231140471"></p><p>直接使用这四个成员变量多少有点过于困难了，什么年代还在用char数组？</p><p>果断放弃了，按照上面的要求的话，一个input函数写了这么多行属实难蚌</p><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Input function reads the raw data from the specified file and stores it in the core storage.</span></span><br><span class="line"><span class="comment"> * If some system I/O error occurs the program exits with an error message.</span></span><br><span class="line"><span class="comment"> * The format of raw data is as follows. Lines are separated by the line separator</span></span><br><span class="line"><span class="comment"> * character(s) (on Unix &#x27;\n&#x27;, on Windows &#x27;\r\n&#x27;). Each line consists of a number of</span></span><br><span class="line"><span class="comment"> * words. Words are delimited by any number and combination of the space chracter (&#x27; &#x27;)</span></span><br><span class="line"><span class="comment"> * and the horizontal tabulation chracter (&#x27;\t&#x27;). The entered data is parsed in the</span></span><br><span class="line"><span class="comment"> * following way. All line separators are removed from the data, all horizontal tabulation</span></span><br><span class="line"><span class="comment"> * word delimiters are replaced by a single space character, and all multiple word</span></span><br><span class="line"><span class="comment"> * delimiters are replaced by a single space character. Then the parsed data is represented</span></span><br><span class="line"><span class="comment"> * in the core as two arrays: chars_ array and line_index_ array.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> file Name of input file</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">input</span><span class="params">(String file)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实现input</span></span><br><span class="line">    <span class="comment">// 期望处理后的目标</span></span><br><span class="line">    <span class="comment">// All line separators are removed from the data, all horizontal tabulation</span></span><br><span class="line">    <span class="comment">// word delimiters are replaced by a single space character, and all multiple word</span></span><br><span class="line">    <span class="comment">// delimiters are replaced by a single space character.</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">FileReader</span> <span class="variable">inputFileReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileReader</span>(file);</span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">inputFileBufferedReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(inputFileReader);</span><br><span class="line"></span><br><span class="line">        <span class="type">CharArrayWriter</span> <span class="variable">caw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CharArrayWriter</span>(); <span class="comment">// 用来向chars中写入数据</span></span><br><span class="line">        String line;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> ((line = inputFileBufferedReader.readLine()) != <span class="literal">null</span>) &#123;</span><br><span class="line">            caw.write(line);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        chars_ = caw.toCharArray();</span><br><span class="line">        caw.close();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 需要按照要求进一步处理chars_</span></span><br><span class="line">        <span class="comment">// 把所有分隔符都换成单个空格，除了换行符</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">text1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(chars_);</span><br><span class="line">        text1 = text1.replaceAll(<span class="string">&quot; +&quot;</span>, <span class="string">&quot; &quot;</span>);</span><br><span class="line">        text1 = text1.replaceAll(<span class="string">&quot;\t&quot;</span>, <span class="string">&quot; &quot;</span>);</span><br><span class="line">        text1 = text1.replaceAll(<span class="string">&quot;\r&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">        chars_ = text1.toCharArray();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 没明白为什么要All line separators are removed from the data</span></span><br><span class="line">        line_index_ = <span class="keyword">new</span> <span class="title class_">int</span>[chars_.length];</span><br><span class="line">        <span class="type">int</span> <span class="variable">line_index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; chars_.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (chars_[i] == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">                line_index_[i] = line_index;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (chars_[i] == <span class="string">&#x27;\n&#x27;</span>) &#123; <span class="comment">//只判断“/n”，不用判断“/r/n”，已经涵盖了</span></span><br><span class="line">                line_index_[i] = line_index;</span><br><span class="line">                line_index++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;File not found!&quot;</span>);</span><br><span class="line">        System.exit(<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;IO error!&quot;</span>);</span><br><span class="line">        System.exit(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="使用OO实现">使用OO实现</h3><h4 id="Alphabetizer类">Alphabetizer类</h4><p>用于排序</p><p>为了便于修改排序算法</p><p>在该类中新建一个内部类，对按行进行排序</p><blockquote><p>单纯实现某两个类的自定义排序，直接使用Comparator</p><p><Type>就行</Type></p><p><a class="link" href="https://blog.csdn.net/kendleo/article/details/105298680">使用Comparator比较接口实现ArrayList集合排序_惟念依的博客-CSDN博客 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p><p>但如果像这道题一样还要获取排序后的Index就不行了，需要使用comparable接口</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 2023-Spring-Courses-软工二 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>智能系统中的嵌入式应用-I2C及7段数码管</title>
      <link href="/posts/2023-Summer-Courses-%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/%E6%99%BA%E8%83%BD%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BA%94%E7%94%A8-i2c%E5%8F%8A7%E6%AE%B5%E6%95%B0%E7%A0%81%E7%AE%A1.html"/>
      <url>/posts/2023-Summer-Courses-%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/%E6%99%BA%E8%83%BD%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BA%94%E7%94%A8-i2c%E5%8F%8A7%E6%AE%B5%E6%95%B0%E7%A0%81%E7%AE%A1.html</url>
      
        <content type="html"><![CDATA[<p>今天的内容主要是I2C的学习和使用</p><blockquote><p>很多地方不太专业，全凭个人胡乱理解</p></blockquote><h2 id="Python异常处理">Python异常处理</h2><p>老规矩还是先讲了会python</p><p>这部分没怎么听，虽然不太记得了但感觉可能用处不大</p><p>课上讲了个os和给程序传args比较有用</p><br><h2 id="7位数码管的使用">7位数码管的使用</h2><h3 id="简介">简介</h3><p>一开始就只有7段，所以叫7位数码管，后来右下角加了个<code>.</code>成了8段了，但已经叫习惯了</p><h3 id="如何接线">如何接线</h3><img lazyload src="/images/loading.svg" data-src="https://s2.loli.net/2023/04/25/Cls67fJ9XIchNPq.png" alt="image-20230425233924548" style="zoom: 33%;"> <img lazyload src="/images/loading.svg" data-src="https://s2.loli.net/2023/04/25/vNHQRLeBIwpS4Vs.png" alt="image-20230425233757865" style="zoom: 25%;"> <blockquote><p>老师课上画的图</p></blockquote><p>用4根两头孔的线连接，2根电源，1根SDA，1根SCL</p><p>VCC接5V/3.3V（5V会好一点</p><p>GND接地（树莓派上的GND</p><p>SDA-&gt;SDA1</p><p>SCL-&gt;SCL1</p><h3 id="树莓派引脚">树莓派引脚</h3><p><img lazyload src="/images/loading.svg" data-src="https://s2.loli.net/2023/04/28/vY4fDjdPmxiFLlZ.png" alt="image-20230428094607658"></p><blockquote><p>尽量不要使用GPIO14和GPIO15，为什么我也不知道</p><p>VCC尽量选5V的</p></blockquote><h3 id="终端使用注意（写代码前先检测下驱动">终端使用注意（写代码前先检测下驱动</h3><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 首先安装驱动</span></span><br><span class="line">modprobe i2c-dev</span><br><span class="line">modprobe i2c-bcm2835</span><br><span class="line">ls /dev/i2c-<span class="number">1</span></span><br><span class="line"><span class="comment"># 显示/dev/i2c-1</span></span><br><span class="line"></span><br><span class="line">i2cdetect -y <span class="number">1</span> <span class="comment"># 能显示出控制寄存器及对应设备的地址</span></span><br></pre></td></tr></table></figure></div><h3 id="控制寄存器和对应设备">控制寄存器和对应设备</h3><img lazyload src="/images/loading.svg" data-src="https://s2.loli.net/2023/05/09/wNJPAcILlijZFR8.png" alt="image-20230509165656273" style="zoom: 67%;"> <p>24所在行就是下一行设备对应的控制器</p><p>1.使用方法就是先向控制寄存器输入写入一些内容，就将其开启（或者关闭，还能控制显示亮度）</p><p>具体如下：</p><p><img lazyload src="/images/loading.svg" data-src="https://s2.loli.net/2023/05/09/GpaJMtdVw9gbUl1.png" alt="image-20230509165944792"></p><p>2.然后就可以向下面他对应的控制的设备写入内容来控制显示什么内容了</p><h3 id="代码">代码</h3><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> smbus2 <span class="keyword">import</span> SMBus</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">inputNumber = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">getInputNumber</span>():</span><br><span class="line">    <span class="keyword">global</span> inputNumber</span><br><span class="line">    inputNumber = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;Please input a number: &quot;</span>))</span><br><span class="line"></span><br><span class="line">my_table = <span class="built_in">dict</span>()</span><br><span class="line">my_table[<span class="string">&#x27;0&#x27;</span>] = <span class="number">0x3f</span></span><br><span class="line">my_table[<span class="string">&#x27;1&#x27;</span>] = <span class="number">0x06</span></span><br><span class="line">my_table[<span class="string">&#x27;2&#x27;</span>] = <span class="number">0x5b</span></span><br><span class="line">my_table[<span class="string">&#x27;3&#x27;</span>] = <span class="number">0x4f</span></span><br><span class="line">my_table[<span class="string">&#x27;4&#x27;</span>] = <span class="number">0x66</span></span><br><span class="line">my_table[<span class="string">&#x27;5&#x27;</span>] = <span class="number">0x6d</span></span><br><span class="line">my_table[<span class="string">&#x27;6&#x27;</span>] = <span class="number">0x7d</span></span><br><span class="line">my_table[<span class="string">&#x27;7&#x27;</span>] = <span class="number">0x07</span></span><br><span class="line">my_table[<span class="string">&#x27;8&#x27;</span>] = <span class="number">0x7f</span></span><br><span class="line">my_table[<span class="string">&#x27;9&#x27;</span>] = <span class="number">0x6f</span></span><br><span class="line"></span><br><span class="line">led = SMBus(bus=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># quan liang</span></span><br><span class="line">led.write_byte(<span class="number">0x24</span>, <span class="number">0x01</span>)</span><br><span class="line">led.write_byte(<span class="number">0x25</span>, <span class="number">0x11</span>)</span><br><span class="line">led.write_byte(<span class="number">0x26</span>, <span class="number">0x21</span>)</span><br><span class="line">led.write_byte(<span class="number">0x27</span>, <span class="number">0x31</span>)</span><br><span class="line"></span><br><span class="line">led.write_byte(<span class="number">0x34</span>, my_table[<span class="string">&#x27;0&#x27;</span>])</span><br><span class="line">led.write_byte(<span class="number">0x35</span>, my_table[<span class="string">&#x27;5&#x27;</span>])</span><br><span class="line">led.write_byte(<span class="number">0x36</span>, my_table[<span class="string">&#x27;2&#x27;</span>])</span><br><span class="line">led.write_byte(<span class="number">0x37</span>, my_table[<span class="string">&#x27;0&#x27;</span>])</span><br><span class="line"></span><br><span class="line">getInputNumber()</span><br><span class="line"></span><br><span class="line">seconds_left = inputNumber</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="comment"># xianshi</span></span><br><span class="line">    <span class="built_in">min</span> = seconds_left // <span class="number">60</span></span><br><span class="line">    sec = seconds_left % <span class="number">60</span></span><br><span class="line">    min_str1 = <span class="built_in">str</span>(<span class="built_in">min</span>)</span><br><span class="line">    min_str2 = min_str1.zfill(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    sec_str1 = <span class="built_in">str</span>(sec)</span><br><span class="line">    sec_str2 = sec_str1.zfill(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    led.write_byte(<span class="number">0x34</span>, my_table[min_str2[<span class="number">0</span>]])</span><br><span class="line">    led.write_byte(<span class="number">0x35</span>, my_table[min_str2[<span class="number">1</span>]])</span><br><span class="line">    led.write_byte(<span class="number">0x36</span>, my_table[sec_str2[<span class="number">0</span>]])</span><br><span class="line">    led.write_byte(<span class="number">0x37</span>, my_table[sec_str2[<span class="number">1</span>]])</span><br><span class="line"></span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    seconds_left -= <span class="number">1</span></span><br></pre></td></tr></table></figure></div>]]></content>
      
      
      <categories>
          
          <category> 2023-Summer-Courses-嵌入式开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 嵌入式开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>how-to-use-AI-painting</title>
      <link href="/posts/%E5%B7%A5%E5%85%B7%E5%AD%A6%E4%B9%A0/how-to-use-ai-painting.html"/>
      <url>/posts/%E5%B7%A5%E5%85%B7%E5%AD%A6%E4%B9%A0/how-to-use-ai-painting.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-使用Midjourney（目前已无法试用？">1. 使用Midjourney（目前已无法试用？</h2><p>试了几次发现没法用，估计得充值，订阅个计划才能用了</p><p>但也可以考虑找点免费的共享服务器？或者获取到别人的邀请链接？</p><p>登录<a class="link" href="https://www.midjourney.com/home/?callbackUrl=%2Fapp%2F">Midjourney <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p><p>然后左下角三个点展开，选择“Go to discord&quot;</p><p>找个频道向机器人输入/image，自动会弹出让输入prompt</p><p>然后就用不了（以前还是可以，也许有限额</p><p><img lazyload src="/images/loading.svg" data-src="https://s2.loli.net/2023/04/24/Q3LOZR5wGWoJq2C.png" alt="image-20230424162300993"></p><h2 id="2-考虑一些替代网站">2. 考虑一些替代网站</h2><p>我在油管上找了个视频<a class="link" href="https://www.youtube.com/watch?v=NAScnKW1N1I">https://www.youtube.com/watch?v=NAScnKW1N1I <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p><p>从评论区知道了这个<a class="link" href="https://www.bluewillow.ai/">BlueWillow | Free AI Art Generator <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p><p><img lazyload src="/images/loading.svg" data-src="https://s2.loli.net/2023/04/24/FvVwUeM65GhpdBS.png" alt="image-20230424162425993"></p><p>感觉效果一般般，也可能是描述太少</p><p><strong>记得把机器人加到自己的服务器频道</strong></p><blockquote><p>使用帮助：基本来自官网的教程</p><p><a class="link" href="https://www.bluewillow.ai/blog/mastering-the-art-of-prompting-seeds-weights-and-beyond">https://www.bluewillow.ai/blog/mastering-the-art-of-prompting-seeds-weights-and-beyond <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p><p>这篇里面有关于 <code>--ar 3:2</code>，就是aspect ration，图片比例</p><p><a class="link" href="https://www.bluewillow.ai/prompt-glossary">https://www.bluewillow.ai/prompt-glossary <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p><p>这是prompt词汇表</p></blockquote><p>随便试了个某个视频里看来的prompt:</p><p>underwater photograph of a reef, beautiful reef on the ocean floor, clear blue water, rays of light shining through the ocean, travel photography, highly detailed, 4k, cinematic photography --ar 3:2</p><p><img lazyload src="/images/loading.svg" data-src="https://s2.loli.net/2023/04/24/9FW4gnfs1CryHxL.png" alt="image-20230424165038386"></p><h2 id="3-一些其他的网站">3. 一些其他的网站</h2><p><a class="link" href="https://6pen.art/">6pen Art <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>最早别人推给我的，手机上也有app（来自青梧道人，咳咳</p>]]></content>
      
      
      <categories>
          
          <category> 工具学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AI </tag>
            
            <tag> AI绘画 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hw1手画记录</title>
      <link href="/posts/23-Spring-Courses-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/hw1%E6%89%8B%E7%94%BB%E8%AE%B0%E5%BD%95.html"/>
      <url>/posts/23-Spring-Courses-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/hw1%E6%89%8B%E7%94%BB%E8%AE%B0%E5%BD%95.html</url>
      
        <content type="html"><![CDATA[<p>因为老师不让交手画的图片，但实际上有些手画的图片比较容易理解，所以只能找个地方存点手稿。</p><h2 id="Problem4">Problem4</h2><p>时间片轮换调度算法</p><p>关键：先来先服务，队列，时间片</p><p>轮转调度算法Round-Robin(RR)<br>在分时系统中都采用时间片轮转算法进行进程调度。时间片是指一个较小的时间间隔，通常为10-100毫秒。<strong>在简单的轮转算法中，系统将所有的就绪进程按先来先服务（即FIFO）规则排成一个队列</strong>，将CPU分配给队首进程，且规定每个进程最多允许运行一个时间片；<strong>若时间片使用完进程还没有结束，则被加入就绪FIFO队列队尾</strong>，并把CPU交给下一个进程。时间片轮转算法<strong>只用于进程调</strong>度，它属于<strong>抢占调度</strong>方式。</p><p>优点 ：CPU分配相对公平；平均响应时间较短缺点：不利于紧急作业，而且当进程的运行时间都相近时，平均的等待时间比较长，甚至不如先来先服务算法。</p><p><img lazyload src="/images/loading.svg" data-src="https://s2.loli.net/2023/04/18/VAPiRvcHwOlfmMa.jpg" alt></p><br><h2 id="Problem5">Problem5</h2><p>只能说由于没听课，连这概念都没听说过</p><blockquote><p>参考资料:</p><p>教材P87-91</p><p>Linux fork,vfork,clone : <a class="link" href="https://blog.csdn.net/gatieme/article/details/51417488">https://blog.csdn.net/gatieme/article/details/51417488 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p><p>针对本题：<a class="link" href="https://blog.csdn.net/qq_35619728/article/details/100995771">https://blog.csdn.net/qq_35619728/article/details/100995771 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p></blockquote><p>zhy学长的笔记</p><p><img lazyload src="/images/loading.svg" data-src="https://s2.loli.net/2023/04/18/SmqraUY3ZN8ybxl.png" alt="image-20230418222656359"></p><br><h2 id="Problem6">Problem6</h2><blockquote><p>图片来源：<a class="link" href="https://max.book118.com/html/2017/0206/88739072.shtm">《操作系统教学资料》操作系统习题讲解.130426.doc-原创力文档 (book118.com) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p><p>也许有关：<a class="link" href="https://www.bilibili.com/video/BV1YE411D7nH?p=67&amp;vd_source=6be38b36e75fc2dd932ed882233a8a39">5.1_6_假脱机技术_哔哩哔哩_bilibili <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p></blockquote><p><img lazyload src="/images/loading.svg" data-src="https://s2.loli.net/2023/04/18/8y1tLUYw5i6QjVH.png" alt="QQ截图20230418224639"></p><h3 id="响应比前面为什么要-1？">响应比前面为什么要+1？</h3><p><img lazyload src="/images/loading.svg" data-src="https://s2.loli.net/2023/04/19/lgyNZSPWvcoTnsG.png" alt="image-20230419115602251"></p><blockquote><p>比较的时候是没有影响的</p></blockquote><br><h2 id="Problem8">Problem8</h2><h4 id="8-1-对于各种地址的理解">8.1 对于各种地址的理解</h4><blockquote><p><a class="link" href="https://www.cnblogs.com/pipci/p/12391439.html">通俗理解物理地址、逻辑地址、线性地址、虚拟地址、有效地址的区别 - pipci - 博客园 (cnblogs.com) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p><p>注意：这些地址应该是在段页式存储下才有的，比如作业P8中采用简单的<strong>分页式存储</strong>，自然只有逻辑地址和物理地址的说法，不会有什么端内偏移量之类的</p></blockquote><p>**物理地址：**物理地址就是内存单元的绝对地址，比如你有一个4G的内存条插在电脑上，物理地址0x0000就表示内存条的第一个存储单元，0x0010就表示内存条的第17个存储单元，不管CPU内部怎么处理地址，最终访问的都是物理地址。在CPU实模式下“段基址+段内偏移地址”就是物理地址，CPU可以使用此地址直接访问内存。</p><p>**线性地址、虚拟地址：**CPU在保护模式下，“段基址+段内偏移地址”叫做线性地址，注意，保护模式下段基址寄存器中存储的不是真正的段基值（和实模式的含义不一样），而是被称为“段选择子”的东西，通过段选择子在GDT（全局描述表）中找到真正的段基值。另外，如果CPU在保护模式下没有开启分页功能，则线性地址就被当做最终的物理地址来用，若开启了分页功能，则线性地址就叫虚拟地址（在没开启分页功能的情况下线性地址和虚拟地址就是一回事）。但是，如果开启分页功能，虚拟地址（或线性地址）还要通过页部件电路转换成最终的物理地址。</p><p>**逻辑地址、有效地址：**无论CPU在什么模式下，段内偏移地址又称为有效地址或者逻辑地址（只是叫法不一样罢了），例如实模式下 “mov ax, [0x7c00]”，0x7c00就是逻辑地址（或有效地址），但这条指令最终操作的物理地址是DS*16+0x7c00</p><p><img lazyload src="/images/loading.svg" data-src="https://s2.loli.net/2023/04/19/7Wv5slT9Ef4S2IY.png" alt></p><h4 id="8-2-页式、段式、段页式">8.2 页式、段式、段页式</h4><blockquote><p><a class="link" href="https://blog.csdn.net/yilongdashi/article/details/82707022">存储管理之页式、段式、段页式存储 以及 优缺点_页式和段式_驭风男孩的博客-CSDN博客 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p><p>关于页框：P9需要知道</p><p><a class="link" href="https://blog.csdn.net/biggerbugger/article/details/105932823">段、页、页框、页表、页表项_页框号和页号的区别_biggerbugger的博客-CSDN博客 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p></blockquote><br><h2 id="Problem-9">Problem 9</h2><h4 id="1-Clock调度算法">1. Clock调度算法</h4><p><img lazyload src="/images/loading.svg" data-src="https://s2.loli.net/2023/04/19/qtVnIOS3m7ZuxvF.png" alt="image-20230419192439946"></p><p>简单的CLOCK 算法实现方法：为每个页面设置一个访问位，再将内存中的页面都通过链接指针链接成一个循环队列。</p><p>①当某页被访问时，其访问位置为1。当需要淘汰一个页面时，只需检查页的访问位。</p><p>②如果是0，就选择该页换出；如果是1，则将它置为0，暂不换出，继续检查下一个页面，若第一轮扫描中所有页面都是1，则将这些页面的访问位依次置为0后，再进行第二轮扫描，第二轮扫描中一定会有访问位为0的页面</p><p><strong>(指针是循环指针，不是想到哪就到哪，只能一步步循环移动，发生替换或者刚开始载入时，指针才会移动，否则指针不会移动)</strong></p><h4 id="2-关于驻留集">2. 关于驻留集</h4><p>1.驻留集对于分页式的虚拟内存，在进程准备执行时，不需要也不可能把一个进程的所有页都读入主存。因此，操作系统必须决定读取多少页，即决定给特定的进程分配几个页框。给一个进程分配的物理页框的集合就是这个进程的驻留集。<br>2.驻留集的大小需要考虑以下几点：<br>1）分配给一个进程的存储量越小，任何时候驻留在主存中的进程数就越多，从而可以提高处理机的时间利用效率。<br>2）若一个进程在主存中的页数过少，则尽管有局部性原理，页错误率仍然会相对较高。<br>3）若页数过多，则由于局部性原理，给特定的进程分配更多的主存空间对该进程的错误率没有明显的影响</p><h4 id="3-工作集算法WS">3. 工作集算法WS</h4><p><img lazyload src="/images/loading.svg" data-src="https://s2.loli.net/2023/04/19/TAu2P4HrtJIXBNL.png" alt="image-20230419222049299"></p><p>书上写的比较复杂，但如果这个答案是正确的话其实并不复杂</p><p>例如t=7的时候，先看当前的是P1，因为delta=2，所以往前看两个，就是之前的这两个也要保留下来，前两个是P4、P5，那么t=7的时候就要有P1,P4,P5其他不能有，再跟前一时刻比较，多出来的填到IN，少的就OUT，t=7正好是相等所以没有IN，也没有OUT</p><br><h2 id="对word分页符的使用">对word分页符的使用</h2><p>以前都不知道有这回事</p><blockquote><p><a class="link" href="https://blog.csdn.net/weixin_38314865/article/details/122701834">https://blog.csdn.net/weixin_38314865/article/details/122701834 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p></blockquote><p><img lazyload src="/images/loading.svg" data-src="https://s2.loli.net/2023/04/19/vSHYr3lGVUtkXLf.png" alt="image-20230419114840440"></p><p>比如7、8两题本来连在一起，现在可以将其分开：在“在”字，也就是第8题的开头处插入分页符就行了</p><p><img lazyload src="/images/loading.svg" data-src="https://s2.loli.net/2023/04/19/Z2XqPO6YmDueoIB.png" alt="image-20230419164704807"></p>]]></content>
      
      
      <categories>
          
          <category> 23-Spring-Courses-操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> homework </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>latex-learning</title>
      <link href="/posts/%E5%B7%A5%E5%85%B7%E5%AD%A6%E4%B9%A0/latex-learning.html"/>
      <url>/posts/%E5%B7%A5%E5%85%B7%E5%AD%A6%E4%B9%A0/latex-learning.html</url>
      
        <content type="html"><![CDATA[<p>记录下一些latex的用法</p><p>收藏夹太满了</p><p>并且懒得每次都因为同样的问题去查</p><h3 id="1-图片插入相关-单张">1.图片插入相关-单张</h3><div class="highlight-container" data-rel="Latex"><figure class="iseeu highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;figure&#125;[h]</span><br><span class="line">  <span class="keyword">\centering</span></span><br><span class="line">  <span class="keyword">\includegraphics</span>[width=0.8<span class="keyword">\textwidth</span>]&#123;1.jpg&#125;</span><br><span class="line">  <span class="keyword">\caption</span>&#123;question1<span class="keyword">\\</span>文法一是LL(1)文法&#125;</span><br><span class="line"><span class="keyword">\end</span>&#123;figure&#125;</span><br></pre></td></tr></table></figure></div><blockquote><p>就写个[h]得了，[htp]反而不太对</p><p><strong>最好写[H]吧，保证在当前位置，编译原理那个环境怪怪的，大H用不了，引了宏包还是不行…</strong></p></blockquote><p>图片因为排版而位置不受控制在LaTex中，\begin{figure}[~]是图片环境，常用选择项[htbp]是浮动格式：<br>[h] ~ here，当前位置。将图形放置在正文文本中给出该图形环境的地方。如果本页所剩页面不够，这一参数将不起作用。<br>[t] ~ top，顶部。将图形放置在页面的顶部。<br>[b] ~ bottom，底部。将图形放置在页面的底部。<br>[p] ~ page of its own，浮动页。将图形放置在一个允许有浮动对象的页面上。一般使用[htb]这样的组合，只用[h]是没有用的。这样组合的意思就是LaTex会尽量满足排在前面的浮动格式，就是h-t-b这个顺序，让排版的效果尽量好。<br>[!h]只是试图放在当前位置。如果页面剩下的部分放不下，还是会跑到下一页的。一般而言，用[!h]选项通常会出现不能正确放置的问题，所以常用[ht]、[htbp]等。这里加感叹号的意思是 忽略 “美学” 标准。</p><blockquote><p>参数详解链接：<a class="link" href="https://blog.csdn.net/king0406/article/details/51252298">https://blog.csdn.net/king0406/article/details/51252298 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 工具学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> latex </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《天空之城》观感</title>
      <link href="/posts/%E8%A7%82%E5%BD%B1%E8%AE%B0%E5%BD%95/%E3%80%8A%E5%A4%A9%E7%A9%BA%E4%B9%8B%E5%9F%8E%E3%80%8B%E8%A7%82%E6%84%9F.html"/>
      <url>/posts/%E8%A7%82%E5%BD%B1%E8%AE%B0%E5%BD%95/%E3%80%8A%E5%A4%A9%E7%A9%BA%E4%B9%8B%E5%9F%8E%E3%80%8B%E8%A7%82%E6%84%9F.html</url>
      
        <content type="html"><![CDATA[<h3 id="啥时候看的？">啥时候看的？</h3><p>应该是2022年9月23号（应该是礼拜四）和24号看的了，23号开始看的晚了，就没看完。至于为啥会看，因为当时发现每天看短视频的时间有点长，与其越刷越造成所谓信息茧房的困境，不如抽点时间看部电影。所以就去找了这部电影看看。</p><h3 id="观感">观感</h3><h4 id="配乐">配乐</h4><p>原来配乐也是出自久石让之手</p><p>这首配乐很久以前我就听过了（又想起一句诗“青灯有味似儿时”），还是存在现在已经被称作老年机的手机里的，当时还小，只觉得这歌很有故事，好听是好听，可就总让人觉得有点伤感。现在再听，伤感依旧，因为添了许多怀念和想念，既是空间上的，亦是时间上的。</p><h4 id="内容">内容</h4><p><img lazyload src="/images/loading.svg" data-src="https://s2.loli.net/2023/04/15/higCmGaNVSywB8n.png" alt="屏幕截图 2022-09-23 191425"></p><p>说实话看完电影，最大的感触是希望，以及美好，但又很难说哪些情节给了我这种感觉，因为它似乎是一种贯穿始终的东西。即使天空之城崩塌，但依旧拾起希望，抬头望向天空，闭上双眼感受着风的轻抚。</p><p>另一方面，又觉得这样的奇遇终究是不可能的，有种幻想破灭的感觉，尤其是这空空荡荡的天空之城，让我感到有些无奈和迷茫。</p><p><img lazyload src="/images/loading.svg" data-src="https://s2.loli.net/2023/04/15/3Dh2i7rPbHf5FJS.png" alt="屏幕截图 2022-09-23 191450"></p><p>“伴随着音乐的响起，我感受到远古文明的没落带来的追远的淡淡忧伤，但同时又无比庆幸世间的美好永驻心间，不觉间泪水划过眼角。那种无法言语的复杂情感恕我无法言说，她好比清晨山林间回荡的鸟鸣，幽邃深沉的黑夜中闪亮的星辰，又或像淡蓝的天空初亮时第一束晨曦，一切都是新生，告别了过往，憧憬着未来，带着那份爱与感动重新踏上新的旅程，希望永远都在前方。”（南风古居）</p><h4 id="其他">其他</h4><ol><li><p>这里面的机器人有点哈人，我感觉跟迪迦里面有一集的怪兽有点像</p><p>【迪迦奥特曼.19.-奔向宇宙（上）】  <a class="link" href="https://www.bilibili.com/video/BV18t41197x2/?share_source=copy_web&amp;vd_source=26ebf8878a6450d881a22145eebf9c9f&amp;t=244">https://www.bilibili.com/video/BV18t41197x2/?share_source=copy_web&amp;vd_source=26ebf8878a6450d881a22145eebf9c9f&amp;t=244 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p></li><li><p>毁灭咒语：巴鲁斯</p><p>记住了（2023.4.15考证，并没有记住…</p></li></ol><h4 id="后记">后记</h4><p>2023年4月15看到这篇文章感慨自己当时还能看几部电影，最近感觉一直刷刷B站短视频，切片之类的有点颓废，貌似跟开头说的一样，樂</p>]]></content>
      
      
      <categories>
          
          <category> 观影记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 电影 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一文带你慢且不通SEOSLab2</title>
      <link href="/posts/2023-Spring-Courses-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E4%B8%80%E6%96%87%E5%B8%A6%E4%BD%A0%E6%85%A2%E4%B8%94%E4%B8%8D%E9%80%9Aseoslab2.html"/>
      <url>/posts/2023-Spring-Courses-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E4%B8%80%E6%96%87%E5%B8%A6%E4%BD%A0%E6%85%A2%E4%B8%94%E4%B8%8D%E9%80%9Aseoslab2.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>主要是针对OS Lab2的一些记录，自己看看的</p></blockquote><h2 id="makefile解读">makefile解读</h2><p><img lazyload src="/images/loading.svg" data-src="https://s2.loli.net/2023/04/27/XHoR61YnEw3OAlr.png" alt="image-20230427102950131"></p><p>一共三条，<code>make onlyCpp</code>主要是一开始没写汇编的打印函数，全用的cout，先编译出来看看效果</p><p>同时也是为了便于调试，打断点（./main的过程可能也是可以调的，没试</p><br><h2 id="实验开始前">实验开始前</h2><h3 id="装库">装库</h3><p>gcc-multilib 和 g+±multilib</p><p>不然后面会报错</p><p><img lazyload src="/images/loading.svg" data-src="https://s2.loli.net/2023/04/27/1QvgZUe8h4tfKy3.png" alt="image-20230427103322790"></p><h3 id="制作软盘并建立结构">制作软盘并建立结构</h3><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkfs.fat -C a.img 1440</span><br><span class="line"><span class="built_in">mkdir</span> mountlab2 <span class="comment"># 挂载点</span></span><br><span class="line">sudo mount ./a.img ./mountlab2 <span class="comment"># 进行挂载</span></span><br><span class="line"><span class="built_in">cd</span> ./mountlab2 <span class="comment"># 就可以进行一些创建之类的操作了</span></span><br></pre></td></tr></table></figure></div><p>补充：</p><ol><li><p>创建层及目录mkdir可加-p参数</p><p><code>mkdir -p a/b/c</code></p></li><li><p>进入挂载好的目录之后，切换成root创建各种东西会方便点</p><p>如果是普通用户vim文件时可能显示文件read only</p></li><li><p>在盘的根路径下使用tree命令查看结构</p></li></ol><br><h2 id="代码部分">代码部分</h2><p>直接从主代码开始看</p><p><strong>整个结构，很重要：</strong></p><p><img lazyload src="/images/loading.svg" data-src="https://s2.loli.net/2023/04/27/Dx4ABkqjgGSsz28.png" alt="image-20230427143504426"></p><h3 id="1-初始化BPB信息">1. 初始化BPB信息</h3><p>打开文件，用自建的BPB类读取相关信息</p><h4 id="BPB类如下：">BPB类如下：</h4><p><img lazyload src="/images/loading.svg" data-src="https://s2.loli.net/2023/04/27/u3E6vf5xDYZ4RLl.png" alt="image-20230427142737793"></p><h4 id="init函数读取">init函数读取</h4><p>bpb-&gt;init(fat12)进行读取</p><p><strong>先读到bpb类的成员函数里面（两行就行</strong></p><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// BPB从第11个字节处开始，0-2为短跳转指令，3-10为厂商名</span></span><br><span class="line"><span class="built_in">fseek</span>(fat12, <span class="number">11</span>, SEEK_SET);</span><br><span class="line"><span class="built_in">fread</span>(<span class="keyword">this</span>, <span class="number">1</span>, <span class="number">25</span>, fat12); <span class="comment">// BPB长度为25字节</span></span><br></pre></td></tr></table></figure></div><p><strong>再初始化一些后面可能用到的全局变量</strong></p><p>要计算的是四个</p><p>BytesPerClus = 1 * 512</p><p>FATBase = 1 * 512</p><p>RootDirBase = (1 + 2 * 9) * 512</p><p>DataBase = ((224 * 32 + 32 - 1) / 512 + 1 + 2 * 9) * 512</p><h3 id="2-创建root根节点（所要建立的那个树">2. 创建root根节点（所要建立的那个树</h3><h4 id="Node类如下：">Node类如下：</h4><p>以及还有一部分get set方法</p><p><img lazyload src="/images/loading.svg" data-src="https://s2.loli.net/2023/04/27/lKzvMIarEkH984i.png" alt="image-20230427145121947"></p><h4 id="设置一些root的成员变量">设置一些root的成员变量</h4><p><img lazyload src="/images/loading.svg" data-src="https://s2.loli.net/2023/04/27/sM3mtyTRpl2ZcA9.png" alt="image-20230427145612583"></p><h3 id="3-开始创建树，利用根目录区开始">3. 开始创建树，利用根目录区开始</h3><blockquote><p>根目录区其实就是很多目录项（这里的目录包含文件，比如我使用的img文件中根目录下就应该有三项</p><p>0x2600根目录区开始</p><p><img lazyload src="/images/loading.svg" data-src="https://s2.loli.net/2023/04/27/ZnjXdrGlfqoF2Js.png" alt="image-20230427150108412"></p><p>后面不用管，注意文件名是8+3</p></blockquote><p>由此开始读文件（并且建立树结构）之旅</p><p><img lazyload src="/images/loading.svg" data-src="https://s2.loli.net/2023/04/27/nrEPK7HThxu3JLW.png" alt="image-20230427150150503"></p><p><strong>RootDirEntry结构如下：</strong></p><blockquote><p>RootDirEntry纯粹就是个读东西存放用的工具</p><p>一共32字节，也就是两行</p><p><img lazyload src="/images/loading.svg" data-src="https://s2.loli.net/2023/04/27/6Uq8TxrPiVkyBpX.png" alt="image-20230427151107912"></p><p>这样就是一个目录项</p></blockquote><p><img lazyload src="/images/loading.svg" data-src="https://s2.loli.net/2023/04/27/jf5dEMYhKNoUHv3.png" alt="image-20230427150323300"></p><h4 id="RootDirEntry里有readFile方法，从这个开始递归读取">RootDirEntry里有readFile方法，从这个开始递归读取</h4><blockquote><p>注1：讲道理这个readFile方法其实就调用了一次，不该作为RootDirEntry的成员方法，而应该是全局的一个函数</p><p>注2：RootDirEntry类的DIR_Name就是那个占11字节的名字</p><p>注3：就是在这里获取了DIR_FstClus，后面读取内容会用到</p></blockquote><h4 id="主体结构如下">主体结构如下</h4><blockquote><p>注1：根目录项的文件属性</p><p><img lazyload src="/images/loading.svg" data-src="https://s2.loli.net/2023/04/27/lCxYyKrFcNUXia3.png" alt="image-20230427154655628"></p></blockquote><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">RootDirEntry::readFile</span><span class="params">(FILE *fat12)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> base = RootDirBase; <span class="comment">// 读取位置，起始位置为根目录区首地址</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; RootEntCnt; i++) &#123;</span><br><span class="line">        <span class="built_in">fseek</span>(fat12, base, SEEK_SET);</span><br><span class="line">        <span class="built_in">fread</span>(<span class="keyword">this</span>, <span class="number">1</span>, <span class="number">32</span>, fat12); <span class="comment">// 读32字节，即一个条目的大小</span></span><br><span class="line">        base += <span class="number">32</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;<span class="built_in">isInvalidName</span>()) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((<span class="keyword">this</span>-&gt;DIR_Attr &amp; <span class="number">0x10</span>) == <span class="number">0</span>) &#123; <span class="comment">// 属性是0x10表示是文件</span></span><br><span class="line">            string name = <span class="built_in">dealFileName</span>(<span class="keyword">this</span>-&gt;DIR_Name); <span class="comment">// 处理文件名</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 创建node* fileNode将其加入到root的children里</span></span><br><span class="line">            <span class="comment">// 略</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 读取文件内容</span></span><br><span class="line">            <span class="built_in">readFileContent</span>(fat12, fileChild);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((<span class="keyword">this</span>-&gt;DIR_Attr &amp; <span class="number">0x20</span>) == <span class="number">0</span>) &#123;     <span class="comment">// 0x20表示是目录</span></span><br><span class="line">            string name = <span class="built_in">dealDirName</span>(<span class="keyword">this</span>-&gt;DIR_Name); <span class="comment">// 处理目录名</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建node* dirNode将其加入到root的children里</span></span><br><span class="line">            <span class="comment">// 略</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 读取目录，更确切的来说是根目录的子目录的内容</span></span><br><span class="line">            <span class="built_in">readDirContent</span>(fat12, dirChild);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><strong>bool RootDirEntry::isInvalidName()：</strong></p><p>读取根目录项时判断哪些是需要的文件或目录</p><p><img lazyload src="/images/loading.svg" data-src="https://s2.loli.net/2023/04/27/i2hB95QRzKj3Aor.png" alt="image-20230427154404957"></p><p>以’\0’开头（就是空的目录项）或者出现11个字节内出现任何不合法字符就是invalid</p><blockquote><p>可如下验证：</p><p><img lazyload src="/images/loading.svg" data-src="https://s2.loli.net/2023/04/27/O92YWmEZfbXvF4r.png" alt="image-20230427154538896"></p></blockquote><h4 id="RootDirEntry-readFile内的四个函数">RootDirEntry::readFile内的四个函数</h4><p>string name = <strong>dealFileName</strong>(entry-&gt;getDirName());</p><p><strong>readFileContent</strong>(fat12, fileChild);</p><p>string name = <strong>dealDirName</strong>(entry-&gt;getDirName());</p><p><strong>readDirContent</strong>(fat12, dirChild);</p><p>递归就是靠这两个readContent函数实现的</p><blockquote><p>个人感觉递归的关键在于</p><p><strong>如果根目录下是一个目录，那么在数据区对应的地方也是会有一个32字节的目录项，就跟根目录区是一样的构成</strong></p><p><strong>数据区并不全是数据，非根目录的目录也是会在这的</strong></p></blockquote><blockquote><p>复看代码的时候发现一处问题</p><p>linux并不是文件都有扩展名，所以在dealFileName的时候，文件名是不一定包含’.'的</p><p><img lazyload src="/images/loading.svg" data-src="https://s2.loli.net/2023/04/27/YuvREt7VBNdKxw5.png" alt="image-20230427160658080"></p><p><img lazyload src="/images/loading.svg" data-src="https://s2.loli.net/2023/04/27/nxRQVtFbqlg2WkK.png" alt="image-20230427160823064"></p><p>但好像这次实验又说了文件会有扩展名，所以就不修这个地方了，要修的话无非就是判断下后面有没有扩展名，没有的话就把’.'去掉而已</p></blockquote><h4 id="getFatValue">getFatValue()</h4><p>实现两个readContent函数还有一个关键的地方在于获取fat表项的值</p><p><img lazyload src="/images/loading.svg" data-src="https://s2.loli.net/2023/04/27/hul6sjEVRDn9XJy.png" alt="image-20230427162922356"></p><p><img lazyload src="/images/loading.svg" data-src="https://s2.loli.net/2023/04/27/57hN1yMDAeGI2CL.png" alt="image-20230427162954663"></p><blockquote><p>小端存储：低地址向高地址生长</p><p>数据的高字节在高位就是小端存储</p><p>图中的例子，读到HOUSE的FstClus=3然后</p><p>0x200 + 3 * 3 / 2 = 0x204</p><p>把204(f0) 205(ff)的字节读出来是fff0，奇数，取高12位fff</p><p>说明结束了，HOUSE的内容只在簇3</p><p>然后簇3-2=簇1</p><p>数据区起始在0x4200一个簇512字节就是0x200所以0x4400的数据就是它的内容</p><p><img lazyload src="/images/loading.svg" data-src="https://s2.loli.net/2023/04/27/fqAZPeU1lI3tp6x.png" alt="image-20230427164448142"></p></blockquote><p><img lazyload src="/images/loading.svg" data-src="https://s2.loli.net/2023/04/27/4klpcnRqob28ANB.png" alt="image-20230427163104689"></p><p>至此，文件终于读完了！树也构建好了</p><h3 id="4-汇编实现的打印函数">4. 汇编实现的打印函数</h3><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">global myAsmPrint</span><br><span class="line"></span><br><span class="line">section .text</span><br><span class="line">myAsmPrint:</span><br><span class="line">; 利用栈传递参数</span><br><span class="line">moveax,4; 系统调用号</span><br><span class="line">movebx,1 ; 文件描述符，1表示stdout</span><br><span class="line">movecx,[esp+4]; char * s ;加4是因为调用函数首先要压IP进栈，接下来的两个</span><br><span class="line">movedx,[esp+8]; length </span><br><span class="line">int80h</span><br><span class="line">ret</span><br></pre></td></tr></table></figure></div><h4 id="关于参数压栈顺序">关于参数压栈顺序</h4><p><a class="link" href="https://blog.csdn.net/zhengnianli/article/details/106684135">(2条消息) C语言 | 函数参数压栈的顺序是？_函数参数压栈顺序_嵌入式大杂烩的博客-CSDN博客 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p><p>栈应该是高地址往地址生长</p><p>C/C++ 参数从右往左压栈，而之前要先压入一个IP，所以栈从高到低是</p><p>长度、首地址、IP</p><p><img lazyload src="/images/loading.svg" data-src="https://s2.loli.net/2023/04/27/LPSv248pch5xslB.png" alt="image-20230427165628885"></p><h3 id="5-实现cat命令">5. 实现cat命令</h3><p>cat和ls都用到了一个关键的函数</p><h4 id="findFileNodeByName">findFileNodeByName</h4><p>找到的话就返回节点，没找到或者找的过程中有不存在的，也会返回空</p><h3 id="6-实现ls和ls-l">6. 实现ls和ls -l</h3><blockquote><p>注意<code>ls -</code> 是要报错的</p></blockquote><p>ls 和 ls -l差不太多</p><p>递归实现下listAllContentWithoutL和listAllContentWithL就行</p><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ls指令，要处理的东西还是很多的</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ls</span><span class="params">(vector&lt;string&gt; &amp;commands)</span> </span>&#123;</span><br><span class="line">    <span class="type">bool</span> haveL = <span class="literal">false</span>;</span><br><span class="line">    <span class="type">bool</span> haveDir = <span class="literal">false</span>;</span><br><span class="line">    <span class="type">int</span> dirCount = <span class="number">0</span>;</span><br><span class="line">    string dir;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; commands.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (commands[i][<span class="number">0</span>] == <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">            haveL = <span class="literal">true</span>;</span><br><span class="line">            <span class="type">bool</span> validL = <span class="built_in">isValidL</span>(commands[i]);</span><br><span class="line">            <span class="keyword">if</span> (!validL) &#123; <span class="comment">// 如果指令不合法，提示输入错误，并直接结束</span></span><br><span class="line">                <span class="built_in">myPrint</span>(ERROR_COMMAND);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            haveDir = <span class="literal">true</span>;</span><br><span class="line">            dir = commands[i];</span><br><span class="line">            dirCount++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 执行到这里如果有l也是合法的</span></span><br><span class="line">    <span class="keyword">if</span> (dirCount &gt; <span class="number">1</span>) &#123; <span class="comment">// 有多个目录是不合法的</span></span><br><span class="line">        <span class="built_in">myPrint</span>(<span class="string">&quot;Too much directory!&quot;</span>);</span><br><span class="line">        <span class="built_in">myPrint</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (haveL) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!haveDir) &#123; <span class="comment">// 有l 没目录</span></span><br><span class="line">            <span class="built_in">listAllContentWithL</span>(root);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 有l 有目录</span></span><br><span class="line">            Node *file = <span class="built_in">findFileNodeByName</span>(dir);</span><br><span class="line">            <span class="keyword">if</span> (file != <span class="literal">nullptr</span>) &#123; </span><br><span class="line">                <span class="keyword">if</span> (file-&gt;<span class="built_in">getFileType</span>() == FileType::FILE) &#123;</span><br><span class="line">                    <span class="built_in">myPrint</span>(<span class="string">&quot;This is a File!\n&quot;</span>);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">listAllContentWithL</span>(file);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">myPrint</span>(CANNOT_FOUND);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!haveDir) &#123; <span class="comment">// 没l 没目录</span></span><br><span class="line">            <span class="built_in">listAllContentWithoutL</span>(root);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 没l 有目录</span></span><br><span class="line">            Node *file = <span class="built_in">findFileNodeByName</span>(dir);</span><br><span class="line">            <span class="keyword">if</span> (file != <span class="literal">nullptr</span>) &#123; <span class="comment">// 如果文件存在，则输出，不存在则报错退出</span></span><br><span class="line">                <span class="keyword">if</span> (file-&gt;<span class="built_in">getFileType</span>() == FileType::FILE) &#123;</span><br><span class="line">                    <span class="built_in">myPrint</span>(<span class="string">&quot;This is a File!\n&quot;</span>);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">listAllContentWithoutL</span>(file);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">myPrint</span>(CANNOT_FOUND);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>]]></content>
      
      
      <categories>
          
          <category> 2023-Spring-Courses-操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
